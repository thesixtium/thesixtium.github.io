{"version":3,"file":"flowchart-elk-definition-30f8bb2c.js","sources":["../src/diagrams/flowchart/elk/render-utils.ts","../src/diagrams/flowchart/elk/flowRenderer-elk.js","../src/diagrams/flowchart/elk/styles.ts","../src/diagrams/flowchart/elk/flowchart-elk-definition.ts"],"sourcesContent":["export interface TreeData {\n  parentById: Record<string, string>;\n  childrenById: Record<string, string[]>;\n}\n\nexport const findCommonAncestor = (id1: string, id2: string, treeData: TreeData) => {\n  const { parentById } = treeData;\n  const visited = new Set();\n  let currentId = id1;\n  while (currentId) {\n    visited.add(currentId);\n    if (currentId === id2) {\n      return currentId;\n    }\n    currentId = parentById[currentId];\n  }\n  currentId = id2;\n  while (currentId) {\n    if (visited.has(currentId)) {\n      return currentId;\n    }\n    currentId = parentById[currentId];\n  }\n  return 'root';\n};\n","import { select, line, curveLinear } from 'd3';\nimport { insertNode } from '../../../dagre-wrapper/nodes.js';\nimport insertMarkers from '../../../dagre-wrapper/markers.js';\nimport { insertEdgeLabel } from '../../../dagre-wrapper/edges.js';\nimport { findCommonAncestor } from './render-utils';\nimport { addHtmlLabel } from 'dagre-d3-es/src/dagre-js/label/add-html-label.js';\nimport { getConfig } from '../../../config';\nimport { log } from '../../../logger';\nimport { setupGraphViewbox } from '../../../setupGraphViewbox';\nimport common, { evaluate } from '../../common/common';\nimport { interpolateToCurve, getStylesFromArray } from '../../../utils';\n\nlet elk;\n\nconst portPos = {};\n\nconst conf = {};\nexport const setConf = function (cnf) {\n  const keys = Object.keys(cnf);\n  for (const key of keys) {\n    conf[key] = cnf[key];\n  }\n};\n\nlet nodeDb = {};\n\n// /**\n//  * Function that adds the vertices found during parsing to the graph to be rendered.\n//  *\n//  * @param vert Object containing the vertices.\n//  * @param g The graph that is to be drawn.\n//  * @param svgId\n//  * @param root\n//  * @param doc\n//  * @param diagObj\n//  */\nexport const addVertices = function (vert, svgId, root, doc, diagObj, parentLookupDb, graph) {\n  const svg = root.select(`[id=\"${svgId}\"]`);\n  const nodes = svg.insert('g').attr('class', 'nodes');\n  const keys = Object.keys(vert);\n\n  // Iterate through each item in the vertex object (containing all the vertices found) in the graph definition\n  keys.forEach(function (id) {\n    const vertex = vert[id];\n\n    /**\n     * Variable for storing the classes for the vertex\n     *\n     * @type {string}\n     */\n    let classStr = 'default';\n    if (vertex.classes.length > 0) {\n      classStr = vertex.classes.join(' ');\n    }\n\n    const styles = getStylesFromArray(vertex.styles);\n\n    // Use vertex id as text in the box if no text is provided by the graph definition\n    let vertexText = vertex.text !== undefined ? vertex.text : vertex.id;\n\n    // We create a SVG label, either by delegating to addHtmlLabel or manually\n    let vertexNode;\n    const labelData = { width: 0, height: 0 };\n    if (evaluate(getConfig().flowchart.htmlLabels)) {\n      // TODO: addHtmlLabel accepts a labelStyle. Do we possibly have that?\n      const node = {\n        label: vertexText.replace(\n          /fa[blrs]?:fa-[\\w-]+/g,\n          (s) => `<i class='${s.replace(':', ' ')}'></i>`\n        ),\n      };\n      vertexNode = addHtmlLabel(svg, node).node();\n      const bbox = vertexNode.getBBox();\n      labelData.width = bbox.width;\n      labelData.height = bbox.height;\n      labelData.labelNode = vertexNode;\n      vertexNode.parentNode.removeChild(vertexNode);\n    } else {\n      const svgLabel = doc.createElementNS('http://www.w3.org/2000/svg', 'text');\n      svgLabel.setAttribute('style', styles.labelStyle.replace('color:', 'fill:'));\n\n      const rows = vertexText.split(common.lineBreakRegex);\n\n      for (const row of rows) {\n        const tspan = doc.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n        tspan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');\n        tspan.setAttribute('dy', '1em');\n        tspan.setAttribute('x', '1');\n        tspan.textContent = row;\n        svgLabel.appendChild(tspan);\n      }\n      vertexNode = svgLabel;\n      const bbox = vertexNode.getBBox();\n      labelData.width = bbox.width;\n      labelData.height = bbox.height;\n      labelData.labelNode = vertexNode;\n    }\n\n    const ports = [\n      {\n        id: vertex.id + '-west',\n        layoutOptions: {\n          'port.side': 'WEST',\n        },\n      },\n      {\n        id: vertex.id + '-east',\n        layoutOptions: {\n          'port.side': 'EAST',\n        },\n      },\n      {\n        id: vertex.id + '-south',\n        layoutOptions: {\n          'port.side': 'SOUTH',\n        },\n      },\n      {\n        id: vertex.id + '-north',\n        layoutOptions: {\n          'port.side': 'NORTH',\n        },\n      },\n    ];\n\n    let radious = 0;\n    let _shape = '';\n    let layoutOptions = {};\n    // Set the shape based parameters\n    switch (vertex.type) {\n      case 'round':\n        radious = 5;\n        _shape = 'rect';\n        break;\n      case 'square':\n        _shape = 'rect';\n        break;\n      case 'diamond':\n        _shape = 'question';\n        layoutOptions = {\n          portConstraints: 'FIXED_SIDE',\n        };\n        break;\n      case 'hexagon':\n        _shape = 'hexagon';\n        break;\n      case 'odd':\n        _shape = 'rect_left_inv_arrow';\n        break;\n      case 'lean_right':\n        _shape = 'lean_right';\n        break;\n      case 'lean_left':\n        _shape = 'lean_left';\n        break;\n      case 'trapezoid':\n        _shape = 'trapezoid';\n        break;\n      case 'inv_trapezoid':\n        _shape = 'inv_trapezoid';\n        break;\n      case 'odd_right':\n        _shape = 'rect_left_inv_arrow';\n        break;\n      case 'circle':\n        _shape = 'circle';\n        break;\n      case 'ellipse':\n        _shape = 'ellipse';\n        break;\n      case 'stadium':\n        _shape = 'stadium';\n        break;\n      case 'subroutine':\n        _shape = 'subroutine';\n        break;\n      case 'cylinder':\n        _shape = 'cylinder';\n        break;\n      case 'group':\n        _shape = 'rect';\n        break;\n      case 'doublecircle':\n        _shape = 'doublecircle';\n        break;\n      default:\n        _shape = 'rect';\n    }\n    // Add the node\n    const node = {\n      labelStyle: styles.labelStyle,\n      shape: _shape,\n      labelText: vertexText,\n      rx: radious,\n      ry: radious,\n      class: classStr,\n      style: styles.style,\n      id: vertex.id,\n      link: vertex.link,\n      linkTarget: vertex.linkTarget,\n      tooltip: diagObj.db.getTooltip(vertex.id) || '',\n      domId: diagObj.db.lookUpDomId(vertex.id),\n      haveCallback: vertex.haveCallback,\n      width: vertex.type === 'group' ? 500 : undefined,\n      dir: vertex.dir,\n      type: vertex.type,\n      props: vertex.props,\n      padding: getConfig().flowchart.padding,\n    };\n    let boundingBox;\n    let nodeEl;\n    if (node.type !== 'group') {\n      nodeEl = insertNode(nodes, node, vertex.dir);\n      boundingBox = nodeEl.node().getBBox();\n    }\n\n    const data = {\n      id: vertex.id,\n      ports: vertex.type === 'diamond' ? ports : [],\n      // labelStyle: styles.labelStyle,\n      // shape: _shape,\n      layoutOptions,\n      labelText: vertexText,\n      labelData,\n      // labels: [{ text: vertexText }],\n      // rx: radius,\n      // ry: radius,\n      // class: classStr,\n      // style: styles.style,\n      // link: vertex.link,\n      // linkTarget: vertex.linkTarget,\n      // tooltip: diagObj.db.getTooltip(vertex.id) || '',\n      domId: diagObj.db.lookUpDomId(vertex.id),\n      // haveCallback: vertex.haveCallback,\n      width: boundingBox?.width,\n      height: boundingBox?.height,\n      // dir: vertex.dir,\n      type: vertex.type,\n      // props: vertex.props,\n      // padding: getConfig().flowchart.padding,\n      // boundingBox,\n      el: nodeEl,\n      parent: parentLookupDb.parentById[vertex.id],\n    };\n    // if (!Object.keys(parentLookupDb.childrenById).includes(vertex.id)) {\n    // graph.children.push({\n    //   ...data,\n    // });\n    // }\n    nodeDb[node.id] = data;\n    // log.trace('setNode', {\n    //   labelStyle: styles.labelStyle,\n    //   shape: _shape,\n    //   labelText: vertexText,\n    //   rx: radius,\n    //   ry: radius,\n    //   class: classStr,\n    //   style: styles.style,\n    //   id: vertex.id,\n    //   domId: diagObj.db.lookUpDomId(vertex.id),\n    //   width: vertex.type === 'group' ? 500 : undefined,\n    //   type: vertex.type,\n    //   dir: vertex.dir,\n    //   props: vertex.props,\n    //   padding: getConfig().flowchart.padding,\n    //   parent: parentLookupDb.parentById[vertex.id],\n    // });\n  });\n  return graph;\n};\n\nconst getNextPosition = (position, edgeDirection, graphDirection) => {\n  const portPos = {\n    TB: {\n      in: {\n        north: 'north',\n      },\n      out: {\n        south: 'west',\n        west: 'east',\n        east: 'south',\n      },\n    },\n    LR: {\n      in: {\n        west: 'west',\n      },\n      out: {\n        east: 'south',\n        south: 'north',\n        north: 'east',\n      },\n    },\n    RL: {\n      in: {\n        east: 'east',\n      },\n      out: {\n        west: 'north',\n        north: 'south',\n        south: 'west',\n      },\n    },\n    BT: {\n      in: {\n        south: 'south',\n      },\n      out: {\n        north: 'east',\n        east: 'west',\n        west: 'north',\n      },\n    },\n  };\n  portPos.TD = portPos.TB;\n  log.info('abc88', graphDirection, edgeDirection, position);\n  return portPos[graphDirection][edgeDirection][position];\n  // return 'south';\n};\n\nconst getNextPort = (node, edgeDirection, graphDirection) => {\n  log.info('getNextPort abc88', { node, edgeDirection, graphDirection });\n  if (!portPos[node]) {\n    switch (graphDirection) {\n      case 'TB':\n      case 'TD':\n        portPos[node] = {\n          inPosition: 'north',\n          outPosition: 'south',\n        };\n        break;\n      case 'BT':\n        portPos[node] = {\n          inPosition: 'south',\n          outPosition: 'north',\n        };\n        break;\n      case 'RL':\n        portPos[node] = {\n          inPosition: 'east',\n          outPosition: 'west',\n        };\n        break;\n      case 'LR':\n        portPos[node] = {\n          inPosition: 'west',\n          outPosition: 'east',\n        };\n        break;\n    }\n  }\n  const result = edgeDirection === 'in' ? portPos[node].inPosition : portPos[node].outPosition;\n\n  if (edgeDirection === 'in') {\n    portPos[node].inPosition = getNextPosition(\n      portPos[node].inPosition,\n      edgeDirection,\n      graphDirection\n    );\n  } else {\n    portPos[node].outPosition = getNextPosition(\n      portPos[node].outPosition,\n      edgeDirection,\n      graphDirection\n    );\n  }\n  return result;\n};\n\nconst getEdgeStartEndPoint = (edge, dir) => {\n  let source = edge.start;\n  let target = edge.end;\n\n  const startNode = nodeDb[source];\n  const endNode = nodeDb[target];\n\n  if (!startNode || !endNode) {\n    return { source, target };\n  }\n\n  if (startNode.type === 'diamond') {\n    source = `${source}-${getNextPort(source, 'out', dir)}`;\n  }\n\n  if (endNode.type === 'diamond') {\n    target = `${target}-${getNextPort(target, 'in', dir)}`;\n  }\n\n  // Add the edge to the graph\n  return { source, target };\n};\n\n/**\n * Add edges to graph based on parsed graph definition\n *\n * @param {object} edges The edges to add to the graph\n * @param {object} g The graph object\n * @param cy\n * @param diagObj\n * @param graph\n * @param svg\n */\nexport const addEdges = function (edges, diagObj, graph, svg) {\n  log.info('abc78 edges = ', edges);\n  const labelsEl = svg.insert('g').attr('class', 'edgeLabels');\n  let linkIdCnt = {};\n  let dir = diagObj.db.getDirection();\n  let defaultStyle;\n  let defaultLabelStyle;\n\n  if (edges.defaultStyle !== undefined) {\n    const defaultStyles = getStylesFromArray(edges.defaultStyle);\n    defaultStyle = defaultStyles.style;\n    defaultLabelStyle = defaultStyles.labelStyle;\n  }\n\n  edges.forEach(function (edge) {\n    // Identify Link\n    var linkIdBase = 'L-' + edge.start + '-' + edge.end;\n    // count the links from+to the same node to give unique id\n    if (linkIdCnt[linkIdBase] === undefined) {\n      linkIdCnt[linkIdBase] = 0;\n      log.info('abc78 new entry', linkIdBase, linkIdCnt[linkIdBase]);\n    } else {\n      linkIdCnt[linkIdBase]++;\n      log.info('abc78 new entry', linkIdBase, linkIdCnt[linkIdBase]);\n    }\n    let linkId = linkIdBase + '-' + linkIdCnt[linkIdBase];\n    log.info('abc78 new link id to be used is', linkIdBase, linkId, linkIdCnt[linkIdBase]);\n    var linkNameStart = 'LS-' + edge.start;\n    var linkNameEnd = 'LE-' + edge.end;\n\n    const edgeData = { style: '', labelStyle: '' };\n    edgeData.minlen = edge.length || 1;\n    //edgeData.id = 'id' + cnt;\n\n    // Set link type for rendering\n    if (edge.type === 'arrow_open') {\n      edgeData.arrowhead = 'none';\n    } else {\n      edgeData.arrowhead = 'normal';\n    }\n\n    // Check of arrow types, placed here in order not to break old rendering\n    edgeData.arrowTypeStart = 'arrow_open';\n    edgeData.arrowTypeEnd = 'arrow_open';\n\n    /* eslint-disable no-fallthrough */\n    switch (edge.type) {\n      case 'double_arrow_cross':\n        edgeData.arrowTypeStart = 'arrow_cross';\n      case 'arrow_cross':\n        edgeData.arrowTypeEnd = 'arrow_cross';\n        break;\n      case 'double_arrow_point':\n        edgeData.arrowTypeStart = 'arrow_point';\n      case 'arrow_point':\n        edgeData.arrowTypeEnd = 'arrow_point';\n        break;\n      case 'double_arrow_circle':\n        edgeData.arrowTypeStart = 'arrow_circle';\n      case 'arrow_circle':\n        edgeData.arrowTypeEnd = 'arrow_circle';\n        break;\n    }\n\n    let style = '';\n    let labelStyle = '';\n\n    switch (edge.stroke) {\n      case 'normal':\n        style = 'fill:none;';\n        if (defaultStyle !== undefined) {\n          style = defaultStyle;\n        }\n        if (defaultLabelStyle !== undefined) {\n          labelStyle = defaultLabelStyle;\n        }\n        edgeData.thickness = 'normal';\n        edgeData.pattern = 'solid';\n        break;\n      case 'dotted':\n        edgeData.thickness = 'normal';\n        edgeData.pattern = 'dotted';\n        edgeData.style = 'fill:none;stroke-width:2px;stroke-dasharray:3;';\n        break;\n      case 'thick':\n        edgeData.thickness = 'thick';\n        edgeData.pattern = 'solid';\n        edgeData.style = 'stroke-width: 3.5px;fill:none;';\n        break;\n    }\n    if (edge.style !== undefined) {\n      const styles = getStylesFromArray(edge.style);\n      style = styles.style;\n      labelStyle = styles.labelStyle;\n    }\n\n    edgeData.style = edgeData.style += style;\n    edgeData.labelStyle = edgeData.labelStyle += labelStyle;\n\n    if (edge.interpolate !== undefined) {\n      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear);\n    } else if (edges.defaultInterpolate !== undefined) {\n      edgeData.curve = interpolateToCurve(edges.defaultInterpolate, curveLinear);\n    } else {\n      edgeData.curve = interpolateToCurve(conf.curve, curveLinear);\n    }\n\n    if (edge.text === undefined) {\n      if (edge.style !== undefined) {\n        edgeData.arrowheadStyle = 'fill: #333';\n      }\n    } else {\n      edgeData.arrowheadStyle = 'fill: #333';\n      edgeData.labelpos = 'c';\n    }\n\n    edgeData.labelType = 'text';\n    edgeData.label = edge.text.replace(common.lineBreakRegex, '\\n');\n\n    if (edge.style === undefined) {\n      edgeData.style = edgeData.style || 'stroke: #333; stroke-width: 1.5px;fill:none;';\n    }\n\n    edgeData.labelStyle = edgeData.labelStyle.replace('color:', 'fill:');\n\n    edgeData.id = linkId;\n    edgeData.classes = 'flowchart-link ' + linkNameStart + ' ' + linkNameEnd;\n\n    const labelEl = insertEdgeLabel(labelsEl, edgeData);\n\n    // calculate start and end points of the edge\n    const { source, target } = getEdgeStartEndPoint(edge, dir);\n    log.debug('abc78 source and target', source, target);\n    // Add the edge to the graph\n    graph.edges.push({\n      id: 'e' + edge.start + edge.end,\n      sources: [source],\n      targets: [target],\n      labelEl: labelEl,\n      labels: [\n        {\n          width: edgeData.width,\n          height: edgeData.height,\n          orgWidth: edgeData.width,\n          orgHeight: edgeData.height,\n          text: edgeData.label,\n          layoutOptions: {\n            'edgeLabels.inline': 'true',\n            'edgeLabels.placement': 'CENTER',\n          },\n        },\n      ],\n      edgeData,\n    });\n  });\n  return graph;\n};\n\n// TODO: break out and share with dagre wrapper. The current code in dagre wrapper also adds\n// adds the line to the graph, but we don't need that here. This is why we cant use the dagre\n// wrapper directly for this\n/**\n * Add the markers to the edge depending on the type of arrow is\n * @param svgPath\n * @param edgeData\n * @param diagramType\n * @param arrowMarkerAbsolute\n */\nconst addMarkersToEdge = function (svgPath, edgeData, diagramType, arrowMarkerAbsolute) {\n  let url = '';\n  // Check configuration for absolute path\n  if (arrowMarkerAbsolute) {\n    url =\n      window.location.protocol +\n      '//' +\n      window.location.host +\n      window.location.pathname +\n      window.location.search;\n    url = url.replace(/\\(/g, '\\\\(');\n    url = url.replace(/\\)/g, '\\\\)');\n  }\n\n  // look in edge data and decide which marker to use\n  switch (edgeData.arrowTypeStart) {\n    case 'arrow_cross':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-crossStart' + ')');\n      break;\n    case 'arrow_point':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-pointStart' + ')');\n      break;\n    case 'arrow_barb':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-barbStart' + ')');\n      break;\n    case 'arrow_circle':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-circleStart' + ')');\n      break;\n    case 'aggregation':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-aggregationStart' + ')');\n      break;\n    case 'extension':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-extensionStart' + ')');\n      break;\n    case 'composition':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-compositionStart' + ')');\n      break;\n    case 'dependency':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-dependencyStart' + ')');\n      break;\n    case 'lollipop':\n      svgPath.attr('marker-start', 'url(' + url + '#' + diagramType + '-lollipopStart' + ')');\n      break;\n    default:\n  }\n  switch (edgeData.arrowTypeEnd) {\n    case 'arrow_cross':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-crossEnd' + ')');\n      break;\n    case 'arrow_point':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-pointEnd' + ')');\n      break;\n    case 'arrow_barb':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-barbEnd' + ')');\n      break;\n    case 'arrow_circle':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-circleEnd' + ')');\n      break;\n    case 'aggregation':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-aggregationEnd' + ')');\n      break;\n    case 'extension':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-extensionEnd' + ')');\n      break;\n    case 'composition':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-compositionEnd' + ')');\n      break;\n    case 'dependency':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-dependencyEnd' + ')');\n      break;\n    case 'lollipop':\n      svgPath.attr('marker-end', 'url(' + url + '#' + diagramType + '-lollipopEnd' + ')');\n      break;\n    default:\n  }\n};\n\n/**\n * Returns the all the styles from classDef statements in the graph definition.\n *\n * @param text\n * @param diagObj\n * @returns {object} ClassDef styles\n */\nexport const getClasses = function (text, diagObj) {\n  log.info('Extracting classes');\n  diagObj.db.clear('ver-2');\n  try {\n    // Parse the graph definition\n    diagObj.parse(text);\n    return diagObj.db.getClasses();\n  } catch (e) {\n    return {};\n  }\n};\n\nconst addSubGraphs = function (db) {\n  const parentLookupDb = { parentById: {}, childrenById: {} };\n  const subgraphs = db.getSubGraphs();\n  log.info('Subgraphs - ', subgraphs);\n  subgraphs.forEach(function (subgraph) {\n    subgraph.nodes.forEach(function (node) {\n      parentLookupDb.parentById[node] = subgraph.id;\n      if (parentLookupDb.childrenById[subgraph.id] === undefined) {\n        parentLookupDb.childrenById[subgraph.id] = [];\n      }\n      parentLookupDb.childrenById[subgraph.id].push(node);\n    });\n  });\n\n  subgraphs.forEach(function (subgraph) {\n    const data = { id: subgraph.id };\n    if (parentLookupDb.parentById[subgraph.id] !== undefined) {\n      data.parent = parentLookupDb.parentById[subgraph.id];\n    }\n  });\n  return parentLookupDb;\n};\n\nconst calcOffset = function (src, dest, parentLookupDb) {\n  const ancestor = findCommonAncestor(src, dest, parentLookupDb);\n  if (ancestor === undefined || ancestor === 'root') {\n    return { x: 0, y: 0 };\n  }\n\n  const ancestorOffset = nodeDb[ancestor].offset;\n  return { x: ancestorOffset.posX, y: ancestorOffset.posY };\n};\n\nconst insertEdge = function (edgesEl, edge, edgeData, diagObj, parentLookupDb) {\n  const offset = calcOffset(edge.sources[0], edge.targets[0], parentLookupDb);\n\n  const src = edge.sections[0].startPoint;\n  const dest = edge.sections[0].endPoint;\n  const segments = edge.sections[0].bendPoints ? edge.sections[0].bendPoints : [];\n\n  const segPoints = segments.map((segment) => [segment.x + offset.x, segment.y + offset.y]);\n  const points = [\n    [src.x + offset.x, src.y + offset.y],\n    ...segPoints,\n    [dest.x + offset.x, dest.y + offset.y],\n  ];\n\n  // const curve = line().curve(curveBasis);\n  const curve = line().curve(curveLinear);\n  const edgePath = edgesEl\n    .insert('path')\n    .attr('d', curve(points))\n    .attr('class', 'path')\n    .attr('fill', 'none');\n  const edgeG = edgesEl.insert('g').attr('class', 'edgeLabel');\n  const edgeWithLabel = select(edgeG.node().appendChild(edge.labelEl));\n  const box = edgeWithLabel.node().firstChild.getBoundingClientRect();\n  edgeWithLabel.attr('width', box.width);\n  edgeWithLabel.attr('height', box.height);\n\n  edgeG.attr(\n    'transform',\n    `translate(${edge.labels[0].x + offset.x}, ${edge.labels[0].y + offset.y})`\n  );\n  addMarkersToEdge(edgePath, edgeData, diagObj.type, diagObj.arrowMarkerAbsolute);\n};\n\n/**\n * Recursive function that iterates over an array of nodes and inserts the children of each node.\n * It also recursively populates the inserts the children of the children and so on.\n * @param {*} graph\n * @param nodeArray\n * @param parentLookupDb\n */\nconst insertChildren = (nodeArray, parentLookupDb) => {\n  nodeArray.forEach((node) => {\n    // Check if we have reached the end of the tree\n    if (!node.children) {\n      node.children = [];\n    }\n    // Check if the node has children\n    const childIds = parentLookupDb.childrenById[node.id];\n    // If the node has children, add them to the node\n    if (childIds) {\n      childIds.forEach((childId) => {\n        node.children.push(nodeDb[childId]);\n      });\n    }\n    // Recursive call\n    insertChildren(node.children, parentLookupDb);\n  });\n};\n\n/**\n * Draws a flowchart in the tag with id: id based on the graph definition in text.\n *\n * @param text\n * @param id\n */\n\nexport const draw = async function (text, id, _version, diagObj) {\n  if (!elk) {\n    const ELK = (await import('elkjs/lib/elk.bundled.js')).default;\n    elk = new ELK();\n  }\n  // Add temporary render element\n  diagObj.db.clear();\n  nodeDb = {};\n  diagObj.db.setGen('gen-2');\n  // Parse the graph definition\n  diagObj.parser.parse(text);\n\n  const renderEl = select('body').append('div').attr('style', 'height:400px').attr('id', 'cy');\n  let graph = {\n    id: 'root',\n    layoutOptions: {\n      'elk.hierarchyHandling': 'INCLUDE_CHILDREN',\n      'org.eclipse.elk.padding': '[top=100, left=100, bottom=110, right=110]',\n      'elk.layered.spacing.edgeNodeBetweenLayers': '30',\n      // 'elk.layered.mergeEdges': 'true',\n      'elk.direction': 'DOWN',\n      // 'elk.ports.sameLayerEdges': true,\n      // 'nodePlacement.strategy': 'SIMPLE',\n    },\n    children: [],\n    edges: [],\n  };\n  log.info('Drawing flowchart using v3 renderer', elk);\n\n  // Set the direction,\n  // Fetch the default direction, use TD if none was found\n  let dir = diagObj.db.getDirection();\n  switch (dir) {\n    case 'BT':\n      graph.layoutOptions['elk.direction'] = 'UP';\n      break;\n    case 'TB':\n      graph.layoutOptions['elk.direction'] = 'DOWN';\n      break;\n    case 'LR':\n      graph.layoutOptions['elk.direction'] = 'RIGHT';\n      break;\n    case 'RL':\n      graph.layoutOptions['elk.direction'] = 'LEFT';\n      break;\n  }\n  const { securityLevel, flowchart: conf } = getConfig();\n\n  // Find the root dom node to ne used in rendering\n  // Handle root and document for when rendering in sandbox mode\n  let sandboxElement;\n  if (securityLevel === 'sandbox') {\n    sandboxElement = select('#i' + id);\n  }\n  const root =\n    securityLevel === 'sandbox'\n      ? select(sandboxElement.nodes()[0].contentDocument.body)\n      : select('body');\n  const doc = securityLevel === 'sandbox' ? sandboxElement.nodes()[0].contentDocument : document;\n\n  const svg = root.select(`[id=\"${id}\"]`);\n\n  // Define the supported markers for the diagram\n  const markers = ['point', 'circle', 'cross'];\n\n  // Add the marker definitions to the svg as marker tags\n  insertMarkers(svg, markers, diagObj.type, diagObj.arrowMarkerAbsolute);\n\n  // Fetch the vertices/nodes and edges/links from the parsed graph definition\n  const vert = diagObj.db.getVertices();\n\n  // Setup nodes from the subgraphs with type group, these will be used\n  // as nodes with children in the subgraph\n  let subG;\n  const subGraphs = diagObj.db.getSubGraphs();\n  log.info('Subgraphs - ', subGraphs);\n  for (let i = subGraphs.length - 1; i >= 0; i--) {\n    subG = subGraphs[i];\n    diagObj.db.addVertex(subG.id, subG.title, 'group', undefined, subG.classes, subG.dir);\n  }\n\n  // Add an element in the svg to be used to hold the subgraphs container\n  // elements\n  const subGraphsEl = svg.insert('g').attr('class', 'subgraphs');\n\n  // Create the lookup db for the subgraphs and their children to used when creating\n  // the tree structured graph\n  const parentLookupDb = addSubGraphs(diagObj.db);\n\n  // Add the nodes to the graph, this will entail creating the actual nodes\n  // in order to get the size of the node. You can't get the size of a node\n  // that is not in the dom so we need to add it to the dom, get the size\n  // we will position the nodes when we get the layout from elkjs\n  graph = addVertices(vert, id, root, doc, diagObj, parentLookupDb, graph);\n\n  // Time for the edges, we start with adding an element in the node to hold the edges\n  const edgesEl = svg.insert('g').attr('class', 'edges edgePath');\n  // Fetch the edges form the parsed graph definition\n  const edges = diagObj.db.getEdges();\n\n  // Add the edges to the graph, this will entail creating the actual edges\n  graph = addEdges(edges, diagObj, graph, svg);\n\n  // Iterate through all nodes and add the top level nodes to the graph\n  const nodes = Object.keys(nodeDb);\n  nodes.forEach((nodeId) => {\n    const node = nodeDb[nodeId];\n    if (!node.parent) {\n      graph.children.push(node);\n    }\n    // Subgraph\n    if (parentLookupDb.childrenById[nodeId] !== undefined) {\n      node.labels = [\n        {\n          text: node.labelText,\n          layoutOptions: {\n            'nodeLabels.placement': '[H_CENTER, V_TOP, INSIDE]',\n          },\n          width: node.labelData.width,\n          height: node.labelData.height,\n        },\n      ];\n      delete node.x;\n      delete node.y;\n      delete node.width;\n      delete node.height;\n    }\n  });\n  insertChildren(graph.children, parentLookupDb);\n  log.info('after layout', JSON.stringify(graph, null, 2));\n  const g = await elk.layout(graph);\n  drawNodes(0, 0, g.children, svg, subGraphsEl, diagObj, 0);\n  log.info('after layout', g);\n  g.edges?.map((edge) => {\n    insertEdge(edgesEl, edge, edge.edgeData, diagObj, parentLookupDb);\n  });\n  setupGraphViewbox({}, svg, conf.diagramPadding, conf.useMaxWidth);\n  // Remove element after layout\n  renderEl.remove();\n};\n\nconst drawNodes = (relX, relY, nodeArray, svg, subgraphsEl, diagObj, depth) => {\n  nodeArray.forEach(function (node) {\n    if (node) {\n      nodeDb[node.id].offset = {\n        posX: node.x + relX,\n        posY: node.y + relY,\n        x: relX,\n        y: relY,\n        depth,\n        width: node.width,\n        height: node.height,\n      };\n      if (node.type === 'group') {\n        const subgraphEl = subgraphsEl.insert('g').attr('class', 'subgraph');\n        subgraphEl\n          .insert('rect')\n          .attr('class', 'subgraph subgraph-lvl-' + (depth % 5) + ' node')\n          .attr('x', node.x + relX)\n          .attr('y', node.y + relY)\n          .attr('width', node.width)\n          .attr('height', node.height);\n        const label = subgraphEl.insert('g').attr('class', 'label');\n        label.attr(\n          'transform',\n          `translate(${node.labels[0].x + relX + node.x}, ${node.labels[0].y + relY + node.y})`\n        );\n        label.node().appendChild(node.labelData.labelNode);\n\n        log.info('Id (UGH)= ', node.type, node.labels);\n      } else {\n        log.info('Id (UGH)= ', node.id);\n        node.el.attr(\n          'transform',\n          `translate(${node.x + relX + node.width / 2}, ${node.y + relY + node.height / 2})`\n        );\n      }\n    }\n  });\n  nodeArray.forEach(function (node) {\n    if (node && node.type === 'group') {\n      drawNodes(relX + node.x, relY + node.y, node.children, svg, subgraphsEl, diagObj, depth + 1);\n    }\n  });\n};\n\nexport default {\n  getClasses,\n  draw,\n};\n","/** Returns the styles given options */\nexport interface FlowChartStyleOptions {\n  arrowheadColor: string;\n  border2: string;\n  clusterBkg: string;\n  clusterBorder: string;\n  edgeLabelBackground: string;\n  fontFamily: string;\n  lineColor: string;\n  mainBkg: string;\n  nodeBorder: string;\n  nodeTextColor: string;\n  tertiaryColor: string;\n  textColor: string;\n  titleColor: string;\n  [key: string]: string;\n}\n\nconst genSections = (options: FlowChartStyleOptions) => {\n  let sections = '';\n\n  for (let i = 0; i < 5; i++) {\n    sections += `\n      .subgraph-lvl-${i} {\n        fill: ${options[`surface${i}`]};\n        stroke: ${options[`surfacePeer${i}`]};\n      }\n    `;\n  }\n  return sections;\n};\n\nconst getStyles = (options: FlowChartStyleOptions) =>\n  `.label {\n    font-family: ${options.fontFamily};\n    color: ${options.nodeTextColor || options.textColor};\n  }\n  .cluster-label text {\n    fill: ${options.titleColor};\n  }\n  .cluster-label span {\n    color: ${options.titleColor};\n  }\n\n  .label text,span {\n    fill: ${options.nodeTextColor || options.textColor};\n    color: ${options.nodeTextColor || options.textColor};\n  }\n\n  .node rect,\n  .node circle,\n  .node ellipse,\n  .node polygon,\n  .node path {\n    fill: ${options.mainBkg};\n    stroke: ${options.nodeBorder};\n    stroke-width: 1px;\n  }\n\n  .node .label {\n    text-align: center;\n  }\n  .node.clickable {\n    cursor: pointer;\n  }\n\n  .arrowheadPath {\n    fill: ${options.arrowheadColor};\n  }\n\n  .edgePath .path {\n    stroke: ${options.lineColor};\n    stroke-width: 2.0px;\n  }\n\n  .flowchart-link {\n    stroke: ${options.lineColor};\n    fill: none;\n  }\n\n  .edgeLabel {\n    background-color: ${options.edgeLabelBackground};\n    rect {\n      opacity: 0.5;\n      background-color: ${options.edgeLabelBackground};\n      fill: ${options.edgeLabelBackground};\n    }\n    text-align: center;\n  }\n\n  .cluster rect {\n    fill: ${options.clusterBkg};\n    stroke: ${options.clusterBorder};\n    stroke-width: 1px;\n  }\n\n  .cluster text {\n    fill: ${options.titleColor};\n  }\n\n  .cluster span {\n    color: ${options.titleColor};\n  }\n  /* .cluster div {\n    color: ${options.titleColor};\n  } */\n\n  div.mermaidTooltip {\n    position: absolute;\n    text-align: center;\n    max-width: 200px;\n    padding: 2px;\n    font-family: ${options.fontFamily};\n    font-size: 12px;\n    background: ${options.tertiaryColor};\n    border: 1px solid ${options.border2};\n    border-radius: 2px;\n    pointer-events: none;\n    z-index: 100;\n  }\n\n  .flowchartTitleText {\n    text-anchor: middle;\n    font-size: 18px;\n    fill: ${options.textColor};\n  }\n  .subgraph {\n    stroke-width:2;\n    rx:3;\n  }\n  // .subgraph-lvl-1 {\n  //   fill:#ccc;\n  //   // stroke:black;\n  // }\n  ${genSections(options)}\n`;\n\nexport default getStyles;\n","// @ts-ignore: JISON typing missing\nimport parser from '../parser/flow';\n\nimport * as db from '../flowDb';\nimport renderer from './flowRenderer-elk';\nimport styles from './styles';\n\nexport const diagram = {\n  db,\n  renderer,\n  parser,\n  styles,\n};\n"],"names":["findCommonAncestor","id1","id2","treeData","parentById","visited","currentId","elk","portPos","conf","nodeDb","addVertices","vert","svgId","root","doc","diagObj","parentLookupDb","graph","svg","nodes","id","vertex","classStr","styles","getStylesFromArray","vertexText","vertexNode","labelData","evaluate","getConfig","node","s","addHtmlLabel","bbox","svgLabel","rows","common","row","tspan","ports","radious","_shape","layoutOptions","boundingBox","nodeEl","insertNode","data","getNextPosition","position","edgeDirection","graphDirection","log","getNextPort","result","getEdgeStartEndPoint","edge","dir","source","target","startNode","endNode","addEdges","edges","labelsEl","linkIdCnt","defaultStyle","defaultLabelStyle","defaultStyles","linkIdBase","linkId","linkNameStart","linkNameEnd","edgeData","style","labelStyle","interpolateToCurve","curveLinear","labelEl","insertEdgeLabel","addMarkersToEdge","svgPath","diagramType","arrowMarkerAbsolute","url","getClasses","text","addSubGraphs","db","subgraphs","subgraph","calcOffset","src","dest","ancestor","ancestorOffset","insertEdge","edgesEl","offset","segPoints","segment","points","curve","line","edgePath","edgeG","edgeWithLabel","select","box","insertChildren","nodeArray","childIds","childId","draw","_version","ELK","n","renderEl","securityLevel","sandboxElement","insertMarkers","subG","subGraphs","i","subGraphsEl","nodeId","drawNodes","_a","setupGraphViewbox","relX","relY","subgraphsEl","depth","subgraphEl","label","renderer","genSections","options","sections","getStyles","diagram","parser"],"mappings":";;;;;;;;;;;;AAKO,MAAMA,IAAqB,CAACC,GAAaC,GAAaC,MAAuB;AAC5E,QAAA,EAAE,YAAAC,EAAe,IAAAD,GACjBE,wBAAc;AACpB,MAAIC,IAAYL;AAChB,SAAOK,KAAW;AAEhB,QADAD,EAAQ,IAAIC,CAAS,GACjBA,MAAcJ;AACT,aAAAI;AAET,IAAAA,IAAYF,EAAWE,CAAS;AAAA,EAClC;AAEA,OADYA,IAAAJ,GACLI,KAAW;AACZ,QAAAD,EAAQ,IAAIC,CAAS;AAChB,aAAAA;AAET,IAAAA,IAAYF,EAAWE,CAAS;AAAA,EAClC;AACO,SAAA;AACT;ACZA,IAAIC;AAEJ,MAAMC,IAAU,CAAA,GAEVC,KAAO,CAAA;AAQb,IAAIC,IAAS,CAAA;AAYN,MAAMC,KAAc,SAAUC,GAAMC,GAAOC,GAAMC,GAAKC,GAASC,GAAgBC,GAAO;AAC3F,QAAMC,IAAML,EAAK,OAAO,QAAQD,KAAS,GACnCO,IAAQD,EAAI,OAAO,GAAG,EAAE,KAAK,SAAS,OAAO;AAInD,SAHa,OAAO,KAAKP,CAAI,EAGxB,QAAQ,SAAUS,GAAI;AACzB,UAAMC,IAASV,EAAKS,CAAE;AAOtB,QAAIE,IAAW;AACf,IAAID,EAAO,QAAQ,SAAS,MAC1BC,IAAWD,EAAO,QAAQ,KAAK,GAAG;AAGpC,UAAME,IAASC,EAAmBH,EAAO,MAAM;AAG/C,QAAII,IAAaJ,EAAO,SAAS,SAAYA,EAAO,OAAOA,EAAO,IAG9DK;AACJ,UAAMC,IAAY,EAAE,OAAO,GAAG,QAAQ,EAAC;AACvC,QAAIC,EAASC,EAAS,EAAG,UAAU,UAAU,GAAG;AAE9C,YAAMC,IAAO;AAAA,QACX,OAAOL,EAAW;AAAA,UAChB;AAAA,UACA,CAACM,MAAM,aAAaA,EAAE,QAAQ,KAAK,GAAG;AAAA,QACvC;AAAA,MACT;AACM,MAAAL,IAAaM,EAAad,GAAKY,CAAI,EAAE,KAAI;AACzC,YAAMG,IAAOP,EAAW;AACxB,MAAAC,EAAU,QAAQM,EAAK,OACvBN,EAAU,SAASM,EAAK,QACxBN,EAAU,YAAYD,GACtBA,EAAW,WAAW,YAAYA,CAAU;AAAA,IAClD,OAAW;AACL,YAAMQ,IAAWpB,EAAI,gBAAgB,8BAA8B,MAAM;AACzE,MAAAoB,EAAS,aAAa,SAASX,EAAO,WAAW,QAAQ,UAAU,OAAO,CAAC;AAE3E,YAAMY,IAAOV,EAAW,MAAMW,EAAO,cAAc;AAEnD,iBAAWC,KAAOF,GAAM;AACtB,cAAMG,IAAQxB,EAAI,gBAAgB,8BAA8B,OAAO;AACvE,QAAAwB,EAAM,eAAe,wCAAwC,aAAa,UAAU,GACpFA,EAAM,aAAa,MAAM,KAAK,GAC9BA,EAAM,aAAa,KAAK,GAAG,GAC3BA,EAAM,cAAcD,GACpBH,EAAS,YAAYI,CAAK;AAAA,MAC3B;AACD,MAAAZ,IAAaQ;AACb,YAAMD,IAAOP,EAAW;AACxB,MAAAC,EAAU,QAAQM,EAAK,OACvBN,EAAU,SAASM,EAAK,QACxBN,EAAU,YAAYD;AAAA,IACvB;AAED,UAAMa,IAAQ;AAAA,MACZ;AAAA,QACE,IAAIlB,EAAO,KAAK;AAAA,QAChB,eAAe;AAAA,UACb,aAAa;AAAA,QACd;AAAA,MACF;AAAA,MACD;AAAA,QACE,IAAIA,EAAO,KAAK;AAAA,QAChB,eAAe;AAAA,UACb,aAAa;AAAA,QACd;AAAA,MACF;AAAA,MACD;AAAA,QACE,IAAIA,EAAO,KAAK;AAAA,QAChB,eAAe;AAAA,UACb,aAAa;AAAA,QACd;AAAA,MACF;AAAA,MACD;AAAA,QACE,IAAIA,EAAO,KAAK;AAAA,QAChB,eAAe;AAAA,UACb,aAAa;AAAA,QACd;AAAA,MACF;AAAA,IACP;AAEI,QAAImB,IAAU,GACVC,IAAS,IACTC,IAAgB,CAAA;AAEpB,YAAQrB,EAAO,MAAI;AAAA,MACjB,KAAK;AACH,QAAAmB,IAAU,GACVC,IAAS;AACT;AAAA,MACF,KAAK;AACH,QAAAA,IAAS;AACT;AAAA,MACF,KAAK;AACH,QAAAA,IAAS,YACTC,IAAgB;AAAA,UACd,iBAAiB;AAAA,QAC3B;AACQ;AAAA,MACF,KAAK;AACH,QAAAD,IAAS;AACT;AAAA,MACF,KAAK;AACH,QAAAA,IAAS;AACT;AAAA,MACF,KAAK;AACH,QAAAA,IAAS;AACT;AAAA,MACF,KAAK;AACH,QAAAA,IAAS;AACT;AAAA,MACF,KAAK;AACH,QAAAA,IAAS;AACT;AAAA,MACF,KAAK;AACH,QAAAA,IAAS;AACT;AAAA,MACF,KAAK;AACH,QAAAA,IAAS;AACT;AAAA,MACF,KAAK;AACH,QAAAA,IAAS;AACT;AAAA,MACF,KAAK;AACH,QAAAA,IAAS;AACT;AAAA,MACF,KAAK;AACH,QAAAA,IAAS;AACT;AAAA,MACF,KAAK;AACH,QAAAA,IAAS;AACT;AAAA,MACF,KAAK;AACH,QAAAA,IAAS;AACT;AAAA,MACF,KAAK;AACH,QAAAA,IAAS;AACT;AAAA,MACF,KAAK;AACH,QAAAA,IAAS;AACT;AAAA,MACF;AACE,QAAAA,IAAS;AAAA,IACZ;AAED,UAAMX,IAAO;AAAA,MACX,YAAYP,EAAO;AAAA,MACnB,OAAOkB;AAAA,MACP,WAAWhB;AAAA,MACX,IAAIe;AAAA,MACJ,IAAIA;AAAA,MACJ,OAAOlB;AAAA,MACP,OAAOC,EAAO;AAAA,MACd,IAAIF,EAAO;AAAA,MACX,MAAMA,EAAO;AAAA,MACb,YAAYA,EAAO;AAAA,MACnB,SAASN,EAAQ,GAAG,WAAWM,EAAO,EAAE,KAAK;AAAA,MAC7C,OAAON,EAAQ,GAAG,YAAYM,EAAO,EAAE;AAAA,MACvC,cAAcA,EAAO;AAAA,MACrB,OAAOA,EAAO,SAAS,UAAU,MAAM;AAAA,MACvC,KAAKA,EAAO;AAAA,MACZ,MAAMA,EAAO;AAAA,MACb,OAAOA,EAAO;AAAA,MACd,SAASQ,IAAY,UAAU;AAAA,IACrC;AACI,QAAIc,GACAC;AACJ,IAAId,EAAK,SAAS,YAChBc,IAASC,EAAW1B,GAAOW,GAAMT,EAAO,GAAG,GAC3CsB,IAAcC,EAAO,KAAM,EAAC,QAAO;AAGrC,UAAME,IAAO;AAAA,MACX,IAAIzB,EAAO;AAAA,MACX,OAAOA,EAAO,SAAS,YAAYkB,IAAQ,CAAE;AAAA;AAAA;AAAA,MAG7C,eAAAG;AAAA,MACA,WAAWjB;AAAA,MACX,WAAAE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MASA,OAAOZ,EAAQ,GAAG,YAAYM,EAAO,EAAE;AAAA;AAAA,MAEvC,OAAOsB,KAAA,gBAAAA,EAAa;AAAA,MACpB,QAAQA,KAAA,gBAAAA,EAAa;AAAA;AAAA,MAErB,MAAMtB,EAAO;AAAA;AAAA;AAAA;AAAA,MAIb,IAAIuB;AAAA,MACJ,QAAQ5B,EAAe,WAAWK,EAAO,EAAE;AAAA,IACjD;AAMI,IAAAZ,EAAOqB,EAAK,EAAE,IAAIgB;AAAA,EAkBtB,CAAG,GACM7B;AACT,GAEM8B,IAAkB,CAACC,GAAUC,GAAeC,MAAmB;AACnE,QAAM3C,IAAU;AAAA,IACd,IAAI;AAAA,MACF,IAAI;AAAA,QACF,OAAO;AAAA,MACR;AAAA,MACD,KAAK;AAAA,QACH,OAAO;AAAA,QACP,MAAM;AAAA,QACN,MAAM;AAAA,MACP;AAAA,IACF;AAAA,IACD,IAAI;AAAA,MACF,IAAI;AAAA,QACF,MAAM;AAAA,MACP;AAAA,MACD,KAAK;AAAA,QACH,MAAM;AAAA,QACN,OAAO;AAAA,QACP,OAAO;AAAA,MACR;AAAA,IACF;AAAA,IACD,IAAI;AAAA,MACF,IAAI;AAAA,QACF,MAAM;AAAA,MACP;AAAA,MACD,KAAK;AAAA,QACH,MAAM;AAAA,QACN,OAAO;AAAA,QACP,OAAO;AAAA,MACR;AAAA,IACF;AAAA,IACD,IAAI;AAAA,MACF,IAAI;AAAA,QACF,OAAO;AAAA,MACR;AAAA,MACD,KAAK;AAAA,QACH,OAAO;AAAA,QACP,MAAM;AAAA,QACN,MAAM;AAAA,MACP;AAAA,IACF;AAAA,EACL;AACE,SAAAA,EAAQ,KAAKA,EAAQ,IACrB4C,EAAI,KAAK,SAASD,GAAgBD,GAAeD,CAAQ,GAClDzC,EAAQ2C,CAAc,EAAED,CAAa,EAAED,CAAQ;AAExD,GAEMI,IAAc,CAACtB,GAAMmB,GAAeC,MAAmB;AAE3D,MADAC,EAAI,KAAK,qBAAqB,EAAE,MAAArB,GAAM,eAAAmB,GAAe,gBAAAC,EAAc,CAAE,GACjE,CAAC3C,EAAQuB,CAAI;AACf,YAAQoB,GAAc;AAAA,MACpB,KAAK;AAAA,MACL,KAAK;AACH,QAAA3C,EAAQuB,CAAI,IAAI;AAAA,UACd,YAAY;AAAA,UACZ,aAAa;AAAA,QACvB;AACQ;AAAA,MACF,KAAK;AACH,QAAAvB,EAAQuB,CAAI,IAAI;AAAA,UACd,YAAY;AAAA,UACZ,aAAa;AAAA,QACvB;AACQ;AAAA,MACF,KAAK;AACH,QAAAvB,EAAQuB,CAAI,IAAI;AAAA,UACd,YAAY;AAAA,UACZ,aAAa;AAAA,QACvB;AACQ;AAAA,MACF,KAAK;AACH,QAAAvB,EAAQuB,CAAI,IAAI;AAAA,UACd,YAAY;AAAA,UACZ,aAAa;AAAA,QACvB;AACQ;AAAA,IACH;AAEH,QAAMuB,IAASJ,MAAkB,OAAO1C,EAAQuB,CAAI,EAAE,aAAavB,EAAQuB,CAAI,EAAE;AAEjF,SAAImB,MAAkB,OACpB1C,EAAQuB,CAAI,EAAE,aAAaiB;AAAA,IACzBxC,EAAQuB,CAAI,EAAE;AAAA,IACdmB;AAAA,IACAC;AAAA,EACN,IAEI3C,EAAQuB,CAAI,EAAE,cAAciB;AAAA,IAC1BxC,EAAQuB,CAAI,EAAE;AAAA,IACdmB;AAAA,IACAC;AAAA,EACN,GAESG;AACT,GAEMC,KAAuB,CAACC,GAAMC,MAAQ;AAC1C,MAAIC,IAASF,EAAK,OACdG,IAASH,EAAK;AAElB,QAAMI,IAAYlD,EAAOgD,CAAM,GACzBG,IAAUnD,EAAOiD,CAAM;AAE7B,SAAI,CAACC,KAAa,CAACC,IACV,EAAE,QAAAH,GAAQ,QAAAC,OAGfC,EAAU,SAAS,cACrBF,IAAS,GAAGA,KAAUL,EAAYK,GAAQ,OAAOD,CAAG,MAGlDI,EAAQ,SAAS,cACnBF,IAAS,GAAGA,KAAUN,EAAYM,GAAQ,MAAMF,CAAG,MAI9C,EAAE,QAAAC,GAAQ,QAAAC;AACnB,GAYaG,KAAW,SAAUC,GAAO/C,GAASE,GAAOC,GAAK;AAC5D,EAAAiC,EAAI,KAAK,kBAAkBW,CAAK;AAChC,QAAMC,IAAW7C,EAAI,OAAO,GAAG,EAAE,KAAK,SAAS,YAAY;AAC3D,MAAI8C,IAAY,CAAA,GACZR,IAAMzC,EAAQ,GAAG,aAAY,GAC7BkD,GACAC;AAEJ,MAAIJ,EAAM,iBAAiB,QAAW;AACpC,UAAMK,IAAgB3C,EAAmBsC,EAAM,YAAY;AAC3D,IAAAG,IAAeE,EAAc,OAC7BD,IAAoBC,EAAc;AAAA,EACnC;AAED,SAAAL,EAAM,QAAQ,SAAUP,GAAM;AAE5B,QAAIa,IAAa,OAAOb,EAAK,QAAQ,MAAMA,EAAK;AAEhD,IAAIS,EAAUI,CAAU,MAAM,UAC5BJ,EAAUI,CAAU,IAAI,GACxBjB,EAAI,KAAK,mBAAmBiB,GAAYJ,EAAUI,CAAU,CAAC,MAE7DJ,EAAUI,CAAU,KACpBjB,EAAI,KAAK,mBAAmBiB,GAAYJ,EAAUI,CAAU,CAAC;AAE/D,QAAIC,IAASD,IAAa,MAAMJ,EAAUI,CAAU;AACpD,IAAAjB,EAAI,KAAK,mCAAmCiB,GAAYC,GAAQL,EAAUI,CAAU,CAAC;AACrF,QAAIE,IAAgB,QAAQf,EAAK,OAC7BgB,IAAc,QAAQhB,EAAK;AAE/B,UAAMiB,IAAW,EAAE,OAAO,IAAI,YAAY,GAAE;AAgB5C,YAfAA,EAAS,SAASjB,EAAK,UAAU,GAI7BA,EAAK,SAAS,eAChBiB,EAAS,YAAY,SAErBA,EAAS,YAAY,UAIvBA,EAAS,iBAAiB,cAC1BA,EAAS,eAAe,cAGhBjB,EAAK,MAAI;AAAA,MACf,KAAK;AACH,QAAAiB,EAAS,iBAAiB;AAAA,MAC5B,KAAK;AACH,QAAAA,EAAS,eAAe;AACxB;AAAA,MACF,KAAK;AACH,QAAAA,EAAS,iBAAiB;AAAA,MAC5B,KAAK;AACH,QAAAA,EAAS,eAAe;AACxB;AAAA,MACF,KAAK;AACH,QAAAA,EAAS,iBAAiB;AAAA,MAC5B,KAAK;AACH,QAAAA,EAAS,eAAe;AACxB;AAAA,IACH;AAED,QAAIC,IAAQ,IACRC,IAAa;AAEjB,YAAQnB,EAAK,QAAM;AAAA,MACjB,KAAK;AACH,QAAAkB,IAAQ,cACJR,MAAiB,WACnBQ,IAAQR,IAENC,MAAsB,WACxBQ,IAAaR,IAEfM,EAAS,YAAY,UACrBA,EAAS,UAAU;AACnB;AAAA,MACF,KAAK;AACH,QAAAA,EAAS,YAAY,UACrBA,EAAS,UAAU,UACnBA,EAAS,QAAQ;AACjB;AAAA,MACF,KAAK;AACH,QAAAA,EAAS,YAAY,SACrBA,EAAS,UAAU,SACnBA,EAAS,QAAQ;AACjB;AAAA,IACH;AACD,QAAIjB,EAAK,UAAU,QAAW;AAC5B,YAAMhC,IAASC,EAAmB+B,EAAK,KAAK;AAC5C,MAAAkB,IAAQlD,EAAO,OACfmD,IAAanD,EAAO;AAAA,IACrB;AAED,IAAAiD,EAAS,QAAQA,EAAS,SAASC,GACnCD,EAAS,aAAaA,EAAS,cAAcE,GAEzCnB,EAAK,gBAAgB,SACvBiB,EAAS,QAAQG,EAAmBpB,EAAK,aAAaqB,CAAW,IACxDd,EAAM,uBAAuB,SACtCU,EAAS,QAAQG,EAAmBb,EAAM,oBAAoBc,CAAW,IAEzEJ,EAAS,QAAQG,EAAmBnE,GAAK,OAAOoE,CAAW,GAGzDrB,EAAK,SAAS,SACZA,EAAK,UAAU,WACjBiB,EAAS,iBAAiB,iBAG5BA,EAAS,iBAAiB,cAC1BA,EAAS,WAAW,MAGtBA,EAAS,YAAY,QACrBA,EAAS,QAAQjB,EAAK,KAAK,QAAQnB,EAAO,gBAAgB;AAAA,CAAI,GAE1DmB,EAAK,UAAU,WACjBiB,EAAS,QAAQA,EAAS,SAAS,iDAGrCA,EAAS,aAAaA,EAAS,WAAW,QAAQ,UAAU,OAAO,GAEnEA,EAAS,KAAKH,GACdG,EAAS,UAAU,oBAAoBF,IAAgB,MAAMC;AAE7D,UAAMM,IAAUC,EAAgBf,GAAUS,CAAQ,GAG5C,EAAE,QAAAf,GAAQ,QAAAC,EAAM,IAAKJ,GAAqBC,GAAMC,CAAG;AACzD,IAAAL,EAAI,MAAM,2BAA2BM,GAAQC,CAAM,GAEnDzC,EAAM,MAAM,KAAK;AAAA,MACf,IAAI,MAAMsC,EAAK,QAAQA,EAAK;AAAA,MAC5B,SAAS,CAACE,CAAM;AAAA,MAChB,SAAS,CAACC,CAAM;AAAA,MAChB,SAASmB;AAAA,MACT,QAAQ;AAAA,QACN;AAAA,UACE,OAAOL,EAAS;AAAA,UAChB,QAAQA,EAAS;AAAA,UACjB,UAAUA,EAAS;AAAA,UACnB,WAAWA,EAAS;AAAA,UACpB,MAAMA,EAAS;AAAA,UACf,eAAe;AAAA,YACb,qBAAqB;AAAA,YACrB,wBAAwB;AAAA,UACzB;AAAA,QACF;AAAA,MACF;AAAA,MACD,UAAAA;AAAA,IACN,CAAK;AAAA,EACL,CAAG,GACMvD;AACT,GAYM8D,KAAmB,SAAUC,GAASR,GAAUS,GAAaC,GAAqB;AACtF,MAAIC,IAAM;AAcV,UAZID,MACFC,IACE,OAAO,SAAS,WAChB,OACA,OAAO,SAAS,OAChB,OAAO,SAAS,WAChB,OAAO,SAAS,QAClBA,IAAMA,EAAI,QAAQ,OAAO,KAAK,GAC9BA,IAAMA,EAAI,QAAQ,OAAO,KAAK,IAIxBX,EAAS,gBAAc;AAAA,IAC7B,KAAK;AACH,MAAAQ,EAAQ,KAAK,gBAAgB,SAASG,IAAM,MAAMF,IAAc,cAAmB;AACnF;AAAA,IACF,KAAK;AACH,MAAAD,EAAQ,KAAK,gBAAgB,SAASG,IAAM,MAAMF,IAAc,cAAmB;AACnF;AAAA,IACF,KAAK;AACH,MAAAD,EAAQ,KAAK,gBAAgB,SAASG,IAAM,MAAMF,IAAc,aAAkB;AAClF;AAAA,IACF,KAAK;AACH,MAAAD,EAAQ,KAAK,gBAAgB,SAASG,IAAM,MAAMF,IAAc,eAAoB;AACpF;AAAA,IACF,KAAK;AACH,MAAAD,EAAQ,KAAK,gBAAgB,SAASG,IAAM,MAAMF,IAAc,oBAAyB;AACzF;AAAA,IACF,KAAK;AACH,MAAAD,EAAQ,KAAK,gBAAgB,SAASG,IAAM,MAAMF,IAAc,kBAAuB;AACvF;AAAA,IACF,KAAK;AACH,MAAAD,EAAQ,KAAK,gBAAgB,SAASG,IAAM,MAAMF,IAAc,oBAAyB;AACzF;AAAA,IACF,KAAK;AACH,MAAAD,EAAQ,KAAK,gBAAgB,SAASG,IAAM,MAAMF,IAAc,mBAAwB;AACxF;AAAA,IACF,KAAK;AACH,MAAAD,EAAQ,KAAK,gBAAgB,SAASG,IAAM,MAAMF,IAAc,iBAAsB;AACtF;AAAA,EAEH;AACD,UAAQT,EAAS,cAAY;AAAA,IAC3B,KAAK;AACH,MAAAQ,EAAQ,KAAK,cAAc,SAASG,IAAM,MAAMF,IAAc,YAAiB;AAC/E;AAAA,IACF,KAAK;AACH,MAAAD,EAAQ,KAAK,cAAc,SAASG,IAAM,MAAMF,IAAc,YAAiB;AAC/E;AAAA,IACF,KAAK;AACH,MAAAD,EAAQ,KAAK,cAAc,SAASG,IAAM,MAAMF,IAAc,WAAgB;AAC9E;AAAA,IACF,KAAK;AACH,MAAAD,EAAQ,KAAK,cAAc,SAASG,IAAM,MAAMF,IAAc,aAAkB;AAChF;AAAA,IACF,KAAK;AACH,MAAAD,EAAQ,KAAK,cAAc,SAASG,IAAM,MAAMF,IAAc,kBAAuB;AACrF;AAAA,IACF,KAAK;AACH,MAAAD,EAAQ,KAAK,cAAc,SAASG,IAAM,MAAMF,IAAc,gBAAqB;AACnF;AAAA,IACF,KAAK;AACH,MAAAD,EAAQ,KAAK,cAAc,SAASG,IAAM,MAAMF,IAAc,kBAAuB;AACrF;AAAA,IACF,KAAK;AACH,MAAAD,EAAQ,KAAK,cAAc,SAASG,IAAM,MAAMF,IAAc,iBAAsB;AACpF;AAAA,IACF,KAAK;AACH,MAAAD,EAAQ,KAAK,cAAc,SAASG,IAAM,MAAMF,IAAc,eAAoB;AAClF;AAAA,EAEH;AACH,GASaG,KAAa,SAAUC,GAAMtE,GAAS;AACjD,EAAAoC,EAAI,KAAK,oBAAoB,GAC7BpC,EAAQ,GAAG,MAAM,OAAO;AACxB,MAAI;AAEF,WAAAA,EAAQ,MAAMsE,CAAI,GACXtE,EAAQ,GAAG;EACnB,QAAC;AACA,WAAO;EACR;AACH,GAEMuE,KAAe,SAAUC,GAAI;AACjC,QAAMvE,IAAiB,EAAE,YAAY,CAAE,GAAE,cAAc,CAAE,EAAA,GACnDwE,IAAYD,EAAG;AACrB,SAAApC,EAAI,KAAK,gBAAgBqC,CAAS,GAClCA,EAAU,QAAQ,SAAUC,GAAU;AACpC,IAAAA,EAAS,MAAM,QAAQ,SAAU3D,GAAM;AACrC,MAAAd,EAAe,WAAWc,CAAI,IAAI2D,EAAS,IACvCzE,EAAe,aAAayE,EAAS,EAAE,MAAM,WAC/CzE,EAAe,aAAayE,EAAS,EAAE,IAAI,CAAA,IAE7CzE,EAAe,aAAayE,EAAS,EAAE,EAAE,KAAK3D,CAAI;AAAA,IACxD,CAAK;AAAA,EACL,CAAG,GAED0D,EAAU,QAAQ,SAAUC,GAAU;AACxC,IAAuBA,EAAS,IACxBzE,EAAe,WAAWyE,EAAS,EAAE,MAAM,UAC/BzE,EAAe,WAAWyE,EAAS,EAAE;AAAA,EAEzD,CAAG,GACMzE;AACT,GAEM0E,KAAa,SAAUC,GAAKC,GAAM5E,GAAgB;AACtD,QAAM6E,IAAW9F,EAAmB4F,GAAKC,GAAM5E,CAAc;AAC7D,MAAI6E,MAAa,UAAaA,MAAa;AACzC,WAAO,EAAE,GAAG,GAAG,GAAG,EAAC;AAGrB,QAAMC,IAAiBrF,EAAOoF,CAAQ,EAAE;AACxC,SAAO,EAAE,GAAGC,EAAe,MAAM,GAAGA,EAAe;AACrD,GAEMC,KAAa,SAAUC,GAASzC,GAAMiB,GAAUzD,GAASC,GAAgB;AAC7E,QAAMiF,IAASP,GAAWnC,EAAK,QAAQ,CAAC,GAAGA,EAAK,QAAQ,CAAC,GAAGvC,CAAc,GAEpE2E,IAAMpC,EAAK,SAAS,CAAC,EAAE,YACvBqC,IAAOrC,EAAK,SAAS,CAAC,EAAE,UAGxB2C,KAFW3C,EAAK,SAAS,CAAC,EAAE,aAAaA,EAAK,SAAS,CAAC,EAAE,aAAa,CAAA,GAElD,IAAI,CAAC4C,MAAY,CAACA,EAAQ,IAAIF,EAAO,GAAGE,EAAQ,IAAIF,EAAO,CAAC,CAAC,GAClFG,IAAS;AAAA,IACb,CAACT,EAAI,IAAIM,EAAO,GAAGN,EAAI,IAAIM,EAAO,CAAC;AAAA,IACnC,GAAGC;AAAA,IACH,CAACN,EAAK,IAAIK,EAAO,GAAGL,EAAK,IAAIK,EAAO,CAAC;AAAA,EACzC,GAGQI,IAAQC,EAAI,EAAG,MAAM1B,CAAW,GAChC2B,IAAWP,EACd,OAAO,MAAM,EACb,KAAK,KAAKK,EAAMD,CAAM,CAAC,EACvB,KAAK,SAAS,MAAM,EACpB,KAAK,QAAQ,MAAM,GAChBI,IAAQR,EAAQ,OAAO,GAAG,EAAE,KAAK,SAAS,WAAW,GACrDS,IAAgBC,EAAOF,EAAM,KAAM,EAAC,YAAYjD,EAAK,OAAO,CAAC,GAC7DoD,IAAMF,EAAc,KAAM,EAAC,WAAW,sBAAqB;AACjE,EAAAA,EAAc,KAAK,SAASE,EAAI,KAAK,GACrCF,EAAc,KAAK,UAAUE,EAAI,MAAM,GAEvCH,EAAM;AAAA,IACJ;AAAA,IACA,aAAajD,EAAK,OAAO,CAAC,EAAE,IAAI0C,EAAO,MAAM1C,EAAK,OAAO,CAAC,EAAE,IAAI0C,EAAO;AAAA,EAC3E,GACElB,GAAiBwB,GAAU/B,GAAUzD,EAAQ,MAAMA,EAAQ,mBAAmB;AAChF,GASM6F,IAAiB,CAACC,GAAW7F,MAAmB;AACpD,EAAA6F,EAAU,QAAQ,CAAC/E,MAAS;AAE1B,IAAKA,EAAK,aACRA,EAAK,WAAW;AAGlB,UAAMgF,IAAW9F,EAAe,aAAac,EAAK,EAAE;AAEpD,IAAIgF,KACFA,EAAS,QAAQ,CAACC,MAAY;AAC5B,MAAAjF,EAAK,SAAS,KAAKrB,EAAOsG,CAAO,CAAC;AAAA,IAC1C,CAAO,GAGHH,EAAe9E,EAAK,UAAUd,CAAc;AAAA,EAChD,CAAG;AACH,GASagG,KAAO,eAAgB3B,GAAMjE,GAAI6F,GAAUlG,GAAS;;AAC/D,MAAI,CAACT,GAAK;AACR,UAAM4G,KAAO,MAAM,OAAO,2BAA0B,EAAA,KAAA,CAAAC,MAAAA,EAAA,CAAA,GAAG;AACvD,IAAA7G,IAAM,IAAI4G;EACX;AAED,EAAAnG,EAAQ,GAAG,SACXN,IAAS,CAAA,GACTM,EAAQ,GAAG,OAAO,OAAO,GAEzBA,EAAQ,OAAO,MAAMsE,CAAI;AAEzB,QAAM+B,IAAWV,EAAO,MAAM,EAAE,OAAO,KAAK,EAAE,KAAK,SAAS,cAAc,EAAE,KAAK,MAAM,IAAI;AAC3F,MAAIzF,IAAQ;AAAA,IACV,IAAI;AAAA,IACJ,eAAe;AAAA,MACb,yBAAyB;AAAA,MACzB,2BAA2B;AAAA,MAC3B,6CAA6C;AAAA;AAAA,MAE7C,iBAAiB;AAAA;AAAA;AAAA,IAGlB;AAAA,IACD,UAAU,CAAE;AAAA,IACZ,OAAO,CAAE;AAAA,EACb;AAME,UALAkC,EAAI,KAAK,uCAAuC7C,CAAG,GAIzCS,EAAQ,GAAG,aAAY,GACtB;AAAA,IACT,KAAK;AACH,MAAAE,EAAM,cAAc,eAAe,IAAI;AACvC;AAAA,IACF,KAAK;AACH,MAAAA,EAAM,cAAc,eAAe,IAAI;AACvC;AAAA,IACF,KAAK;AACH,MAAAA,EAAM,cAAc,eAAe,IAAI;AACvC;AAAA,IACF,KAAK;AACH,MAAAA,EAAM,cAAc,eAAe,IAAI;AACvC;AAAA,EACH;AACD,QAAM,EAAE,eAAAoG,GAAe,WAAW7G,EAAM,IAAGqB,EAAS;AAIpD,MAAIyF;AACJ,EAAID,MAAkB,cACpBC,IAAiBZ,EAAO,OAAOtF,CAAE;AAEnC,QAAMP,IACJwG,MAAkB,YACdX,EAAOY,EAAe,MAAK,EAAG,CAAC,EAAE,gBAAgB,IAAI,IACrDZ,EAAO,MAAM,GACb5F,IAAMuG,MAAkB,YAAYC,EAAe,MAAK,EAAG,CAAC,EAAE,kBAAkB,UAEhFpG,IAAML,EAAK,OAAO,QAAQO,KAAM;AAMtC,EAAAmG,EAAcrG,GAHE,CAAC,SAAS,UAAU,OAAO,GAGfH,EAAQ,MAAMA,EAAQ,mBAAmB;AAGrE,QAAMJ,IAAOI,EAAQ,GAAG,YAAW;AAInC,MAAIyG;AACJ,QAAMC,IAAY1G,EAAQ,GAAG,aAAY;AACzC,EAAAoC,EAAI,KAAK,gBAAgBsE,CAAS;AAClC,WAASC,IAAID,EAAU,SAAS,GAAGC,KAAK,GAAGA;AACzC,IAAAF,IAAOC,EAAUC,CAAC,GAClB3G,EAAQ,GAAG,UAAUyG,EAAK,IAAIA,EAAK,OAAO,SAAS,QAAWA,EAAK,SAASA,EAAK,GAAG;AAKtF,QAAMG,IAAczG,EAAI,OAAO,GAAG,EAAE,KAAK,SAAS,WAAW,GAIvDF,IAAiBsE,GAAavE,EAAQ,EAAE;AAM9C,EAAAE,IAAQP,GAAYC,GAAMS,GAAIP,GAAMC,GAAKC,GAASC,GAAgBC,CAAK;AAGvE,QAAM+E,IAAU9E,EAAI,OAAO,GAAG,EAAE,KAAK,SAAS,gBAAgB,GAExD4C,IAAQ/C,EAAQ,GAAG,SAAQ;AAGjC,EAAAE,IAAQ4C,GAASC,GAAO/C,GAASE,GAAOC,CAAG,GAG7B,OAAO,KAAKT,CAAM,EAC1B,QAAQ,CAACmH,MAAW;AACxB,UAAM9F,IAAOrB,EAAOmH,CAAM;AAC1B,IAAK9F,EAAK,UACRb,EAAM,SAAS,KAAKa,CAAI,GAGtBd,EAAe,aAAa4G,CAAM,MAAM,WAC1C9F,EAAK,SAAS;AAAA,MACZ;AAAA,QACE,MAAMA,EAAK;AAAA,QACX,eAAe;AAAA,UACb,wBAAwB;AAAA,QACzB;AAAA,QACD,OAAOA,EAAK,UAAU;AAAA,QACtB,QAAQA,EAAK,UAAU;AAAA,MACxB;AAAA,IACT,GACM,OAAOA,EAAK,GACZ,OAAOA,EAAK,GACZ,OAAOA,EAAK,OACZ,OAAOA,EAAK;AAAA,EAElB,CAAG,GACD8E,EAAe3F,EAAM,UAAUD,CAAc,GAC7CmC,EAAI,KAAK,gBAAgB,KAAK,UAAUlC,GAAO,MAAM,CAAC,CAAC;AACvD,QAAM,IAAI,MAAMX,EAAI,OAAOW,CAAK;AAChC,EAAA4G,EAAU,GAAG,GAAG,EAAE,UAAU3G,GAAKyG,GAAa5G,GAAS,CAAC,GACxDoC,EAAI,KAAK,gBAAgB,CAAC,IAC1B2E,IAAA,EAAE,UAAF,QAAAA,EAAS,IAAI,CAACvE,MAAS;AACrB,IAAAwC,GAAWC,GAASzC,GAAMA,EAAK,UAAUxC,GAASC,CAAc;AAAA,EACpE,IACE+G,EAAkB,CAAE,GAAE7G,GAAKV,EAAK,gBAAgBA,EAAK,WAAW,GAEhE4G,EAAS,OAAM;AACjB,GAEMS,IAAY,CAACG,GAAMC,GAAMpB,GAAW3F,GAAKgH,GAAanH,GAASoH,MAAU;AAC7E,EAAAtB,EAAU,QAAQ,SAAU/E,GAAM;AAChC,QAAIA;AAUF,UATArB,EAAOqB,EAAK,EAAE,EAAE,SAAS;AAAA,QACvB,MAAMA,EAAK,IAAIkG;AAAA,QACf,MAAMlG,EAAK,IAAImG;AAAA,QACf,GAAGD;AAAA,QACH,GAAGC;AAAA,QACH,OAAAE;AAAA,QACA,OAAOrG,EAAK;AAAA,QACZ,QAAQA,EAAK;AAAA,MACrB,GACUA,EAAK,SAAS,SAAS;AACzB,cAAMsG,IAAaF,EAAY,OAAO,GAAG,EAAE,KAAK,SAAS,UAAU;AACnE,QAAAE,EACG,OAAO,MAAM,EACb,KAAK,SAAS,2BAA4BD,IAAQ,IAAK,OAAO,EAC9D,KAAK,KAAKrG,EAAK,IAAIkG,CAAI,EACvB,KAAK,KAAKlG,EAAK,IAAImG,CAAI,EACvB,KAAK,SAASnG,EAAK,KAAK,EACxB,KAAK,UAAUA,EAAK,MAAM;AAC7B,cAAMuG,IAAQD,EAAW,OAAO,GAAG,EAAE,KAAK,SAAS,OAAO;AAC1D,QAAAC,EAAM;AAAA,UACJ;AAAA,UACA,aAAavG,EAAK,OAAO,CAAC,EAAE,IAAIkG,IAAOlG,EAAK,MAAMA,EAAK,OAAO,CAAC,EAAE,IAAImG,IAAOnG,EAAK;AAAA,QAC3F,GACQuG,EAAM,KAAI,EAAG,YAAYvG,EAAK,UAAU,SAAS,GAEjDqB,EAAI,KAAK,cAAcrB,EAAK,MAAMA,EAAK,MAAM;AAAA,MACrD;AACQ,QAAAqB,EAAI,KAAK,cAAcrB,EAAK,EAAE,GAC9BA,EAAK,GAAG;AAAA,UACN;AAAA,UACA,aAAaA,EAAK,IAAIkG,IAAOlG,EAAK,QAAQ,MAAMA,EAAK,IAAImG,IAAOnG,EAAK,SAAS;AAAA,QACxF;AAAA,EAGA,CAAG,GACD+E,EAAU,QAAQ,SAAU/E,GAAM;AAChC,IAAIA,KAAQA,EAAK,SAAS,WACxB+F,EAAUG,IAAOlG,EAAK,GAAGmG,IAAOnG,EAAK,GAAGA,EAAK,UAAUZ,GAAKgH,GAAanH,GAASoH,IAAQ,CAAC;AAAA,EAEjG,CAAG;AACH,GAEeG,KAAA;AAAA,EACb,YAAAlD;AAAA,EACA,MAAA4B;AACF,GCz6BMuB,KAAc,CAACC,MAAmC;AACtD,MAAIC,IAAW;AAEf,WAASf,IAAI,GAAGA,IAAI,GAAGA;AACT,IAAAe,KAAA;AAAA,sBACMf;AAAA,gBACNc,EAAQ,UAAUd,GAAG;AAAA,kBACnBc,EAAQ,cAAcd,GAAG;AAAA;AAAA;AAIlC,SAAAe;AACT,GAEMC,KAAY,CAACF,MACjB;AAAA,mBACiBA,EAAQ;AAAA,aACdA,EAAQ,iBAAiBA,EAAQ;AAAA;AAAA;AAAA,YAGlCA,EAAQ;AAAA;AAAA;AAAA,aAGPA,EAAQ;AAAA;AAAA;AAAA;AAAA,YAITA,EAAQ,iBAAiBA,EAAQ;AAAA,aAChCA,EAAQ,iBAAiBA,EAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAQlCA,EAAQ;AAAA,cACNA,EAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAYVA,EAAQ;AAAA;AAAA;AAAA;AAAA,cAINA,EAAQ;AAAA;AAAA;AAAA;AAAA;AAAA,cAKRA,EAAQ;AAAA;AAAA;AAAA;AAAA;AAAA,wBAKEA,EAAQ;AAAA;AAAA;AAAA,0BAGNA,EAAQ;AAAA,cACpBA,EAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAMVA,EAAQ;AAAA,cACNA,EAAQ;AAAA;AAAA;AAAA;AAAA;AAAA,YAKVA,EAAQ;AAAA;AAAA;AAAA;AAAA,aAIPA,EAAQ;AAAA;AAAA;AAAA,aAGRA,EAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAQFA,EAAQ;AAAA;AAAA,kBAETA,EAAQ;AAAA,wBACFA,EAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YASpBA,EAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAUhBD,GAAYC,CAAO;AAAA,GAGvBjH,KAAemH,IClIFC,KAAU;AAAA,EACrB,IAAApD;AAAA,EACA,UAAA+C;AAAA,EACA,QAAAM;AAAA,EACA,QAAArH;AACF;"}