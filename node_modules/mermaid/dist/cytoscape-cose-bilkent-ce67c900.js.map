{"version":3,"file":"cytoscape-cose-bilkent-ce67c900.js","sources":["../../../node_modules/.pnpm/layout-base@1.0.2/node_modules/layout-base/layout-base.js","../../../node_modules/.pnpm/cose-base@1.0.3/node_modules/cose-base/cose-base.js","../../../node_modules/.pnpm/cytoscape-cose-bilkent@4.1.0_cytoscape@3.23.0/node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"layoutBase\"] = factory();\n\telse\n\t\troot[\"layoutBase\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 26);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LayoutConstants() {}\n\n/**\r\n * Layout Quality: 0:draft, 1:default, 2:proof\r\n */\nLayoutConstants.QUALITY = 1;\n\n/**\r\n * Default parameters\r\n */\nLayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\nLayoutConstants.DEFAULT_INCREMENTAL = false;\nLayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\nLayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\nLayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\nLayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n\n// -----------------------------------------------------------------------------\n// Section: General other constants\n// -----------------------------------------------------------------------------\n/*\r\n * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n * assume margins on all four sides to be uniform.\r\n */\nLayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n\n/*\r\n * Whether to consider labels in node dimensions or not\r\n */\nLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_SIZE = 40;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n\n/*\r\n * Empty compound node size. When a compound node is empty, its both\r\n * dimensions should be of this value.\r\n */\nLayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n\n/*\r\n * Minimum length that an edge should take during layout\r\n */\nLayoutConstants.MIN_EDGE_LENGTH = 1;\n\n/*\r\n * World boundaries that layout operates on\r\n */\nLayoutConstants.WORLD_BOUNDARY = 1000000;\n\n/*\r\n * World boundaries that random positioning can be performed with\r\n */\nLayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n\n/*\r\n * Coordinates of the world center\r\n */\nLayoutConstants.WORLD_CENTER_X = 1200;\nLayoutConstants.WORLD_CENTER_Y = 900;\n\nmodule.exports = LayoutConstants;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __webpack_require__(2);\nvar IGeometry = __webpack_require__(8);\nvar IMath = __webpack_require__(9);\n\nfunction LEdge(source, target, vEdge) {\n  LGraphObject.call(this, vEdge);\n\n  this.isOverlapingSourceAndTarget = false;\n  this.vGraphObject = vEdge;\n  this.bendpoints = [];\n  this.source = source;\n  this.target = target;\n}\n\nLEdge.prototype = Object.create(LGraphObject.prototype);\n\nfor (var prop in LGraphObject) {\n  LEdge[prop] = LGraphObject[prop];\n}\n\nLEdge.prototype.getSource = function () {\n  return this.source;\n};\n\nLEdge.prototype.getTarget = function () {\n  return this.target;\n};\n\nLEdge.prototype.isInterGraph = function () {\n  return this.isInterGraph;\n};\n\nLEdge.prototype.getLength = function () {\n  return this.length;\n};\n\nLEdge.prototype.isOverlapingSourceAndTarget = function () {\n  return this.isOverlapingSourceAndTarget;\n};\n\nLEdge.prototype.getBendpoints = function () {\n  return this.bendpoints;\n};\n\nLEdge.prototype.getLca = function () {\n  return this.lca;\n};\n\nLEdge.prototype.getSourceInLca = function () {\n  return this.sourceInLca;\n};\n\nLEdge.prototype.getTargetInLca = function () {\n  return this.targetInLca;\n};\n\nLEdge.prototype.getOtherEnd = function (node) {\n  if (this.source === node) {\n    return this.target;\n  } else if (this.target === node) {\n    return this.source;\n  } else {\n    throw \"Node is not incident with this edge\";\n  }\n};\n\nLEdge.prototype.getOtherEndInGraph = function (node, graph) {\n  var otherEnd = this.getOtherEnd(node);\n  var root = graph.getGraphManager().getRoot();\n\n  while (true) {\n    if (otherEnd.getOwner() == graph) {\n      return otherEnd;\n    }\n\n    if (otherEnd.getOwner() == root) {\n      break;\n    }\n\n    otherEnd = otherEnd.getOwner().getParent();\n  }\n\n  return null;\n};\n\nLEdge.prototype.updateLength = function () {\n  var clipPointCoordinates = new Array(4);\n\n  this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n\n  if (!this.isOverlapingSourceAndTarget) {\n    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n\n    if (Math.abs(this.lengthX) < 1.0) {\n      this.lengthX = IMath.sign(this.lengthX);\n    }\n\n    if (Math.abs(this.lengthY) < 1.0) {\n      this.lengthY = IMath.sign(this.lengthY);\n    }\n\n    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n  }\n};\n\nLEdge.prototype.updateLengthSimple = function () {\n  this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n  this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n\n  if (Math.abs(this.lengthX) < 1.0) {\n    this.lengthX = IMath.sign(this.lengthX);\n  }\n\n  if (Math.abs(this.lengthY) < 1.0) {\n    this.lengthY = IMath.sign(this.lengthY);\n  }\n\n  this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n};\n\nmodule.exports = LEdge;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LGraphObject(vGraphObject) {\n  this.vGraphObject = vGraphObject;\n}\n\nmodule.exports = LGraphObject;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __webpack_require__(2);\nvar Integer = __webpack_require__(10);\nvar RectangleD = __webpack_require__(13);\nvar LayoutConstants = __webpack_require__(0);\nvar RandomSeed = __webpack_require__(16);\nvar PointD = __webpack_require__(4);\n\nfunction LNode(gm, loc, size, vNode) {\n  //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n  if (size == null && vNode == null) {\n    vNode = loc;\n  }\n\n  LGraphObject.call(this, vNode);\n\n  //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n  if (gm.graphManager != null) gm = gm.graphManager;\n\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.inclusionTreeDepth = Integer.MAX_VALUE;\n  this.vGraphObject = vNode;\n  this.edges = [];\n  this.graphManager = gm;\n\n  if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();\n}\n\nLNode.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LNode[prop] = LGraphObject[prop];\n}\n\nLNode.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLNode.prototype.getChild = function () {\n  return this.child;\n};\n\nLNode.prototype.getOwner = function () {\n  //  if (this.owner != null) {\n  //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n  //      throw \"assert failed\";\n  //    }\n  //  }\n\n  return this.owner;\n};\n\nLNode.prototype.getWidth = function () {\n  return this.rect.width;\n};\n\nLNode.prototype.setWidth = function (width) {\n  this.rect.width = width;\n};\n\nLNode.prototype.getHeight = function () {\n  return this.rect.height;\n};\n\nLNode.prototype.setHeight = function (height) {\n  this.rect.height = height;\n};\n\nLNode.prototype.getCenterX = function () {\n  return this.rect.x + this.rect.width / 2;\n};\n\nLNode.prototype.getCenterY = function () {\n  return this.rect.y + this.rect.height / 2;\n};\n\nLNode.prototype.getCenter = function () {\n  return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n};\n\nLNode.prototype.getLocation = function () {\n  return new PointD(this.rect.x, this.rect.y);\n};\n\nLNode.prototype.getRect = function () {\n  return this.rect;\n};\n\nLNode.prototype.getDiagonal = function () {\n  return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n};\n\n/**\n * This method returns half the diagonal length of this node.\n */\nLNode.prototype.getHalfTheDiagonal = function () {\n  return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n};\n\nLNode.prototype.setRect = function (upperLeft, dimension) {\n  this.rect.x = upperLeft.x;\n  this.rect.y = upperLeft.y;\n  this.rect.width = dimension.width;\n  this.rect.height = dimension.height;\n};\n\nLNode.prototype.setCenter = function (cx, cy) {\n  this.rect.x = cx - this.rect.width / 2;\n  this.rect.y = cy - this.rect.height / 2;\n};\n\nLNode.prototype.setLocation = function (x, y) {\n  this.rect.x = x;\n  this.rect.y = y;\n};\n\nLNode.prototype.moveBy = function (dx, dy) {\n  this.rect.x += dx;\n  this.rect.y += dy;\n};\n\nLNode.prototype.getEdgeListToNode = function (to) {\n  var edgeList = [];\n  var edge;\n  var self = this;\n\n  self.edges.forEach(function (edge) {\n\n    if (edge.target == to) {\n      if (edge.source != self) throw \"Incorrect edge source!\";\n\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getEdgesBetween = function (other) {\n  var edgeList = [];\n  var edge;\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (!(edge.source == self || edge.target == self)) throw \"Incorrect edge source and/or target\";\n\n    if (edge.target == other || edge.source == other) {\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getNeighborsList = function () {\n  var neighbors = new Set();\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (edge.source == self) {\n      neighbors.add(edge.target);\n    } else {\n      if (edge.target != self) {\n        throw \"Incorrect incidency!\";\n      }\n\n      neighbors.add(edge.source);\n    }\n  });\n\n  return neighbors;\n};\n\nLNode.prototype.withChildren = function () {\n  var withNeighborsList = new Set();\n  var childNode;\n  var children;\n\n  withNeighborsList.add(this);\n\n  if (this.child != null) {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n      children = childNode.withChildren();\n      children.forEach(function (node) {\n        withNeighborsList.add(node);\n      });\n    }\n  }\n\n  return withNeighborsList;\n};\n\nLNode.prototype.getNoOfChildren = function () {\n  var noOfChildren = 0;\n  var childNode;\n\n  if (this.child == null) {\n    noOfChildren = 1;\n  } else {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n\n      noOfChildren += childNode.getNoOfChildren();\n    }\n  }\n\n  if (noOfChildren == 0) {\n    noOfChildren = 1;\n  }\n  return noOfChildren;\n};\n\nLNode.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLNode.prototype.calcEstimatedSize = function () {\n  if (this.child == null) {\n    return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n  } else {\n    this.estimatedSize = this.child.calcEstimatedSize();\n    this.rect.width = this.estimatedSize;\n    this.rect.height = this.estimatedSize;\n\n    return this.estimatedSize;\n  }\n};\n\nLNode.prototype.scatter = function () {\n  var randomCenterX;\n  var randomCenterY;\n\n  var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n\n  var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n\n  this.rect.x = randomCenterX;\n  this.rect.y = randomCenterY;\n};\n\nLNode.prototype.updateBounds = function () {\n  if (this.getChild() == null) {\n    throw \"assert failed\";\n  }\n  if (this.getChild().getNodes().length != 0) {\n    // wrap the children nodes by re-arranging the boundaries\n    var childGraph = this.getChild();\n    childGraph.updateBounds(true);\n\n    this.rect.x = childGraph.getLeft();\n    this.rect.y = childGraph.getTop();\n\n    this.setWidth(childGraph.getRight() - childGraph.getLeft());\n    this.setHeight(childGraph.getBottom() - childGraph.getTop());\n\n    // Update compound bounds considering its label properties    \n    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = childGraph.getRight() - childGraph.getLeft();\n      var height = childGraph.getBottom() - childGraph.getTop();\n\n      if (this.labelWidth > width) {\n        this.rect.x -= (this.labelWidth - width) / 2;\n        this.setWidth(this.labelWidth);\n      }\n\n      if (this.labelHeight > height) {\n        if (this.labelPos == \"center\") {\n          this.rect.y -= (this.labelHeight - height) / 2;\n        } else if (this.labelPos == \"top\") {\n          this.rect.y -= this.labelHeight - height;\n        }\n        this.setHeight(this.labelHeight);\n      }\n    }\n  }\n};\n\nLNode.prototype.getInclusionTreeDepth = function () {\n  if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.inclusionTreeDepth;\n};\n\nLNode.prototype.transform = function (trans) {\n  var left = this.rect.x;\n\n  if (left > LayoutConstants.WORLD_BOUNDARY) {\n    left = LayoutConstants.WORLD_BOUNDARY;\n  } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n    left = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var top = this.rect.y;\n\n  if (top > LayoutConstants.WORLD_BOUNDARY) {\n    top = LayoutConstants.WORLD_BOUNDARY;\n  } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n    top = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var leftTop = new PointD(left, top);\n  var vLeftTop = trans.inverseTransformPoint(leftTop);\n\n  this.setLocation(vLeftTop.x, vLeftTop.y);\n};\n\nLNode.prototype.getLeft = function () {\n  return this.rect.x;\n};\n\nLNode.prototype.getRight = function () {\n  return this.rect.x + this.rect.width;\n};\n\nLNode.prototype.getTop = function () {\n  return this.rect.y;\n};\n\nLNode.prototype.getBottom = function () {\n  return this.rect.y + this.rect.height;\n};\n\nLNode.prototype.getParent = function () {\n  if (this.owner == null) {\n    return null;\n  }\n\n  return this.owner.getParent();\n};\n\nmodule.exports = LNode;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction PointD(x, y) {\n  if (x == null && y == null) {\n    this.x = 0;\n    this.y = 0;\n  } else {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nPointD.prototype.getX = function () {\n  return this.x;\n};\n\nPointD.prototype.getY = function () {\n  return this.y;\n};\n\nPointD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nPointD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nPointD.prototype.getDifference = function (pt) {\n  return new DimensionD(this.x - pt.x, this.y - pt.y);\n};\n\nPointD.prototype.getCopy = function () {\n  return new PointD(this.x, this.y);\n};\n\nPointD.prototype.translate = function (dim) {\n  this.x += dim.width;\n  this.y += dim.height;\n  return this;\n};\n\nmodule.exports = PointD;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __webpack_require__(2);\nvar Integer = __webpack_require__(10);\nvar LayoutConstants = __webpack_require__(0);\nvar LGraphManager = __webpack_require__(6);\nvar LNode = __webpack_require__(3);\nvar LEdge = __webpack_require__(1);\nvar RectangleD = __webpack_require__(13);\nvar Point = __webpack_require__(12);\nvar LinkedList = __webpack_require__(11);\n\nfunction LGraph(parent, obj2, vGraph) {\n  LGraphObject.call(this, vGraph);\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n  this.edges = [];\n  this.nodes = [];\n  this.isConnected = false;\n  this.parent = parent;\n\n  if (obj2 != null && obj2 instanceof LGraphManager) {\n    this.graphManager = obj2;\n  } else if (obj2 != null && obj2 instanceof Layout) {\n    this.graphManager = obj2.graphManager;\n  }\n}\n\nLGraph.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LGraph[prop] = LGraphObject[prop];\n}\n\nLGraph.prototype.getNodes = function () {\n  return this.nodes;\n};\n\nLGraph.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLGraph.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLGraph.prototype.getParent = function () {\n  return this.parent;\n};\n\nLGraph.prototype.getLeft = function () {\n  return this.left;\n};\n\nLGraph.prototype.getRight = function () {\n  return this.right;\n};\n\nLGraph.prototype.getTop = function () {\n  return this.top;\n};\n\nLGraph.prototype.getBottom = function () {\n  return this.bottom;\n};\n\nLGraph.prototype.isConnected = function () {\n  return this.isConnected;\n};\n\nLGraph.prototype.add = function (obj1, sourceNode, targetNode) {\n  if (sourceNode == null && targetNode == null) {\n    var newNode = obj1;\n    if (this.graphManager == null) {\n      throw \"Graph has no graph mgr!\";\n    }\n    if (this.getNodes().indexOf(newNode) > -1) {\n      throw \"Node already in graph!\";\n    }\n    newNode.owner = this;\n    this.getNodes().push(newNode);\n\n    return newNode;\n  } else {\n    var newEdge = obj1;\n    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n      throw \"Source or target not in graph!\";\n    }\n\n    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n      throw \"Both owners must be this graph!\";\n    }\n\n    if (sourceNode.owner != targetNode.owner) {\n      return null;\n    }\n\n    // set source and target\n    newEdge.source = sourceNode;\n    newEdge.target = targetNode;\n\n    // set as intra-graph edge\n    newEdge.isInterGraph = false;\n\n    // add to graph edge list\n    this.getEdges().push(newEdge);\n\n    // add to incidency lists\n    sourceNode.edges.push(newEdge);\n\n    if (targetNode != sourceNode) {\n      targetNode.edges.push(newEdge);\n    }\n\n    return newEdge;\n  }\n};\n\nLGraph.prototype.remove = function (obj) {\n  var node = obj;\n  if (obj instanceof LNode) {\n    if (node == null) {\n      throw \"Node is null!\";\n    }\n    if (!(node.owner != null && node.owner == this)) {\n      throw \"Owner graph is invalid!\";\n    }\n    if (this.graphManager == null) {\n      throw \"Owner graph manager is invalid!\";\n    }\n    // remove incident edges first (make a copy to do it safely)\n    var edgesToBeRemoved = node.edges.slice();\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n\n      if (edge.isInterGraph) {\n        this.graphManager.remove(edge);\n      } else {\n        edge.source.owner.remove(edge);\n      }\n    }\n\n    // now the node itself\n    var index = this.nodes.indexOf(node);\n    if (index == -1) {\n      throw \"Node not in owner node list!\";\n    }\n\n    this.nodes.splice(index, 1);\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n      throw \"Source and/or target owner is invalid!\";\n    }\n\n    var sourceIndex = edge.source.edges.indexOf(edge);\n    var targetIndex = edge.target.edges.indexOf(edge);\n    if (!(sourceIndex > -1 && targetIndex > -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    edge.source.edges.splice(sourceIndex, 1);\n\n    if (edge.target != edge.source) {\n      edge.target.edges.splice(targetIndex, 1);\n    }\n\n    var index = edge.source.owner.getEdges().indexOf(edge);\n    if (index == -1) {\n      throw \"Not in owner's edge list!\";\n    }\n\n    edge.source.owner.getEdges().splice(index, 1);\n  }\n};\n\nLGraph.prototype.updateLeftTop = function () {\n  var top = Integer.MAX_VALUE;\n  var left = Integer.MAX_VALUE;\n  var nodeTop;\n  var nodeLeft;\n  var margin;\n\n  var nodes = this.getNodes();\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeTop = lNode.getTop();\n    nodeLeft = lNode.getLeft();\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n  }\n\n  // Do we have any nodes in this graph?\n  if (top == Integer.MAX_VALUE) {\n    return null;\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = left - margin;\n  this.top = top - margin;\n\n  // Apply the margins and return the result\n  return new Point(this.left, this.top);\n};\n\nLGraph.prototype.updateBounds = function (recursive) {\n  // calculate bounds\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n  var margin;\n\n  var nodes = this.nodes;\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n\n    if (recursive && lNode.child != null) {\n      lNode.updateBounds();\n    }\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n  if (left == Integer.MAX_VALUE) {\n    this.left = this.parent.getLeft();\n    this.right = this.parent.getRight();\n    this.top = this.parent.getTop();\n    this.bottom = this.parent.getBottom();\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = boundingRect.x - margin;\n  this.right = boundingRect.x + boundingRect.width + margin;\n  this.top = boundingRect.y - margin;\n  this.bottom = boundingRect.y + boundingRect.height + margin;\n};\n\nLGraph.calculateBounds = function (nodes) {\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n\n  return boundingRect;\n};\n\nLGraph.prototype.getInclusionTreeDepth = function () {\n  if (this == this.graphManager.getRoot()) {\n    return 1;\n  } else {\n    return this.parent.getInclusionTreeDepth();\n  }\n};\n\nLGraph.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLGraph.prototype.calcEstimatedSize = function () {\n  var size = 0;\n  var nodes = this.nodes;\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    size += lNode.calcEstimatedSize();\n  }\n\n  if (size == 0) {\n    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n  } else {\n    this.estimatedSize = size / Math.sqrt(this.nodes.length);\n  }\n\n  return this.estimatedSize;\n};\n\nLGraph.prototype.updateConnected = function () {\n  var self = this;\n  if (this.nodes.length == 0) {\n    this.isConnected = true;\n    return;\n  }\n\n  var queue = new LinkedList();\n  var visited = new Set();\n  var currentNode = this.nodes[0];\n  var neighborEdges;\n  var currentNeighbor;\n  var childrenOfNode = currentNode.withChildren();\n  childrenOfNode.forEach(function (node) {\n    queue.push(node);\n    visited.add(node);\n  });\n\n  while (queue.length !== 0) {\n    currentNode = queue.shift();\n\n    // Traverse all neighbors of this node\n    neighborEdges = currentNode.getEdges();\n    var size = neighborEdges.length;\n    for (var i = 0; i < size; i++) {\n      var neighborEdge = neighborEdges[i];\n      currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\n\n      // Add unvisited neighbors to the list to visit\n      if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n        var childrenOfNeighbor = currentNeighbor.withChildren();\n\n        childrenOfNeighbor.forEach(function (node) {\n          queue.push(node);\n          visited.add(node);\n        });\n      }\n    }\n  }\n\n  this.isConnected = false;\n\n  if (visited.size >= this.nodes.length) {\n    var noOfVisitedInThisGraph = 0;\n\n    visited.forEach(function (visitedNode) {\n      if (visitedNode.owner == self) {\n        noOfVisitedInThisGraph++;\n      }\n    });\n\n    if (noOfVisitedInThisGraph == this.nodes.length) {\n      this.isConnected = true;\n    }\n  }\n};\n\nmodule.exports = LGraph;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraph;\nvar LEdge = __webpack_require__(1);\n\nfunction LGraphManager(layout) {\n  LGraph = __webpack_require__(5); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\n  this.layout = layout;\n\n  this.graphs = [];\n  this.edges = [];\n}\n\nLGraphManager.prototype.addRoot = function () {\n  var ngraph = this.layout.newGraph();\n  var nnode = this.layout.newNode(null);\n  var root = this.add(ngraph, nnode);\n  this.setRootGraph(root);\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {\n  //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n  if (newEdge == null && sourceNode == null && targetNode == null) {\n    if (newGraph == null) {\n      throw \"Graph is null!\";\n    }\n    if (parentNode == null) {\n      throw \"Parent node is null!\";\n    }\n    if (this.graphs.indexOf(newGraph) > -1) {\n      throw \"Graph already in this graph mgr!\";\n    }\n\n    this.graphs.push(newGraph);\n\n    if (newGraph.parent != null) {\n      throw \"Already has a parent!\";\n    }\n    if (parentNode.child != null) {\n      throw \"Already has a child!\";\n    }\n\n    newGraph.parent = parentNode;\n    parentNode.child = newGraph;\n\n    return newGraph;\n  } else {\n    //change the order of the parameters\n    targetNode = newEdge;\n    sourceNode = parentNode;\n    newEdge = newGraph;\n    var sourceGraph = sourceNode.getOwner();\n    var targetGraph = targetNode.getOwner();\n\n    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n      throw \"Source not in this graph mgr!\";\n    }\n    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n      throw \"Target not in this graph mgr!\";\n    }\n\n    if (sourceGraph == targetGraph) {\n      newEdge.isInterGraph = false;\n      return sourceGraph.add(newEdge, sourceNode, targetNode);\n    } else {\n      newEdge.isInterGraph = true;\n\n      // set source and target\n      newEdge.source = sourceNode;\n      newEdge.target = targetNode;\n\n      // add edge to inter-graph edge list\n      if (this.edges.indexOf(newEdge) > -1) {\n        throw \"Edge already in inter-graph edge list!\";\n      }\n\n      this.edges.push(newEdge);\n\n      // add edge to source and target incidency lists\n      if (!(newEdge.source != null && newEdge.target != null)) {\n        throw \"Edge source and/or target is null!\";\n      }\n\n      if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n        throw \"Edge already in source and/or target incidency list!\";\n      }\n\n      newEdge.source.edges.push(newEdge);\n      newEdge.target.edges.push(newEdge);\n\n      return newEdge;\n    }\n  }\n};\n\nLGraphManager.prototype.remove = function (lObj) {\n  if (lObj instanceof LGraph) {\n    var graph = lObj;\n    if (graph.getGraphManager() != this) {\n      throw \"Graph not in this graph mgr\";\n    }\n    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n      throw \"Invalid parent node!\";\n    }\n\n    // first the edges (make a copy to do it safely)\n    var edgesToBeRemoved = [];\n\n    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n      graph.remove(edge);\n    }\n\n    // then the nodes (make a copy to do it safely)\n    var nodesToBeRemoved = [];\n\n    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n\n    var node;\n    s = nodesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      node = nodesToBeRemoved[i];\n      graph.remove(node);\n    }\n\n    // check if graph is the root\n    if (graph == this.rootGraph) {\n      this.setRootGraph(null);\n    }\n\n    // now remove the graph itself\n    var index = this.graphs.indexOf(graph);\n    this.graphs.splice(index, 1);\n\n    // also reset the parent of the graph\n    graph.parent = null;\n  } else if (lObj instanceof LEdge) {\n    edge = lObj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!edge.isInterGraph) {\n      throw \"Not an inter-graph edge!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n\n    // remove edge from source and target nodes' incidency lists\n\n    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    var index = edge.source.edges.indexOf(edge);\n    edge.source.edges.splice(index, 1);\n    index = edge.target.edges.indexOf(edge);\n    edge.target.edges.splice(index, 1);\n\n    // remove edge from owner graph manager's inter-graph edge list\n\n    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n      throw \"Edge owner graph or owner graph manager is null!\";\n    }\n    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n      throw \"Not in owner graph manager's edge list!\";\n    }\n\n    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n    edge.source.owner.getGraphManager().edges.splice(index, 1);\n  }\n};\n\nLGraphManager.prototype.updateBounds = function () {\n  this.rootGraph.updateBounds(true);\n};\n\nLGraphManager.prototype.getGraphs = function () {\n  return this.graphs;\n};\n\nLGraphManager.prototype.getAllNodes = function () {\n  if (this.allNodes == null) {\n    var nodeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < s; i++) {\n      nodeList = nodeList.concat(graphs[i].getNodes());\n    }\n    this.allNodes = nodeList;\n  }\n  return this.allNodes;\n};\n\nLGraphManager.prototype.resetAllNodes = function () {\n  this.allNodes = null;\n};\n\nLGraphManager.prototype.resetAllEdges = function () {\n  this.allEdges = null;\n};\n\nLGraphManager.prototype.resetAllNodesToApplyGravitation = function () {\n  this.allNodesToApplyGravitation = null;\n};\n\nLGraphManager.prototype.getAllEdges = function () {\n  if (this.allEdges == null) {\n    var edgeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < graphs.length; i++) {\n      edgeList = edgeList.concat(graphs[i].getEdges());\n    }\n\n    edgeList = edgeList.concat(this.edges);\n\n    this.allEdges = edgeList;\n  }\n  return this.allEdges;\n};\n\nLGraphManager.prototype.getAllNodesToApplyGravitation = function () {\n  return this.allNodesToApplyGravitation;\n};\n\nLGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {\n  if (this.allNodesToApplyGravitation != null) {\n    throw \"assert failed\";\n  }\n\n  this.allNodesToApplyGravitation = nodeList;\n};\n\nLGraphManager.prototype.getRoot = function () {\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.setRootGraph = function (graph) {\n  if (graph.getGraphManager() != this) {\n    throw \"Root not in this graph mgr!\";\n  }\n\n  this.rootGraph = graph;\n  // root graph must have a root node associated with it for convenience\n  if (graph.parent == null) {\n    graph.parent = this.layout.newNode(\"Root node\");\n  }\n};\n\nLGraphManager.prototype.getLayout = function () {\n  return this.layout;\n};\n\nLGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {\n  if (!(firstNode != null && secondNode != null)) {\n    throw \"assert failed\";\n  }\n\n  if (firstNode == secondNode) {\n    return true;\n  }\n  // Is second node an ancestor of the first one?\n  var ownerGraph = firstNode.getOwner();\n  var parentNode;\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == secondNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n  // Is first node an ancestor of the second one?\n  ownerGraph = secondNode.getOwner();\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == firstNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n\n  return false;\n};\n\nLGraphManager.prototype.calcLowestCommonAncestors = function () {\n  var edge;\n  var sourceNode;\n  var targetNode;\n  var sourceAncestorGraph;\n  var targetAncestorGraph;\n\n  var edges = this.getAllEdges();\n  var s = edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = edges[i];\n\n    sourceNode = edge.source;\n    targetNode = edge.target;\n    edge.lca = null;\n    edge.sourceInLca = sourceNode;\n    edge.targetInLca = targetNode;\n\n    if (sourceNode == targetNode) {\n      edge.lca = sourceNode.getOwner();\n      continue;\n    }\n\n    sourceAncestorGraph = sourceNode.getOwner();\n\n    while (edge.lca == null) {\n      edge.targetInLca = targetNode;\n      targetAncestorGraph = targetNode.getOwner();\n\n      while (edge.lca == null) {\n        if (targetAncestorGraph == sourceAncestorGraph) {\n          edge.lca = targetAncestorGraph;\n          break;\n        }\n\n        if (targetAncestorGraph == this.rootGraph) {\n          break;\n        }\n\n        if (edge.lca != null) {\n          throw \"assert failed\";\n        }\n        edge.targetInLca = targetAncestorGraph.getParent();\n        targetAncestorGraph = edge.targetInLca.getOwner();\n      }\n\n      if (sourceAncestorGraph == this.rootGraph) {\n        break;\n      }\n\n      if (edge.lca == null) {\n        edge.sourceInLca = sourceAncestorGraph.getParent();\n        sourceAncestorGraph = edge.sourceInLca.getOwner();\n      }\n    }\n\n    if (edge.lca == null) {\n      throw \"assert failed\";\n    }\n  }\n};\n\nLGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {\n  if (firstNode == secondNode) {\n    return firstNode.getOwner();\n  }\n  var firstOwnerGraph = firstNode.getOwner();\n\n  do {\n    if (firstOwnerGraph == null) {\n      break;\n    }\n    var secondOwnerGraph = secondNode.getOwner();\n\n    do {\n      if (secondOwnerGraph == null) {\n        break;\n      }\n\n      if (secondOwnerGraph == firstOwnerGraph) {\n        return secondOwnerGraph;\n      }\n      secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n    } while (true);\n\n    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n  } while (true);\n\n  return firstOwnerGraph;\n};\n\nLGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {\n  if (graph == null && depth == null) {\n    graph = this.rootGraph;\n    depth = 1;\n  }\n  var node;\n\n  var nodes = graph.getNodes();\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    node = nodes[i];\n    node.inclusionTreeDepth = depth;\n\n    if (node.child != null) {\n      this.calcInclusionTreeDepths(node.child, depth + 1);\n    }\n  }\n};\n\nLGraphManager.prototype.includesInvalidEdge = function () {\n  var edge;\n\n  var s = this.edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = this.edges[i];\n\n    if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nmodule.exports = LGraphManager;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LayoutConstants = __webpack_require__(0);\n\nfunction FDLayoutConstants() {}\n\n//FDLayoutConstants inherits static props in LayoutConstants\nfor (var prop in LayoutConstants) {\n  FDLayoutConstants[prop] = LayoutConstants[prop];\n}\n\nFDLayoutConstants.MAX_ITERATIONS = 2500;\n\nFDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\nFDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\nFDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\nFDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\nFDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\nFDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\nFDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\nFDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\nFDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\nFDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\nFDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\nFDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\nFDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\nFDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\nFDLayoutConstants.MIN_EDGE_LENGTH = 1;\nFDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n\nmodule.exports = FDLayoutConstants;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class maintains a list of static geometry related utility methods.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar Point = __webpack_require__(12);\n\nfunction IGeometry() {}\n\n/**\n * This method calculates *half* the amount in x and y directions of the two\n * input rectangles needed to separate them keeping their respective\n * positioning, and returns the result in the input array. An input\n * separation buffer added to the amount in both directions. We assume that\n * the two rectangles do intersect.\n */\nIGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {\n  if (!rectA.intersects(rectB)) {\n    throw \"assert failed\";\n  }\n\n  var directions = new Array(2);\n\n  this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n\n  overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n  overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\n\n  // update the overlapping amounts for the following cases:\n  if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n    /* Case x.1:\n    *\n    * rectA\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectB\n    */\n    overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n  } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n    /* Case x.2:\n    *\n    * rectB\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectA\n    */\n    overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n  }\n  if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n    /* Case y.1:\n     *          ________ rectA\n     *         |\n     *         |\n     *   ______|____  rectB\n     *         |    |\n     *         |    |\n     *   ______|____|\n     *         |\n     *         |\n     *         |________\n     *\n     */\n    overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n  } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n    /* Case y.2:\n    *          ________ rectB\n    *         |\n    *         |\n    *   ______|____  rectA\n    *         |    |\n    *         |    |\n    *   ______|____|\n    *         |\n    *         |\n    *         |________\n    *\n    */\n    overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n  }\n\n  // find slope of the line passes two centers\n  var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\n  // if centers are overlapped\n  if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n    // assume the slope is 1 (45 degree)\n    slope = 1.0;\n  }\n\n  var moveByY = slope * overlapAmount[0];\n  var moveByX = overlapAmount[1] / slope;\n  if (overlapAmount[0] < moveByX) {\n    moveByX = overlapAmount[0];\n  } else {\n    moveByY = overlapAmount[1];\n  }\n  // return half the amount so that if each rectangle is moved by these\n  // amounts in opposite directions, overlap will be resolved\n  overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n  overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n};\n\n/**\n * This method decides the separation direction of overlapping nodes\n *\n * if directions[0] = -1, then rectA goes left\n * if directions[0] = 1,  then rectA goes right\n * if directions[1] = -1, then rectA goes up\n * if directions[1] = 1,  then rectA goes down\n */\nIGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {\n  if (rectA.getCenterX() < rectB.getCenterX()) {\n    directions[0] = -1;\n  } else {\n    directions[0] = 1;\n  }\n\n  if (rectA.getCenterY() < rectB.getCenterY()) {\n    directions[1] = -1;\n  } else {\n    directions[1] = 1;\n  }\n};\n\n/**\n * This method calculates the intersection (clipping) points of the two\n * input rectangles with line segment defined by the centers of these two\n * rectangles. The clipping points are saved in the input double array and\n * whether or not the two rectangles overlap is returned.\n */\nIGeometry.getIntersection2 = function (rectA, rectB, result) {\n  //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n  var p1x = rectA.getCenterX();\n  var p1y = rectA.getCenterY();\n  var p2x = rectB.getCenterX();\n  var p2y = rectB.getCenterY();\n\n  //if two rectangles intersect, then clipping points are centers\n  if (rectA.intersects(rectB)) {\n    result[0] = p1x;\n    result[1] = p1y;\n    result[2] = p2x;\n    result[3] = p2y;\n    return true;\n  }\n  //variables for rectA\n  var topLeftAx = rectA.getX();\n  var topLeftAy = rectA.getY();\n  var topRightAx = rectA.getRight();\n  var bottomLeftAx = rectA.getX();\n  var bottomLeftAy = rectA.getBottom();\n  var bottomRightAx = rectA.getRight();\n  var halfWidthA = rectA.getWidthHalf();\n  var halfHeightA = rectA.getHeightHalf();\n  //variables for rectB\n  var topLeftBx = rectB.getX();\n  var topLeftBy = rectB.getY();\n  var topRightBx = rectB.getRight();\n  var bottomLeftBx = rectB.getX();\n  var bottomLeftBy = rectB.getBottom();\n  var bottomRightBx = rectB.getRight();\n  var halfWidthB = rectB.getWidthHalf();\n  var halfHeightB = rectB.getHeightHalf();\n\n  //flag whether clipping points are found\n  var clipPointAFound = false;\n  var clipPointBFound = false;\n\n  // line is vertical\n  if (p1x === p2x) {\n    if (p1y > p2y) {\n      result[0] = p1x;\n      result[1] = topLeftAy;\n      result[2] = p2x;\n      result[3] = bottomLeftBy;\n      return false;\n    } else if (p1y < p2y) {\n      result[0] = p1x;\n      result[1] = bottomLeftAy;\n      result[2] = p2x;\n      result[3] = topLeftBy;\n      return false;\n    } else {\n      //not line, return null;\n    }\n  }\n  // line is horizontal\n  else if (p1y === p2y) {\n      if (p1x > p2x) {\n        result[0] = topLeftAx;\n        result[1] = p1y;\n        result[2] = topRightBx;\n        result[3] = p2y;\n        return false;\n      } else if (p1x < p2x) {\n        result[0] = topRightAx;\n        result[1] = p1y;\n        result[2] = topLeftBx;\n        result[3] = p2y;\n        return false;\n      } else {\n        //not valid line, return null;\n      }\n    } else {\n      //slopes of rectA's and rectB's diagonals\n      var slopeA = rectA.height / rectA.width;\n      var slopeB = rectB.height / rectB.width;\n\n      //slope of line between center of rectA and center of rectB\n      var slopePrime = (p2y - p1y) / (p2x - p1x);\n      var cardinalDirectionA = void 0;\n      var cardinalDirectionB = void 0;\n      var tempPointAx = void 0;\n      var tempPointAy = void 0;\n      var tempPointBx = void 0;\n      var tempPointBy = void 0;\n\n      //determine whether clipping point is the corner of nodeA\n      if (-slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = bottomLeftAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = topRightAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        }\n      } else if (slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = topLeftAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = bottomRightAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        }\n      }\n\n      //determine whether clipping point is the corner of nodeB\n      if (-slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = bottomLeftBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = topRightBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        }\n      } else if (slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = topLeftBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = bottomRightBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        }\n      }\n\n      //if both clipping points are corners\n      if (clipPointAFound && clipPointBFound) {\n        return false;\n      }\n\n      //determine Cardinal Direction of rectangles\n      if (p1x > p2x) {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n        }\n      } else {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n        }\n      }\n      //calculate clipping Point if it is not found before\n      if (!clipPointAFound) {\n        switch (cardinalDirectionA) {\n          case 1:\n            tempPointAy = topLeftAy;\n            tempPointAx = p1x + -halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 2:\n            tempPointAx = bottomRightAx;\n            tempPointAy = p1y + halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 3:\n            tempPointAy = bottomLeftAy;\n            tempPointAx = p1x + halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 4:\n            tempPointAx = bottomLeftAx;\n            tempPointAy = p1y + -halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n        }\n      }\n      if (!clipPointBFound) {\n        switch (cardinalDirectionB) {\n          case 1:\n            tempPointBy = topLeftBy;\n            tempPointBx = p2x + -halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 2:\n            tempPointBx = bottomRightBx;\n            tempPointBy = p2y + halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 3:\n            tempPointBy = bottomLeftBy;\n            tempPointBx = p2x + halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 4:\n            tempPointBx = bottomLeftBx;\n            tempPointBy = p2y + -halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n        }\n      }\n    }\n  return false;\n};\n\n/**\n * This method returns in which cardinal direction does input point stays\n * 1: North\n * 2: East\n * 3: South\n * 4: West\n */\nIGeometry.getCardinalDirection = function (slope, slopePrime, line) {\n  if (slope > slopePrime) {\n    return line;\n  } else {\n    return 1 + line % 4;\n  }\n};\n\n/**\n * This method calculates the intersection of the two lines defined by\n * point pairs (s1,s2) and (f1,f2).\n */\nIGeometry.getIntersection = function (s1, s2, f1, f2) {\n  if (f2 == null) {\n    return this.getIntersection2(s1, s2, f1);\n  }\n\n  var x1 = s1.x;\n  var y1 = s1.y;\n  var x2 = s2.x;\n  var y2 = s2.y;\n  var x3 = f1.x;\n  var y3 = f1.y;\n  var x4 = f2.x;\n  var y4 = f2.y;\n  var x = void 0,\n      y = void 0; // intersection point\n  var a1 = void 0,\n      a2 = void 0,\n      b1 = void 0,\n      b2 = void 0,\n      c1 = void 0,\n      c2 = void 0; // coefficients of line eqns.\n  var denom = void 0;\n\n  a1 = y2 - y1;\n  b1 = x1 - x2;\n  c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n\n  a2 = y4 - y3;\n  b2 = x3 - x4;\n  c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n\n  denom = a1 * b2 - a2 * b1;\n\n  if (denom === 0) {\n    return null;\n  }\n\n  x = (b1 * c2 - b2 * c1) / denom;\n  y = (a2 * c1 - a1 * c2) / denom;\n\n  return new Point(x, y);\n};\n\n/**\n * This method finds and returns the angle of the vector from the + x-axis\n * in clockwise direction (compatible w/ Java coordinate system!).\n */\nIGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {\n  var C_angle = void 0;\n\n  if (Cx !== Nx) {\n    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n\n    if (Nx < Cx) {\n      C_angle += Math.PI;\n    } else if (Ny < Cy) {\n      C_angle += this.TWO_PI;\n    }\n  } else if (Ny < Cy) {\n    C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n  } else {\n    C_angle = this.HALF_PI; // 90 degrees\n  }\n\n  return C_angle;\n};\n\n/**\n * This method checks whether the given two line segments (one with point\n * p1 and p2, the other with point p3 and p4) intersect at a point other\n * than these points.\n */\nIGeometry.doIntersect = function (p1, p2, p3, p4) {\n  var a = p1.x;\n  var b = p1.y;\n  var c = p2.x;\n  var d = p2.y;\n  var p = p3.x;\n  var q = p3.y;\n  var r = p4.x;\n  var s = p4.y;\n  var det = (c - a) * (s - q) - (r - p) * (d - b);\n\n  if (det === 0) {\n    return false;\n  } else {\n    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Class Constants\n// -----------------------------------------------------------------------------\n/**\n * Some useful pre-calculated constants\n */\nIGeometry.HALF_PI = 0.5 * Math.PI;\nIGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\nIGeometry.TWO_PI = 2.0 * Math.PI;\nIGeometry.THREE_PI = 3.0 * Math.PI;\n\nmodule.exports = IGeometry;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction IMath() {}\n\n/**\n * This method returns the sign of the input value.\n */\nIMath.sign = function (value) {\n  if (value > 0) {\n    return 1;\n  } else if (value < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n\nIMath.floor = function (value) {\n  return value < 0 ? Math.ceil(value) : Math.floor(value);\n};\n\nIMath.ceil = function (value) {\n  return value < 0 ? Math.floor(value) : Math.ceil(value);\n};\n\nmodule.exports = IMath;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Integer() {}\n\nInteger.MAX_VALUE = 2147483647;\nInteger.MIN_VALUE = -2147483648;\n\nmodule.exports = Integer;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar nodeFrom = function nodeFrom(value) {\n  return { value: value, next: null, prev: null };\n};\n\nvar add = function add(prev, node, next, list) {\n  if (prev !== null) {\n    prev.next = node;\n  } else {\n    list.head = node;\n  }\n\n  if (next !== null) {\n    next.prev = node;\n  } else {\n    list.tail = node;\n  }\n\n  node.prev = prev;\n  node.next = next;\n\n  list.length++;\n\n  return node;\n};\n\nvar _remove = function _remove(node, list) {\n  var prev = node.prev,\n      next = node.next;\n\n\n  if (prev !== null) {\n    prev.next = next;\n  } else {\n    list.head = next;\n  }\n\n  if (next !== null) {\n    next.prev = prev;\n  } else {\n    list.tail = prev;\n  }\n\n  node.prev = node.next = null;\n\n  list.length--;\n\n  return node;\n};\n\nvar LinkedList = function () {\n  function LinkedList(vals) {\n    var _this = this;\n\n    _classCallCheck(this, LinkedList);\n\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n\n    if (vals != null) {\n      vals.forEach(function (v) {\n        return _this.push(v);\n      });\n    }\n  }\n\n  _createClass(LinkedList, [{\n    key: \"size\",\n    value: function size() {\n      return this.length;\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(val, otherNode) {\n      return add(otherNode.prev, nodeFrom(val), otherNode, this);\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(val, otherNode) {\n      return add(otherNode, nodeFrom(val), otherNode.next, this);\n    }\n  }, {\n    key: \"insertNodeBefore\",\n    value: function insertNodeBefore(newNode, otherNode) {\n      return add(otherNode.prev, newNode, otherNode, this);\n    }\n  }, {\n    key: \"insertNodeAfter\",\n    value: function insertNodeAfter(newNode, otherNode) {\n      return add(otherNode, newNode, otherNode.next, this);\n    }\n  }, {\n    key: \"push\",\n    value: function push(val) {\n      return add(this.tail, nodeFrom(val), null, this);\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(val) {\n      return add(null, nodeFrom(val), this.head, this);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      return _remove(node, this);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return _remove(this.tail, this).value;\n    }\n  }, {\n    key: \"popNode\",\n    value: function popNode() {\n      return _remove(this.tail, this);\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      return _remove(this.head, this).value;\n    }\n  }, {\n    key: \"shiftNode\",\n    value: function shiftNode() {\n      return _remove(this.head, this);\n    }\n  }, {\n    key: \"get_object_at\",\n    value: function get_object_at(index) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        return current.value;\n      }\n    }\n  }, {\n    key: \"set_object_at\",\n    value: function set_object_at(index, value) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        current.value = value;\n      }\n    }\n  }]);\n\n  return LinkedList;\n}();\n\nmodule.exports = LinkedList;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\r\n *This class is the javascript implementation of the Point.java class in jdk\r\n */\nfunction Point(x, y, p) {\n  this.x = null;\n  this.y = null;\n  if (x == null && y == null && p == null) {\n    this.x = 0;\n    this.y = 0;\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    this.x = x;\n    this.y = y;\n  } else if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.x = p.x;\n    this.y = p.y;\n  }\n}\n\nPoint.prototype.getX = function () {\n  return this.x;\n};\n\nPoint.prototype.getY = function () {\n  return this.y;\n};\n\nPoint.prototype.getLocation = function () {\n  return new Point(this.x, this.y);\n};\n\nPoint.prototype.setLocation = function (x, y, p) {\n  if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.setLocation(p.x, p.y);\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    //if both parameters are integer just move (x,y) location\n    if (parseInt(x) == x && parseInt(y) == y) {\n      this.move(x, y);\n    } else {\n      this.x = Math.floor(x + 0.5);\n      this.y = Math.floor(y + 0.5);\n    }\n  }\n};\n\nPoint.prototype.move = function (x, y) {\n  this.x = x;\n  this.y = y;\n};\n\nPoint.prototype.translate = function (dx, dy) {\n  this.x += dx;\n  this.y += dy;\n};\n\nPoint.prototype.equals = function (obj) {\n  if (obj.constructor.name == \"Point\") {\n    var pt = obj;\n    return this.x == pt.x && this.y == pt.y;\n  }\n  return this == obj;\n};\n\nPoint.prototype.toString = function () {\n  return new Point().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n};\n\nmodule.exports = Point;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RectangleD(x, y, width, height) {\n  this.x = 0;\n  this.y = 0;\n  this.width = 0;\n  this.height = 0;\n\n  if (x != null && y != null && width != null && height != null) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n}\n\nRectangleD.prototype.getX = function () {\n  return this.x;\n};\n\nRectangleD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nRectangleD.prototype.getY = function () {\n  return this.y;\n};\n\nRectangleD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nRectangleD.prototype.getWidth = function () {\n  return this.width;\n};\n\nRectangleD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nRectangleD.prototype.getHeight = function () {\n  return this.height;\n};\n\nRectangleD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nRectangleD.prototype.getRight = function () {\n  return this.x + this.width;\n};\n\nRectangleD.prototype.getBottom = function () {\n  return this.y + this.height;\n};\n\nRectangleD.prototype.intersects = function (a) {\n  if (this.getRight() < a.x) {\n    return false;\n  }\n\n  if (this.getBottom() < a.y) {\n    return false;\n  }\n\n  if (a.getRight() < this.x) {\n    return false;\n  }\n\n  if (a.getBottom() < this.y) {\n    return false;\n  }\n\n  return true;\n};\n\nRectangleD.prototype.getCenterX = function () {\n  return this.x + this.width / 2;\n};\n\nRectangleD.prototype.getMinX = function () {\n  return this.getX();\n};\n\nRectangleD.prototype.getMaxX = function () {\n  return this.getX() + this.width;\n};\n\nRectangleD.prototype.getCenterY = function () {\n  return this.y + this.height / 2;\n};\n\nRectangleD.prototype.getMinY = function () {\n  return this.getY();\n};\n\nRectangleD.prototype.getMaxY = function () {\n  return this.getY() + this.height;\n};\n\nRectangleD.prototype.getWidthHalf = function () {\n  return this.width / 2;\n};\n\nRectangleD.prototype.getHeightHalf = function () {\n  return this.height / 2;\n};\n\nmodule.exports = RectangleD;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction UniqueIDGeneretor() {}\n\nUniqueIDGeneretor.lastID = 0;\n\nUniqueIDGeneretor.createID = function (obj) {\n  if (UniqueIDGeneretor.isPrimitive(obj)) {\n    return obj;\n  }\n  if (obj.uniqueID != null) {\n    return obj.uniqueID;\n  }\n  obj.uniqueID = UniqueIDGeneretor.getString();\n  UniqueIDGeneretor.lastID++;\n  return obj.uniqueID;\n};\n\nUniqueIDGeneretor.getString = function (id) {\n  if (id == null) id = UniqueIDGeneretor.lastID;\n  return \"Object#\" + id + \"\";\n};\n\nUniqueIDGeneretor.isPrimitive = function (arg) {\n  var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n  return arg == null || type != \"object\" && type != \"function\";\n};\n\nmodule.exports = UniqueIDGeneretor;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar LayoutConstants = __webpack_require__(0);\nvar LGraphManager = __webpack_require__(6);\nvar LNode = __webpack_require__(3);\nvar LEdge = __webpack_require__(1);\nvar LGraph = __webpack_require__(5);\nvar PointD = __webpack_require__(4);\nvar Transform = __webpack_require__(17);\nvar Emitter = __webpack_require__(27);\n\nfunction Layout(isRemoteUse) {\n  Emitter.call(this);\n\n  //Layout Quality: 0:draft, 1:default, 2:proof\n  this.layoutQuality = LayoutConstants.QUALITY;\n  //Whether layout should create bendpoints as needed or not\n  this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  //Whether layout should be incremental or not\n  this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n  //Whether we animate from before to after layout node positions\n  this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n  //Whether we animate the layout process or not\n  this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n  //Number iterations that should be done between two successive animations\n  this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n  /**\r\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n   * they are, both spring and repulsion forces between two leaf nodes can be\r\n   * calculated without the expensive clipping point calculations, resulting\r\n   * in major speed-up.\r\n   */\n  this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  /**\r\n   * This is used for creation of bendpoints by using dummy nodes and edges.\r\n   * Maps an LEdge to its dummy bendpoint path.\r\n   */\n  this.edgeToDummyNodes = new Map();\n  this.graphManager = new LGraphManager(this);\n  this.isLayoutFinished = false;\n  this.isSubLayout = false;\n  this.isRemoteUse = false;\n\n  if (isRemoteUse != null) {\n    this.isRemoteUse = isRemoteUse;\n  }\n}\n\nLayout.RANDOM_SEED = 1;\n\nLayout.prototype = Object.create(Emitter.prototype);\n\nLayout.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLayout.prototype.getAllNodes = function () {\n  return this.graphManager.getAllNodes();\n};\n\nLayout.prototype.getAllEdges = function () {\n  return this.graphManager.getAllEdges();\n};\n\nLayout.prototype.getAllNodesToApplyGravitation = function () {\n  return this.graphManager.getAllNodesToApplyGravitation();\n};\n\nLayout.prototype.newGraphManager = function () {\n  var gm = new LGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nLayout.prototype.newGraph = function (vGraph) {\n  return new LGraph(null, this.graphManager, vGraph);\n};\n\nLayout.prototype.newNode = function (vNode) {\n  return new LNode(this.graphManager, vNode);\n};\n\nLayout.prototype.newEdge = function (vEdge) {\n  return new LEdge(null, null, vEdge);\n};\n\nLayout.prototype.checkLayoutSuccess = function () {\n  return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n};\n\nLayout.prototype.runLayout = function () {\n  this.isLayoutFinished = false;\n\n  if (this.tilingPreLayout) {\n    this.tilingPreLayout();\n  }\n\n  this.initParameters();\n  var isLayoutSuccessfull;\n\n  if (this.checkLayoutSuccess()) {\n    isLayoutSuccessfull = false;\n  } else {\n    isLayoutSuccessfull = this.layout();\n  }\n\n  if (LayoutConstants.ANIMATE === 'during') {\n    // If this is a 'during' layout animation. Layout is not finished yet. \n    // We need to perform these in index.js when layout is really finished.\n    return false;\n  }\n\n  if (isLayoutSuccessfull) {\n    if (!this.isSubLayout) {\n      this.doPostLayout();\n    }\n  }\n\n  if (this.tilingPostLayout) {\n    this.tilingPostLayout();\n  }\n\n  this.isLayoutFinished = true;\n\n  return isLayoutSuccessfull;\n};\n\n/**\r\n * This method performs the operations required after layout.\r\n */\nLayout.prototype.doPostLayout = function () {\n  //assert !isSubLayout : \"Should not be called on sub-layout!\";\n  // Propagate geometric changes to v-level objects\n  if (!this.incremental) {\n    this.transform();\n  }\n  this.update();\n};\n\n/**\r\n * This method updates the geometry of the target graph according to\r\n * calculated layout.\r\n */\nLayout.prototype.update2 = function () {\n  // update bend points\n  if (this.createBendsAsNeeded) {\n    this.createBendpointsFromDummyNodes();\n\n    // reset all edges, since the topology has changed\n    this.graphManager.resetAllEdges();\n  }\n\n  // perform edge, node and root updates if layout is not called\n  // remotely\n  if (!this.isRemoteUse) {\n    // update all edges\n    var edge;\n    var allEdges = this.graphManager.getAllEdges();\n    for (var i = 0; i < allEdges.length; i++) {\n      edge = allEdges[i];\n      //      this.update(edge);\n    }\n\n    // recursively update nodes\n    var node;\n    var nodes = this.graphManager.getRoot().getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      //      this.update(node);\n    }\n\n    // update root graph\n    this.update(this.graphManager.getRoot());\n  }\n};\n\nLayout.prototype.update = function (obj) {\n  if (obj == null) {\n    this.update2();\n  } else if (obj instanceof LNode) {\n    var node = obj;\n    if (node.getChild() != null) {\n      // since node is compound, recursively update child nodes\n      var nodes = node.getChild().getNodes();\n      for (var i = 0; i < nodes.length; i++) {\n        update(nodes[i]);\n      }\n    }\n\n    // if the l-level node is associated with a v-level graph object,\n    // then it is assumed that the v-level node implements the\n    // interface Updatable.\n    if (node.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vNode = node.vGraphObject;\n\n      // call the update method of the interface\n      vNode.update(node);\n    }\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    // if the l-level edge is associated with a v-level graph object,\n    // then it is assumed that the v-level edge implements the\n    // interface Updatable.\n\n    if (edge.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vEdge = edge.vGraphObject;\n\n      // call the update method of the interface\n      vEdge.update(edge);\n    }\n  } else if (obj instanceof LGraph) {\n    var graph = obj;\n    // if the l-level graph is associated with a v-level graph object,\n    // then it is assumed that the v-level object implements the\n    // interface Updatable.\n\n    if (graph.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vGraph = graph.vGraphObject;\n\n      // call the update method of the interface\n      vGraph.update(graph);\n    }\n  }\n};\n\n/**\r\n * This method is used to set all layout parameters to default values\r\n * determined at compile time.\r\n */\nLayout.prototype.initParameters = function () {\n  if (!this.isSubLayout) {\n    this.layoutQuality = LayoutConstants.QUALITY;\n    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  }\n\n  if (this.animationDuringLayout) {\n    this.animationOnLayout = false;\n  }\n};\n\nLayout.prototype.transform = function (newLeftTop) {\n  if (newLeftTop == undefined) {\n    this.transform(new PointD(0, 0));\n  } else {\n    // create a transformation object (from Eclipse to layout). When an\n    // inverse transform is applied, we get upper-left coordinate of the\n    // drawing or the root graph at given input coordinate (some margins\n    // already included in calculation of left-top).\n\n    var trans = new Transform();\n    var leftTop = this.graphManager.getRoot().updateLeftTop();\n\n    if (leftTop != null) {\n      trans.setWorldOrgX(newLeftTop.x);\n      trans.setWorldOrgY(newLeftTop.y);\n\n      trans.setDeviceOrgX(leftTop.x);\n      trans.setDeviceOrgY(leftTop.y);\n\n      var nodes = this.getAllNodes();\n      var node;\n\n      for (var i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        node.transform(trans);\n      }\n    }\n  }\n};\n\nLayout.prototype.positionNodesRandomly = function (graph) {\n\n  if (graph == undefined) {\n    //assert !this.incremental;\n    this.positionNodesRandomly(this.getGraphManager().getRoot());\n    this.getGraphManager().getRoot().updateBounds(true);\n  } else {\n    var lNode;\n    var childGraph;\n\n    var nodes = graph.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      lNode = nodes[i];\n      childGraph = lNode.getChild();\n\n      if (childGraph == null) {\n        lNode.scatter();\n      } else if (childGraph.getNodes().length == 0) {\n        lNode.scatter();\n      } else {\n        this.positionNodesRandomly(childGraph);\n        lNode.updateBounds();\n      }\n    }\n  }\n};\n\n/**\r\n * This method returns a list of trees where each tree is represented as a\r\n * list of l-nodes. The method returns a list of size 0 when:\r\n * - The graph is not flat or\r\n * - One of the component(s) of the graph is not a tree.\r\n */\nLayout.prototype.getFlatForest = function () {\n  var flatForest = [];\n  var isForest = true;\n\n  // Quick reference for all nodes in the graph manager associated with\n  // this layout. The list should not be changed.\n  var allNodes = this.graphManager.getRoot().getNodes();\n\n  // First be sure that the graph is flat\n  var isFlat = true;\n\n  for (var i = 0; i < allNodes.length; i++) {\n    if (allNodes[i].getChild() != null) {\n      isFlat = false;\n    }\n  }\n\n  // Return empty forest if the graph is not flat.\n  if (!isFlat) {\n    return flatForest;\n  }\n\n  // Run BFS for each component of the graph.\n\n  var visited = new Set();\n  var toBeVisited = [];\n  var parents = new Map();\n  var unProcessedNodes = [];\n\n  unProcessedNodes = unProcessedNodes.concat(allNodes);\n\n  // Each iteration of this loop finds a component of the graph and\n  // decides whether it is a tree or not. If it is a tree, adds it to the\n  // forest and continued with the next component.\n\n  while (unProcessedNodes.length > 0 && isForest) {\n    toBeVisited.push(unProcessedNodes[0]);\n\n    // Start the BFS. Each iteration of this loop visits a node in a\n    // BFS manner.\n    while (toBeVisited.length > 0 && isForest) {\n      //pool operation\n      var currentNode = toBeVisited[0];\n      toBeVisited.splice(0, 1);\n      visited.add(currentNode);\n\n      // Traverse all neighbors of this node\n      var neighborEdges = currentNode.getEdges();\n\n      for (var i = 0; i < neighborEdges.length; i++) {\n        var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\n\n        // If BFS is not growing from this neighbor.\n        if (parents.get(currentNode) != currentNeighbor) {\n          // We haven't previously visited this neighbor.\n          if (!visited.has(currentNeighbor)) {\n            toBeVisited.push(currentNeighbor);\n            parents.set(currentNeighbor, currentNode);\n          }\n          // Since we have previously visited this neighbor and\n          // this neighbor is not parent of currentNode, given\n          // graph contains a component that is not tree, hence\n          // it is not a forest.\n          else {\n              isForest = false;\n              break;\n            }\n        }\n      }\n    }\n\n    // The graph contains a component that is not a tree. Empty\n    // previously found trees. The method will end.\n    if (!isForest) {\n      flatForest = [];\n    }\n    // Save currently visited nodes as a tree in our forest. Reset\n    // visited and parents lists. Continue with the next component of\n    // the graph, if any.\n    else {\n        var temp = [].concat(_toConsumableArray(visited));\n        flatForest.push(temp);\n        //flatForest = flatForest.concat(temp);\n        //unProcessedNodes.removeAll(visited);\n        for (var i = 0; i < temp.length; i++) {\n          var value = temp[i];\n          var index = unProcessedNodes.indexOf(value);\n          if (index > -1) {\n            unProcessedNodes.splice(index, 1);\n          }\n        }\n        visited = new Set();\n        parents = new Map();\n      }\n  }\n\n  return flatForest;\n};\n\n/**\r\n * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n * for the given edge (one per bendpoint). The existing l-level structure\r\n * is updated accordingly.\r\n */\nLayout.prototype.createDummyNodesForBendpoints = function (edge) {\n  var dummyNodes = [];\n  var prev = edge.source;\n\n  var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n\n  for (var i = 0; i < edge.bendpoints.length; i++) {\n    // create new dummy node\n    var dummyNode = this.newNode(null);\n    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n\n    graph.add(dummyNode);\n\n    // create new dummy edge between prev and dummy node\n    var dummyEdge = this.newEdge(null);\n    this.graphManager.add(dummyEdge, prev, dummyNode);\n\n    dummyNodes.add(dummyNode);\n    prev = dummyNode;\n  }\n\n  var dummyEdge = this.newEdge(null);\n  this.graphManager.add(dummyEdge, prev, edge.target);\n\n  this.edgeToDummyNodes.set(edge, dummyNodes);\n\n  // remove real edge from graph manager if it is inter-graph\n  if (edge.isInterGraph()) {\n    this.graphManager.remove(edge);\n  }\n  // else, remove the edge from the current graph\n  else {\n      graph.remove(edge);\n    }\n\n  return dummyNodes;\n};\n\n/**\r\n * This method creates bendpoints for edges from the dummy nodes\r\n * at l-level.\r\n */\nLayout.prototype.createBendpointsFromDummyNodes = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n\n  for (var k = 0; k < edges.length; k++) {\n    var lEdge = edges[k];\n\n    if (lEdge.bendpoints.length > 0) {\n      var path = this.edgeToDummyNodes.get(lEdge);\n\n      for (var i = 0; i < path.length; i++) {\n        var dummyNode = path[i];\n        var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\n\n        // update bendpoint's location according to dummy node\n        var ebp = lEdge.bendpoints.get(i);\n        ebp.x = p.x;\n        ebp.y = p.y;\n\n        // remove the dummy node, dummy edges incident with this\n        // dummy node is also removed (within the remove method)\n        dummyNode.getOwner().remove(dummyNode);\n      }\n\n      // add the real edge to graph\n      this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n    }\n  }\n};\n\nLayout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {\n  if (minDiv != undefined && maxMul != undefined) {\n    var value = defaultValue;\n\n    if (sliderValue <= 50) {\n      var minValue = defaultValue / minDiv;\n      value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n    } else {\n      var maxValue = defaultValue * maxMul;\n      value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n    }\n\n    return value;\n  } else {\n    var a, b;\n\n    if (sliderValue <= 50) {\n      a = 9.0 * defaultValue / 500.0;\n      b = defaultValue / 10.0;\n    } else {\n      a = 9.0 * defaultValue / 50.0;\n      b = -8 * defaultValue;\n    }\n\n    return a * sliderValue + b;\n  }\n};\n\n/**\r\n * This method finds and returns the center of the given nodes, assuming\r\n * that the given nodes form a tree in themselves.\r\n */\nLayout.findCenterOfTree = function (nodes) {\n  var list = [];\n  list = list.concat(nodes);\n\n  var removedNodes = [];\n  var remainingDegrees = new Map();\n  var foundCenter = false;\n  var centerNode = null;\n\n  if (list.length == 1 || list.length == 2) {\n    foundCenter = true;\n    centerNode = list[0];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var node = list[i];\n    var degree = node.getNeighborsList().size;\n    remainingDegrees.set(node, node.getNeighborsList().size);\n\n    if (degree == 1) {\n      removedNodes.push(node);\n    }\n  }\n\n  var tempList = [];\n  tempList = tempList.concat(removedNodes);\n\n  while (!foundCenter) {\n    var tempList2 = [];\n    tempList2 = tempList2.concat(tempList);\n    tempList = [];\n\n    for (var i = 0; i < list.length; i++) {\n      var node = list[i];\n\n      var index = list.indexOf(node);\n      if (index >= 0) {\n        list.splice(index, 1);\n      }\n\n      var neighbours = node.getNeighborsList();\n\n      neighbours.forEach(function (neighbour) {\n        if (removedNodes.indexOf(neighbour) < 0) {\n          var otherDegree = remainingDegrees.get(neighbour);\n          var newDegree = otherDegree - 1;\n\n          if (newDegree == 1) {\n            tempList.push(neighbour);\n          }\n\n          remainingDegrees.set(neighbour, newDegree);\n        }\n      });\n    }\n\n    removedNodes = removedNodes.concat(tempList);\n\n    if (list.length == 1 || list.length == 2) {\n      foundCenter = true;\n      centerNode = list[0];\n    }\n  }\n\n  return centerNode;\n};\n\n/**\r\n * During the coarsening process, this layout may be referenced by two graph managers\r\n * this setter function grants access to change the currently being used graph manager\r\n */\nLayout.prototype.setGraphManager = function (gm) {\n  this.graphManager = gm;\n};\n\nmodule.exports = Layout;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RandomSeed() {}\n// adapted from: https://stackoverflow.com/a/19303725\nRandomSeed.seed = 1;\nRandomSeed.x = 0;\n\nRandomSeed.nextDouble = function () {\n  RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n  return RandomSeed.x - Math.floor(RandomSeed.x);\n};\n\nmodule.exports = RandomSeed;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar PointD = __webpack_require__(4);\n\nfunction Transform(x, y) {\n  this.lworldOrgX = 0.0;\n  this.lworldOrgY = 0.0;\n  this.ldeviceOrgX = 0.0;\n  this.ldeviceOrgY = 0.0;\n  this.lworldExtX = 1.0;\n  this.lworldExtY = 1.0;\n  this.ldeviceExtX = 1.0;\n  this.ldeviceExtY = 1.0;\n}\n\nTransform.prototype.getWorldOrgX = function () {\n  return this.lworldOrgX;\n};\n\nTransform.prototype.setWorldOrgX = function (wox) {\n  this.lworldOrgX = wox;\n};\n\nTransform.prototype.getWorldOrgY = function () {\n  return this.lworldOrgY;\n};\n\nTransform.prototype.setWorldOrgY = function (woy) {\n  this.lworldOrgY = woy;\n};\n\nTransform.prototype.getWorldExtX = function () {\n  return this.lworldExtX;\n};\n\nTransform.prototype.setWorldExtX = function (wex) {\n  this.lworldExtX = wex;\n};\n\nTransform.prototype.getWorldExtY = function () {\n  return this.lworldExtY;\n};\n\nTransform.prototype.setWorldExtY = function (wey) {\n  this.lworldExtY = wey;\n};\n\n/* Device related */\n\nTransform.prototype.getDeviceOrgX = function () {\n  return this.ldeviceOrgX;\n};\n\nTransform.prototype.setDeviceOrgX = function (dox) {\n  this.ldeviceOrgX = dox;\n};\n\nTransform.prototype.getDeviceOrgY = function () {\n  return this.ldeviceOrgY;\n};\n\nTransform.prototype.setDeviceOrgY = function (doy) {\n  this.ldeviceOrgY = doy;\n};\n\nTransform.prototype.getDeviceExtX = function () {\n  return this.ldeviceExtX;\n};\n\nTransform.prototype.setDeviceExtX = function (dex) {\n  this.ldeviceExtX = dex;\n};\n\nTransform.prototype.getDeviceExtY = function () {\n  return this.ldeviceExtY;\n};\n\nTransform.prototype.setDeviceExtY = function (dey) {\n  this.ldeviceExtY = dey;\n};\n\nTransform.prototype.transformX = function (x) {\n  var xDevice = 0.0;\n  var worldExtX = this.lworldExtX;\n  if (worldExtX != 0.0) {\n    xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n  }\n\n  return xDevice;\n};\n\nTransform.prototype.transformY = function (y) {\n  var yDevice = 0.0;\n  var worldExtY = this.lworldExtY;\n  if (worldExtY != 0.0) {\n    yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n  }\n\n  return yDevice;\n};\n\nTransform.prototype.inverseTransformX = function (x) {\n  var xWorld = 0.0;\n  var deviceExtX = this.ldeviceExtX;\n  if (deviceExtX != 0.0) {\n    xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n  }\n\n  return xWorld;\n};\n\nTransform.prototype.inverseTransformY = function (y) {\n  var yWorld = 0.0;\n  var deviceExtY = this.ldeviceExtY;\n  if (deviceExtY != 0.0) {\n    yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n  }\n  return yWorld;\n};\n\nTransform.prototype.inverseTransformPoint = function (inPoint) {\n  var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n  return outPoint;\n};\n\nmodule.exports = Transform;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar Layout = __webpack_require__(15);\nvar FDLayoutConstants = __webpack_require__(7);\nvar LayoutConstants = __webpack_require__(0);\nvar IGeometry = __webpack_require__(8);\nvar IMath = __webpack_require__(9);\n\nfunction FDLayout() {\n  Layout.call(this);\n\n  this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n  this.idealEdgeLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n  this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n  this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n  this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n  this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n  this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n  this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n  this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n  this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.totalDisplacement = 0.0;\n  this.oldTotalDisplacement = 0.0;\n  this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n}\n\nFDLayout.prototype = Object.create(Layout.prototype);\n\nfor (var prop in Layout) {\n  FDLayout[prop] = Layout[prop];\n}\n\nFDLayout.prototype.initParameters = function () {\n  Layout.prototype.initParameters.call(this, arguments);\n\n  this.totalIterations = 0;\n  this.notAnimatedIterations = 0;\n\n  this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n\n  this.grid = [];\n};\n\nFDLayout.prototype.calcIdealEdgeLengths = function () {\n  var edge;\n  var lcaDepth;\n  var source;\n  var target;\n  var sizeOfSourceInLca;\n  var sizeOfTargetInLca;\n\n  var allEdges = this.getGraphManager().getAllEdges();\n  for (var i = 0; i < allEdges.length; i++) {\n    edge = allEdges[i];\n\n    edge.idealLength = this.idealEdgeLength;\n\n    if (edge.isInterGraph) {\n      source = edge.getSource();\n      target = edge.getTarget();\n\n      sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n      sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n\n      if (this.useSmartIdealEdgeLengthCalculation) {\n        edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n      }\n\n      lcaDepth = edge.getLca().getInclusionTreeDepth();\n\n      edge.idealLength += FDLayoutConstants.DEFAULT_EDGE_LENGTH * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n    }\n  }\n};\n\nFDLayout.prototype.initSpringEmbedder = function () {\n\n  var s = this.getAllNodes().length;\n  if (this.incremental) {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    }\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n  } else {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    } else {\n      this.coolingFactor = 1.0;\n    }\n    this.initialCoolingFactor = this.coolingFactor;\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n  }\n\n  this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n\n  this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n\n  this.repulsionRange = this.calcRepulsionRange();\n};\n\nFDLayout.prototype.calcSpringForces = function () {\n  var lEdges = this.getAllEdges();\n  var edge;\n\n  for (var i = 0; i < lEdges.length; i++) {\n    edge = lEdges[i];\n\n    this.calcSpringForce(edge, edge.idealLength);\n  }\n};\n\nFDLayout.prototype.calcRepulsionForces = function () {\n  var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var i, j;\n  var nodeA, nodeB;\n  var lNodes = this.getAllNodes();\n  var processedNodeSet;\n\n  if (this.useFRGridVariant) {\n    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n      this.updateGrid();\n    }\n\n    processedNodeSet = new Set();\n\n    // calculate repulsion forces between each nodes and its surrounding\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n      this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n      processedNodeSet.add(nodeA);\n    }\n  } else {\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n\n      for (j = i + 1; j < lNodes.length; j++) {\n        nodeB = lNodes[j];\n\n        // If both nodes are not members of the same graph, skip.\n        if (nodeA.getOwner() != nodeB.getOwner()) {\n          continue;\n        }\n\n        this.calcRepulsionForce(nodeA, nodeB);\n      }\n    }\n  }\n};\n\nFDLayout.prototype.calcGravitationalForces = function () {\n  var node;\n  var lNodes = this.getAllNodesToApplyGravitation();\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    this.calcGravitationalForce(node);\n  }\n};\n\nFDLayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\nFDLayout.prototype.calcSpringForce = function (edge, idealLength) {\n  var sourceNode = edge.getSource();\n  var targetNode = edge.getTarget();\n\n  var length;\n  var springForce;\n  var springForceX;\n  var springForceY;\n\n  // Update edge length\n  if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n    edge.updateLengthSimple();\n  } else {\n    edge.updateLength();\n\n    if (edge.isOverlapingSourceAndTarget) {\n      return;\n    }\n  }\n\n  length = edge.getLength();\n\n  if (length == 0) return;\n\n  // Calculate spring forces\n  springForce = this.springConstant * (length - idealLength);\n\n  // Project force onto x and y axes\n  springForceX = springForce * (edge.lengthX / length);\n  springForceY = springForce * (edge.lengthY / length);\n\n  // Apply forces on the end nodes\n  sourceNode.springForceX += springForceX;\n  sourceNode.springForceY += springForceY;\n  targetNode.springForceX -= springForceX;\n  targetNode.springForceY -= springForceY;\n};\n\nFDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {\n  var rectA = nodeA.getRect();\n  var rectB = nodeB.getRect();\n  var overlapAmount = new Array(2);\n  var clipPoints = new Array(4);\n  var distanceX;\n  var distanceY;\n  var distanceSquared;\n  var distance;\n  var repulsionForce;\n  var repulsionForceX;\n  var repulsionForceY;\n\n  if (rectA.intersects(rectB)) // two nodes overlap\n    {\n      // calculate separation amount in x and y directions\n      IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n\n      repulsionForceX = 2 * overlapAmount[0];\n      repulsionForceY = 2 * overlapAmount[1];\n\n      var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\n\n      // Apply forces on the two nodes\n      nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n      nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n      nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n      nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n    } else // no overlap\n    {\n      // calculate distance\n\n      if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) // simply base repulsion on distance of node centers\n        {\n          distanceX = rectB.getCenterX() - rectA.getCenterX();\n          distanceY = rectB.getCenterY() - rectA.getCenterY();\n        } else // use clipping points\n        {\n          IGeometry.getIntersection(rectA, rectB, clipPoints);\n\n          distanceX = clipPoints[2] - clipPoints[0];\n          distanceY = clipPoints[3] - clipPoints[1];\n        }\n\n      // No repulsion range. FR grid variant should take care of this.\n      if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      distanceSquared = distanceX * distanceX + distanceY * distanceY;\n      distance = Math.sqrt(distanceSquared);\n\n      repulsionForce = this.repulsionConstant * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\n\n      // Project force onto x and y axes\n      repulsionForceX = repulsionForce * distanceX / distance;\n      repulsionForceY = repulsionForce * distanceY / distance;\n\n      // Apply forces on the two nodes    \n      nodeA.repulsionForceX -= repulsionForceX;\n      nodeA.repulsionForceY -= repulsionForceY;\n      nodeB.repulsionForceX += repulsionForceX;\n      nodeB.repulsionForceY += repulsionForceY;\n    }\n};\n\nFDLayout.prototype.calcGravitationalForce = function (node) {\n  var ownerGraph;\n  var ownerCenterX;\n  var ownerCenterY;\n  var distanceX;\n  var distanceY;\n  var absDistanceX;\n  var absDistanceY;\n  var estimatedSize;\n  ownerGraph = node.getOwner();\n\n  ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n  ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n  distanceX = node.getCenterX() - ownerCenterX;\n  distanceY = node.getCenterY() - ownerCenterY;\n  absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n  absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n\n  if (node.getOwner() == this.graphManager.getRoot()) // in the root graph\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX;\n        node.gravitationForceY = -this.gravityConstant * distanceY;\n      }\n    } else // inside a compound\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n      }\n    }\n};\n\nFDLayout.prototype.isConverged = function () {\n  var converged;\n  var oscilating = false;\n\n  if (this.totalIterations > this.maxIterations / 3) {\n    oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n  }\n\n  converged = this.totalDisplacement < this.totalDisplacementThreshold;\n\n  this.oldTotalDisplacement = this.totalDisplacement;\n\n  return converged || oscilating;\n};\n\nFDLayout.prototype.animate = function () {\n  if (this.animationDuringLayout && !this.isSubLayout) {\n    if (this.notAnimatedIterations == this.animationPeriod) {\n      this.update();\n      this.notAnimatedIterations = 0;\n    } else {\n      this.notAnimatedIterations++;\n    }\n  }\n};\n\n//This method calculates the number of children (weight) for all nodes\nFDLayout.prototype.calcNoOfChildrenForAllNodes = function () {\n  var node;\n  var allNodes = this.graphManager.getAllNodes();\n\n  for (var i = 0; i < allNodes.length; i++) {\n    node = allNodes[i];\n    node.noOfChildren = node.getNoOfChildren();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: FR-Grid Variant Repulsion Force Calculation\n// -----------------------------------------------------------------------------\n\nFDLayout.prototype.calcGrid = function (graph) {\n\n  var sizeX = 0;\n  var sizeY = 0;\n\n  sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n  sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n\n  var grid = new Array(sizeX);\n\n  for (var i = 0; i < sizeX; i++) {\n    grid[i] = new Array(sizeY);\n  }\n\n  for (var i = 0; i < sizeX; i++) {\n    for (var j = 0; j < sizeY; j++) {\n      grid[i][j] = new Array();\n    }\n  }\n\n  return grid;\n};\n\nFDLayout.prototype.addNodeToGrid = function (v, left, top) {\n\n  var startX = 0;\n  var finishX = 0;\n  var startY = 0;\n  var finishY = 0;\n\n  startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n  finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n  startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n  finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n\n  for (var i = startX; i <= finishX; i++) {\n    for (var j = startY; j <= finishY; j++) {\n      this.grid[i][j].push(v);\n      v.setGridCoordinates(startX, finishX, startY, finishY);\n    }\n  }\n};\n\nFDLayout.prototype.updateGrid = function () {\n  var i;\n  var nodeA;\n  var lNodes = this.getAllNodes();\n\n  this.grid = this.calcGrid(this.graphManager.getRoot());\n\n  // put all nodes to proper grid cells\n  for (i = 0; i < lNodes.length; i++) {\n    nodeA = lNodes[i];\n    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n  }\n};\n\nFDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n\n  if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n    var surrounding = new Set();\n    nodeA.surrounding = new Array();\n    var nodeB;\n    var grid = this.grid;\n\n    for (var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++) {\n      for (var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++) {\n        if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n          for (var k = 0; k < grid[i][j].length; k++) {\n            nodeB = grid[i][j][k];\n\n            // If both nodes are not members of the same graph, \n            // or both nodes are the same, skip.\n            if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n              continue;\n            }\n\n            // check if the repulsion force between\n            // nodeA and nodeB has already been calculated\n            if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n              var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n              var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\n\n              // if the distance between nodeA and nodeB \n              // is less then calculation range\n              if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                //then add nodeB to surrounding of nodeA\n                surrounding.add(nodeB);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n  }\n  for (i = 0; i < nodeA.surrounding.length; i++) {\n    this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n  }\n};\n\nFDLayout.prototype.calcRepulsionRange = function () {\n  return 0.0;\n};\n\nmodule.exports = FDLayout;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LEdge = __webpack_require__(1);\nvar FDLayoutConstants = __webpack_require__(7);\n\nfunction FDLayoutEdge(source, target, vEdge) {\n  LEdge.call(this, source, target, vEdge);\n  this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n}\n\nFDLayoutEdge.prototype = Object.create(LEdge.prototype);\n\nfor (var prop in LEdge) {\n  FDLayoutEdge[prop] = LEdge[prop];\n}\n\nmodule.exports = FDLayoutEdge;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LNode = __webpack_require__(3);\n\nfunction FDLayoutNode(gm, loc, size, vNode) {\n  // alternative constructor is handled inside LNode\n  LNode.call(this, gm, loc, size, vNode);\n  //Spring, repulsion and gravitational forces acting on this node\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  //Amount by which this node is to be moved in this iteration\n  this.displacementX = 0;\n  this.displacementY = 0;\n\n  //Start and finish grid coordinates that this node is fallen into\n  this.startX = 0;\n  this.finishX = 0;\n  this.startY = 0;\n  this.finishY = 0;\n\n  //Geometric neighbors of this node\n  this.surrounding = [];\n}\n\nFDLayoutNode.prototype = Object.create(LNode.prototype);\n\nfor (var prop in LNode) {\n  FDLayoutNode[prop] = LNode[prop];\n}\n\nFDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {\n  this.startX = _startX;\n  this.finishX = _finishX;\n  this.startY = _startY;\n  this.finishY = _finishY;\n};\n\nmodule.exports = FDLayoutNode;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction DimensionD(width, height) {\n  this.width = 0;\n  this.height = 0;\n  if (width !== null && height !== null) {\n    this.height = height;\n    this.width = width;\n  }\n}\n\nDimensionD.prototype.getWidth = function () {\n  return this.width;\n};\n\nDimensionD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nDimensionD.prototype.getHeight = function () {\n  return this.height;\n};\n\nDimensionD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nmodule.exports = DimensionD;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __webpack_require__(14);\n\nfunction HashMap() {\n  this.map = {};\n  this.keys = [];\n}\n\nHashMap.prototype.put = function (key, value) {\n  var theId = UniqueIDGeneretor.createID(key);\n  if (!this.contains(theId)) {\n    this.map[theId] = value;\n    this.keys.push(key);\n  }\n};\n\nHashMap.prototype.contains = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[key] != null;\n};\n\nHashMap.prototype.get = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[theId];\n};\n\nHashMap.prototype.keySet = function () {\n  return this.keys;\n};\n\nmodule.exports = HashMap;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __webpack_require__(14);\n\nfunction HashSet() {\n  this.set = {};\n}\n;\n\nHashSet.prototype.add = function (obj) {\n  var theId = UniqueIDGeneretor.createID(obj);\n  if (!this.contains(theId)) this.set[theId] = obj;\n};\n\nHashSet.prototype.remove = function (obj) {\n  delete this.set[UniqueIDGeneretor.createID(obj)];\n};\n\nHashSet.prototype.clear = function () {\n  this.set = {};\n};\n\nHashSet.prototype.contains = function (obj) {\n  return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n};\n\nHashSet.prototype.isEmpty = function () {\n  return this.size() === 0;\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\n//concats this.set to the given list\nHashSet.prototype.addAllTo = function (list) {\n  var keys = Object.keys(this.set);\n  var length = keys.length;\n  for (var i = 0; i < length; i++) {\n    list.push(this.set[keys[i]]);\n  }\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\nHashSet.prototype.addAll = function (list) {\n  var s = list.length;\n  for (var i = 0; i < s; i++) {\n    var v = list[i];\n    this.add(v);\n  }\n};\n\nmodule.exports = HashSet;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A classic Quicksort algorithm with Hoare's partition\n * - Works also on LinkedList objects\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar LinkedList = __webpack_require__(11);\n\nvar Quicksort = function () {\n    function Quicksort(A, compareFunction) {\n        _classCallCheck(this, Quicksort);\n\n        if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n\n        var length = void 0;\n        if (A instanceof LinkedList) length = A.size();else length = A.length;\n\n        this._quicksort(A, 0, length - 1);\n    }\n\n    _createClass(Quicksort, [{\n        key: '_quicksort',\n        value: function _quicksort(A, p, r) {\n            if (p < r) {\n                var q = this._partition(A, p, r);\n                this._quicksort(A, p, q);\n                this._quicksort(A, q + 1, r);\n            }\n        }\n    }, {\n        key: '_partition',\n        value: function _partition(A, p, r) {\n            var x = this._get(A, p);\n            var i = p;\n            var j = r;\n            while (true) {\n                while (this.compareFunction(x, this._get(A, j))) {\n                    j--;\n                }while (this.compareFunction(this._get(A, i), x)) {\n                    i++;\n                }if (i < j) {\n                    this._swap(A, i, j);\n                    i++;\n                    j--;\n                } else return j;\n            }\n        }\n    }, {\n        key: '_get',\n        value: function _get(object, index) {\n            if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];\n        }\n    }, {\n        key: '_set',\n        value: function _set(object, index, value) {\n            if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;\n        }\n    }, {\n        key: '_swap',\n        value: function _swap(A, i, j) {\n            var temp = this._get(A, i);\n            this._set(A, i, this._get(A, j));\n            this._set(A, j, temp);\n        }\n    }, {\n        key: '_defaultCompareFunction',\n        value: function _defaultCompareFunction(a, b) {\n            return b > a;\n        }\n    }]);\n\n    return Quicksort;\n}();\n\nmodule.exports = Quicksort;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n *\n *   Aside from the inputs, you can assign the scores for,\n *   - Match: The two characters at the current index are same.\n *   - Mismatch: The two characters at the current index are different.\n *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n */\n\nvar NeedlemanWunsch = function () {\n    function NeedlemanWunsch(sequence1, sequence2) {\n        var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n        var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n\n        _classCallCheck(this, NeedlemanWunsch);\n\n        this.sequence1 = sequence1;\n        this.sequence2 = sequence2;\n        this.match_score = match_score;\n        this.mismatch_penalty = mismatch_penalty;\n        this.gap_penalty = gap_penalty;\n\n        // Just the remove redundancy\n        this.iMax = sequence1.length + 1;\n        this.jMax = sequence2.length + 1;\n\n        // Grid matrix of scores\n        this.grid = new Array(this.iMax);\n        for (var i = 0; i < this.iMax; i++) {\n            this.grid[i] = new Array(this.jMax);\n\n            for (var j = 0; j < this.jMax; j++) {\n                this.grid[i][j] = 0;\n            }\n        }\n\n        // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n        this.tracebackGrid = new Array(this.iMax);\n        for (var _i = 0; _i < this.iMax; _i++) {\n            this.tracebackGrid[_i] = new Array(this.jMax);\n\n            for (var _j = 0; _j < this.jMax; _j++) {\n                this.tracebackGrid[_i][_j] = [null, null, null];\n            }\n        }\n\n        // The aligned sequences (return multiple possibilities)\n        this.alignments = [];\n\n        // Final alignment score\n        this.score = -1;\n\n        // Calculate scores and tracebacks\n        this.computeGrids();\n    }\n\n    _createClass(NeedlemanWunsch, [{\n        key: \"getScore\",\n        value: function getScore() {\n            return this.score;\n        }\n    }, {\n        key: \"getAlignments\",\n        value: function getAlignments() {\n            return this.alignments;\n        }\n\n        // Main dynamic programming procedure\n\n    }, {\n        key: \"computeGrids\",\n        value: function computeGrids() {\n            // Fill in the first row\n            for (var j = 1; j < this.jMax; j++) {\n                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n                this.tracebackGrid[0][j] = [false, false, true];\n            }\n\n            // Fill in the first column\n            for (var i = 1; i < this.iMax; i++) {\n                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n                this.tracebackGrid[i][0] = [false, true, false];\n            }\n\n            // Fill the rest of the grid\n            for (var _i2 = 1; _i2 < this.iMax; _i2++) {\n                for (var _j2 = 1; _j2 < this.jMax; _j2++) {\n                    // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                    var diag = void 0;\n                    if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n\n                    var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                    var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\n\n                    // If there exists multiple max values, capture them for multiple paths\n                    var maxOf = [diag, up, left];\n                    var indices = this.arrayAllMaxIndexes(maxOf);\n\n                    // Update Grids\n                    this.grid[_i2][_j2] = maxOf[indices[0]];\n                    this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];\n                }\n            }\n\n            // Update alignment score\n            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n        }\n\n        // Gets all possible valid sequence combinations\n\n    }, {\n        key: \"alignmentTraceback\",\n        value: function alignmentTraceback() {\n            var inProcessAlignments = [];\n\n            inProcessAlignments.push({ pos: [this.sequence1.length, this.sequence2.length],\n                seq1: \"\",\n                seq2: \"\"\n            });\n\n            while (inProcessAlignments[0]) {\n                var current = inProcessAlignments[0];\n                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n\n                if (directions[0]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1] - 1],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n                if (directions[1]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1]],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: '-' + current.seq2\n                    });\n                }\n                if (directions[2]) {\n                    inProcessAlignments.push({ pos: [current.pos[0], current.pos[1] - 1],\n                        seq1: '-' + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n\n                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({ sequence1: current.seq1,\n                    sequence2: current.seq2\n                });\n\n                inProcessAlignments.shift();\n            }\n\n            return this.alignments;\n        }\n\n        // Helper Functions\n\n    }, {\n        key: \"getAllIndexes\",\n        value: function getAllIndexes(arr, val) {\n            var indexes = [],\n                i = -1;\n            while ((i = arr.indexOf(val, i + 1)) !== -1) {\n                indexes.push(i);\n            }\n            return indexes;\n        }\n    }, {\n        key: \"arrayAllMaxIndexes\",\n        value: function arrayAllMaxIndexes(array) {\n            return this.getAllIndexes(array, Math.max.apply(null, array));\n        }\n    }]);\n\n    return NeedlemanWunsch;\n}();\n\nmodule.exports = NeedlemanWunsch;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar layoutBase = function layoutBase() {\n  return;\n};\n\nlayoutBase.FDLayout = __webpack_require__(18);\nlayoutBase.FDLayoutConstants = __webpack_require__(7);\nlayoutBase.FDLayoutEdge = __webpack_require__(19);\nlayoutBase.FDLayoutNode = __webpack_require__(20);\nlayoutBase.DimensionD = __webpack_require__(21);\nlayoutBase.HashMap = __webpack_require__(22);\nlayoutBase.HashSet = __webpack_require__(23);\nlayoutBase.IGeometry = __webpack_require__(8);\nlayoutBase.IMath = __webpack_require__(9);\nlayoutBase.Integer = __webpack_require__(10);\nlayoutBase.Point = __webpack_require__(12);\nlayoutBase.PointD = __webpack_require__(4);\nlayoutBase.RandomSeed = __webpack_require__(16);\nlayoutBase.RectangleD = __webpack_require__(13);\nlayoutBase.Transform = __webpack_require__(17);\nlayoutBase.UniqueIDGeneretor = __webpack_require__(14);\nlayoutBase.Quicksort = __webpack_require__(24);\nlayoutBase.LinkedList = __webpack_require__(11);\nlayoutBase.LGraphObject = __webpack_require__(2);\nlayoutBase.LGraph = __webpack_require__(5);\nlayoutBase.LEdge = __webpack_require__(1);\nlayoutBase.LGraphManager = __webpack_require__(6);\nlayoutBase.LNode = __webpack_require__(3);\nlayoutBase.Layout = __webpack_require__(15);\nlayoutBase.LayoutConstants = __webpack_require__(0);\nlayoutBase.NeedlemanWunsch = __webpack_require__(25);\n\nmodule.exports = layoutBase;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Emitter() {\n  this.listeners = [];\n}\n\nvar p = Emitter.prototype;\n\np.addListener = function (event, callback) {\n  this.listeners.push({\n    event: event,\n    callback: callback\n  });\n};\n\np.removeListener = function (event, callback) {\n  for (var i = this.listeners.length; i >= 0; i--) {\n    var l = this.listeners[i];\n\n    if (l.event === event && l.callback === callback) {\n      this.listeners.splice(i, 1);\n    }\n  }\n};\n\np.emit = function (event, data) {\n  for (var i = 0; i < this.listeners.length; i++) {\n    var l = this.listeners[i];\n\n    if (event === l.event) {\n      l.callback(data);\n    }\n  }\n};\n\nmodule.exports = Emitter;\n\n/***/ })\n/******/ ]);\n});","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"layout-base\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"layout-base\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"coseBase\"] = factory(require(\"layout-base\"));\n\telse\n\t\troot[\"coseBase\"] = factory(root[\"layoutBase\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\n\nfunction CoSEConstants() {}\n\n//CoSEConstants inherits static props in FDLayoutConstants\nfor (var prop in FDLayoutConstants) {\n  CoSEConstants[prop] = FDLayoutConstants[prop];\n}\n\nCoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\nCoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\nCoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\nCoSEConstants.TILE = true;\nCoSEConstants.TILING_PADDING_VERTICAL = 10;\nCoSEConstants.TILING_PADDING_HORIZONTAL = 10;\nCoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false; // make this true when cose is used incrementally as a part of other non-incremental layout\n\nmodule.exports = CoSEConstants;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutEdge = __webpack_require__(0).FDLayoutEdge;\n\nfunction CoSEEdge(source, target, vEdge) {\n  FDLayoutEdge.call(this, source, target, vEdge);\n}\n\nCoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\nfor (var prop in FDLayoutEdge) {\n  CoSEEdge[prop] = FDLayoutEdge[prop];\n}\n\nmodule.exports = CoSEEdge;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraph = __webpack_require__(0).LGraph;\n\nfunction CoSEGraph(parent, graphMgr, vGraph) {\n  LGraph.call(this, parent, graphMgr, vGraph);\n}\n\nCoSEGraph.prototype = Object.create(LGraph.prototype);\nfor (var prop in LGraph) {\n  CoSEGraph[prop] = LGraph[prop];\n}\n\nmodule.exports = CoSEGraph;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphManager = __webpack_require__(0).LGraphManager;\n\nfunction CoSEGraphManager(layout) {\n  LGraphManager.call(this, layout);\n}\n\nCoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\nfor (var prop in LGraphManager) {\n  CoSEGraphManager[prop] = LGraphManager[prop];\n}\n\nmodule.exports = CoSEGraphManager;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutNode = __webpack_require__(0).FDLayoutNode;\nvar IMath = __webpack_require__(0).IMath;\n\nfunction CoSENode(gm, loc, size, vNode) {\n  FDLayoutNode.call(this, gm, loc, size, vNode);\n}\n\nCoSENode.prototype = Object.create(FDLayoutNode.prototype);\nfor (var prop in FDLayoutNode) {\n  CoSENode[prop] = FDLayoutNode[prop];\n}\n\nCoSENode.prototype.move = function () {\n  var layout = this.graphManager.getLayout();\n  this.displacementX = layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n  this.displacementY = layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n\n  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n  }\n\n  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n  }\n\n  // a simple node, just move it\n  if (this.child == null) {\n    this.moveBy(this.displacementX, this.displacementY);\n  }\n  // an empty compound node, again just move it\n  else if (this.child.getNodes().length == 0) {\n      this.moveBy(this.displacementX, this.displacementY);\n    }\n    // non-empty compound node, propogate movement to children as well\n    else {\n        this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n      }\n\n  layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  this.displacementX = 0;\n  this.displacementY = 0;\n};\n\nCoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n  var nodes = this.getChild().getNodes();\n  var node;\n  for (var i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (node.getChild() == null) {\n      node.moveBy(dX, dY);\n      node.displacementX += dX;\n      node.displacementY += dY;\n    } else {\n      node.propogateDisplacementToChildren(dX, dY);\n    }\n  }\n};\n\nCoSENode.prototype.setPred1 = function (pred1) {\n  this.pred1 = pred1;\n};\n\nCoSENode.prototype.getPred1 = function () {\n  return pred1;\n};\n\nCoSENode.prototype.getPred2 = function () {\n  return pred2;\n};\n\nCoSENode.prototype.setNext = function (next) {\n  this.next = next;\n};\n\nCoSENode.prototype.getNext = function () {\n  return next;\n};\n\nCoSENode.prototype.setProcessed = function (processed) {\n  this.processed = processed;\n};\n\nCoSENode.prototype.isProcessed = function () {\n  return processed;\n};\n\nmodule.exports = CoSENode;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayout = __webpack_require__(0).FDLayout;\nvar CoSEGraphManager = __webpack_require__(4);\nvar CoSEGraph = __webpack_require__(3);\nvar CoSENode = __webpack_require__(5);\nvar CoSEEdge = __webpack_require__(2);\nvar CoSEConstants = __webpack_require__(1);\nvar FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\nvar LayoutConstants = __webpack_require__(0).LayoutConstants;\nvar Point = __webpack_require__(0).Point;\nvar PointD = __webpack_require__(0).PointD;\nvar Layout = __webpack_require__(0).Layout;\nvar Integer = __webpack_require__(0).Integer;\nvar IGeometry = __webpack_require__(0).IGeometry;\nvar LGraph = __webpack_require__(0).LGraph;\nvar Transform = __webpack_require__(0).Transform;\n\nfunction CoSELayout() {\n  FDLayout.call(this);\n\n  this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n}\n\nCoSELayout.prototype = Object.create(FDLayout.prototype);\n\nfor (var prop in FDLayout) {\n  CoSELayout[prop] = FDLayout[prop];\n}\n\nCoSELayout.prototype.newGraphManager = function () {\n  var gm = new CoSEGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nCoSELayout.prototype.newGraph = function (vGraph) {\n  return new CoSEGraph(null, this.graphManager, vGraph);\n};\n\nCoSELayout.prototype.newNode = function (vNode) {\n  return new CoSENode(this.graphManager, vNode);\n};\n\nCoSELayout.prototype.newEdge = function (vEdge) {\n  return new CoSEEdge(null, null, vEdge);\n};\n\nCoSELayout.prototype.initParameters = function () {\n  FDLayout.prototype.initParameters.call(this, arguments);\n  if (!this.isSubLayout) {\n    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n      this.idealEdgeLength = 10;\n    } else {\n      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n    }\n\n    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n    this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n    this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n    // variables for tree reduction support\n    this.prunedNodesAll = [];\n    this.growTreeIterations = 0;\n    this.afterGrowthIterations = 0;\n    this.isTreeGrowing = false;\n    this.isGrowthFinished = false;\n\n    // variables for cooling\n    this.coolingCycle = 0;\n    this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n    this.finalTemperature = FDLayoutConstants.CONVERGENCE_CHECK_PERIOD / this.maxIterations;\n    this.coolingAdjuster = 1;\n  }\n};\n\nCoSELayout.prototype.layout = function () {\n  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  if (createBendsAsNeeded) {\n    this.createBendpoints();\n    this.graphManager.resetAllEdges();\n  }\n\n  this.level = 0;\n  return this.classicLayout();\n};\n\nCoSELayout.prototype.classicLayout = function () {\n  this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n  this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n  this.calcNoOfChildrenForAllNodes();\n  this.graphManager.calcLowestCommonAncestors();\n  this.graphManager.calcInclusionTreeDepths();\n  this.graphManager.getRoot().calcEstimatedSize();\n  this.calcIdealEdgeLengths();\n\n  if (!this.incremental) {\n    var forest = this.getFlatForest();\n\n    // The graph associated with this layout is flat and a forest\n    if (forest.length > 0) {\n      this.positionNodesRadially(forest);\n    }\n    // The graph associated with this layout is not flat or a forest\n    else {\n        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n        this.reduceTrees();\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.positionNodesRandomly();\n      }\n  } else {\n    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n      // Reduce the trees in incremental mode if only this constant is set to true \n      this.reduceTrees();\n      // Update nodes that gravity will be applied\n      this.graphManager.resetAllNodesToApplyGravitation();\n      var allNodes = new Set(this.getAllNodes());\n      var intersection = this.nodesWithGravity.filter(function (x) {\n        return allNodes.has(x);\n      });\n      this.graphManager.setAllNodesToApplyGravitation(intersection);\n    }\n  }\n\n  this.initSpringEmbedder();\n  this.runSpringEmbedder();\n\n  return true;\n};\n\nCoSELayout.prototype.tick = function () {\n  this.totalIterations++;\n\n  if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.prunedNodesAll.length > 0) {\n      this.isTreeGrowing = true;\n    } else {\n      return true;\n    }\n  }\n\n  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.isConverged()) {\n      if (this.prunedNodesAll.length > 0) {\n        this.isTreeGrowing = true;\n      } else {\n        return true;\n      }\n    }\n\n    this.coolingCycle++;\n\n    if (this.layoutQuality == 0) {\n      // quality - \"draft\"\n      this.coolingAdjuster = this.coolingCycle;\n    } else if (this.layoutQuality == 1) {\n      // quality - \"default\"\n      this.coolingAdjuster = this.coolingCycle / 3;\n    }\n\n    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n  }\n  // Operations while tree is growing again \n  if (this.isTreeGrowing) {\n    if (this.growTreeIterations % 10 == 0) {\n      if (this.prunedNodesAll.length > 0) {\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.growTree(this.prunedNodesAll);\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n      } else {\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = true;\n      }\n    }\n    this.growTreeIterations++;\n  }\n  // Operations after growth is finished\n  if (this.isGrowthFinished) {\n    if (this.isConverged()) {\n      return true;\n    }\n    if (this.afterGrowthIterations % 10 == 0) {\n      this.graphManager.updateBounds();\n      this.updateGrid();\n    }\n    this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n    this.afterGrowthIterations++;\n  }\n\n  var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n  var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n\n  this.totalDisplacement = 0;\n  this.graphManager.updateBounds();\n  this.calcSpringForces();\n  this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n  this.calcGravitationalForces();\n  this.moveNodes();\n  this.animate();\n\n  return false; // Layout is not ended yet return false\n};\n\nCoSELayout.prototype.getPositionsData = function () {\n  var allNodes = this.graphManager.getAllNodes();\n  var pData = {};\n  for (var i = 0; i < allNodes.length; i++) {\n    var rect = allNodes[i].rect;\n    var id = allNodes[i].id;\n    pData[id] = {\n      id: id,\n      x: rect.getCenterX(),\n      y: rect.getCenterY(),\n      w: rect.width,\n      h: rect.height\n    };\n  }\n\n  return pData;\n};\n\nCoSELayout.prototype.runSpringEmbedder = function () {\n  this.initialAnimationPeriod = 25;\n  this.animationPeriod = this.initialAnimationPeriod;\n  var layoutEnded = false;\n\n  // If aminate option is 'during' signal that layout is supposed to start iterating\n  if (FDLayoutConstants.ANIMATE === 'during') {\n    this.emit('layoutstarted');\n  } else {\n    // If aminate option is 'during' tick() function will be called on index.js\n    while (!layoutEnded) {\n      layoutEnded = this.tick();\n    }\n\n    this.graphManager.updateBounds();\n  }\n};\n\nCoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n  var nodeList = [];\n  var graph;\n\n  var graphs = this.graphManager.getGraphs();\n  var size = graphs.length;\n  var i;\n  for (i = 0; i < size; i++) {\n    graph = graphs[i];\n\n    graph.updateConnected();\n\n    if (!graph.isConnected) {\n      nodeList = nodeList.concat(graph.getNodes());\n    }\n  }\n\n  return nodeList;\n};\n\nCoSELayout.prototype.createBendpoints = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  var visited = new Set();\n  var i;\n  for (i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n\n    if (!visited.has(edge)) {\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if (source == target) {\n        edge.getBendpoints().push(new PointD());\n        edge.getBendpoints().push(new PointD());\n        this.createDummyNodesForBendpoints(edge);\n        visited.add(edge);\n      } else {\n        var edgeList = [];\n\n        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n        if (!visited.has(edgeList[0])) {\n          if (edgeList.length > 1) {\n            var k;\n            for (k = 0; k < edgeList.length; k++) {\n              var multiEdge = edgeList[k];\n              multiEdge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(multiEdge);\n            }\n          }\n          edgeList.forEach(function (edge) {\n            visited.add(edge);\n          });\n        }\n      }\n    }\n\n    if (visited.size == edges.length) {\n      break;\n    }\n  }\n};\n\nCoSELayout.prototype.positionNodesRadially = function (forest) {\n  // We tile the trees to a grid row by row; first tree starts at (0,0)\n  var currentStartingPoint = new Point(0, 0);\n  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n  var height = 0;\n  var currentY = 0;\n  var currentX = 0;\n  var point = new PointD(0, 0);\n\n  for (var i = 0; i < forest.length; i++) {\n    if (i % numberOfColumns == 0) {\n      // Start of a new row, make the x coordinate 0, increment the\n      // y coordinate with the max height of the previous row\n      currentX = 0;\n      currentY = height;\n\n      if (i != 0) {\n        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n      }\n\n      height = 0;\n    }\n\n    var tree = forest[i];\n\n    // Find the center of the tree\n    var centerNode = Layout.findCenterOfTree(tree);\n\n    // Set the staring point of the next tree\n    currentStartingPoint.x = currentX;\n    currentStartingPoint.y = currentY;\n\n    // Do a radial layout starting with the center\n    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n    if (point.y > height) {\n      height = Math.floor(point.y);\n    }\n\n    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n  }\n\n  this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n};\n\nCoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n  var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n  var bounds = LGraph.calculateBounds(tree);\n\n  var transform = new Transform();\n  transform.setDeviceOrgX(bounds.getMinX());\n  transform.setDeviceOrgY(bounds.getMinY());\n  transform.setWorldOrgX(startingPoint.x);\n  transform.setWorldOrgY(startingPoint.y);\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    node.transform(transform);\n  }\n\n  var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n\n  return transform.inverseTransformPoint(bottomRight);\n};\n\nCoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n  // First, position this node by finding its angle.\n  var halfInterval = (endAngle - startAngle + 1) / 2;\n\n  if (halfInterval < 0) {\n    halfInterval += 180;\n  }\n\n  var nodeAngle = (halfInterval + startAngle) % 360;\n  var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n  // Make polar to java cordinate conversion.\n  var cos_teta = Math.cos(teta);\n  var x_ = distance * Math.cos(teta);\n  var y_ = distance * Math.sin(teta);\n\n  node.setCenter(x_, y_);\n\n  // Traverse all neighbors of this node and recursively call this\n  // function.\n  var neighborEdges = [];\n  neighborEdges = neighborEdges.concat(node.getEdges());\n  var childCount = neighborEdges.length;\n\n  if (parentOfNode != null) {\n    childCount--;\n  }\n\n  var branchCount = 0;\n\n  var incEdgesCount = neighborEdges.length;\n  var startIndex;\n\n  var edges = node.getEdgesBetween(parentOfNode);\n\n  // If there are multiple edges, prune them until there remains only one\n  // edge.\n  while (edges.length > 1) {\n    //neighborEdges.remove(edges.remove(0));\n    var temp = edges[0];\n    edges.splice(0, 1);\n    var index = neighborEdges.indexOf(temp);\n    if (index >= 0) {\n      neighborEdges.splice(index, 1);\n    }\n    incEdgesCount--;\n    childCount--;\n  }\n\n  if (parentOfNode != null) {\n    //assert edges.length == 1;\n    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n  } else {\n    startIndex = 0;\n  }\n\n  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n  for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n    // Don't back traverse to root node in current tree.\n    if (currentNeighbor == parentOfNode) {\n      continue;\n    }\n\n    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n    var childEndAngle = (childStartAngle + stepAngle) % 360;\n\n    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n\n    branchCount++;\n  }\n};\n\nCoSELayout.maxDiagonalInTree = function (tree) {\n  var maxDiagonal = Integer.MIN_VALUE;\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    var diagonal = node.getDiagonal();\n\n    if (diagonal > maxDiagonal) {\n      maxDiagonal = diagonal;\n    }\n  }\n\n  return maxDiagonal;\n};\n\nCoSELayout.prototype.calcRepulsionRange = function () {\n  // formula is 2 x (level + 1) x idealEdgeLength\n  return 2 * (this.level + 1) * this.idealEdgeLength;\n};\n\n// Tiling methods\n\n// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\nCoSELayout.prototype.groupZeroDegreeMembers = function () {\n  var self = this;\n  // array of [parent_id x oneDegreeNode_id]\n  var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n  this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n  this.idToDummyNode = {}; // A map of id to dummy node \n\n  var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n  var allNodes = this.graphManager.getAllNodes();\n\n  // Fill zero degree list\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    var parent = node.getParent();\n    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n      zeroDegree.push(node);\n    }\n  }\n\n  // Create a map of parent node and its zero degree members\n  for (var i = 0; i < zeroDegree.length; i++) {\n    var node = zeroDegree[i]; // Zero degree node itself\n    var p_id = node.getParent().id; // Parent id\n\n    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n\n    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n  }\n\n  // If there are at least two nodes at a level, create a dummy compound for them\n  Object.keys(tempMemberGroups).forEach(function (p_id) {\n    if (tempMemberGroups[p_id].length > 1) {\n      var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n      self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n      var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n      // Create a dummy compound with calculated id\n      var dummyCompound = new CoSENode(self.graphManager);\n      dummyCompound.id = dummyCompoundId;\n      dummyCompound.paddingLeft = parent.paddingLeft || 0;\n      dummyCompound.paddingRight = parent.paddingRight || 0;\n      dummyCompound.paddingBottom = parent.paddingBottom || 0;\n      dummyCompound.paddingTop = parent.paddingTop || 0;\n\n      self.idToDummyNode[dummyCompoundId] = dummyCompound;\n\n      var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n      var parentGraph = parent.getChild();\n\n      // Add dummy compound to parent the graph\n      parentGraph.add(dummyCompound);\n\n      // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n      for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n        var node = tempMemberGroups[p_id][i];\n\n        parentGraph.remove(node);\n        dummyParentGraph.add(node);\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.clearCompounds = function () {\n  var childGraphMap = {};\n  var idToNode = {};\n\n  // Get compound ordering by finding the inner one first\n  this.performDFSOnCompounds();\n\n  for (var i = 0; i < this.compoundOrder.length; i++) {\n\n    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n    // Remove children of compounds\n    this.graphManager.remove(this.compoundOrder[i].getChild());\n    this.compoundOrder[i].child = null;\n  }\n\n  this.graphManager.resetAllNodes();\n\n  // Tile the removed children\n  this.tileCompoundMembers(childGraphMap, idToNode);\n};\n\nCoSELayout.prototype.clearZeroDegreeMembers = function () {\n  var self = this;\n  var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n\n  Object.keys(this.memberGroups).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    // Set the width and height of the dummy compound as calculated\n    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n  });\n};\n\nCoSELayout.prototype.repopulateCompounds = function () {\n  for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n    var lCompoundNode = this.compoundOrder[i];\n    var id = lCompoundNode.id;\n    var horizontalMargin = lCompoundNode.paddingLeft;\n    var verticalMargin = lCompoundNode.paddingTop;\n\n    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);\n  }\n};\n\nCoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n  var self = this;\n  var tiledPack = this.tiledZeroDegreePack;\n\n  Object.keys(tiledPack).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n    var horizontalMargin = compoundNode.paddingLeft;\n    var verticalMargin = compoundNode.paddingTop;\n\n    // Adjust the positions of nodes wrt its compound\n    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);\n  });\n};\n\nCoSELayout.prototype.getToBeTiled = function (node) {\n  var id = node.id;\n  //firstly check the previous results\n  if (this.toBeTiled[id] != null) {\n    return this.toBeTiled[id];\n  }\n\n  //only compound nodes are to be tiled\n  var childGraph = node.getChild();\n  if (childGraph == null) {\n    this.toBeTiled[id] = false;\n    return false;\n  }\n\n  var children = childGraph.getNodes(); // Get the children nodes\n\n  //a compound node is not to be tiled if all of its compound children are not to be tiled\n  for (var i = 0; i < children.length; i++) {\n    var theChild = children[i];\n\n    if (this.getNodeDegree(theChild) > 0) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n\n    //pass the children not having the compound structure\n    if (theChild.getChild() == null) {\n      this.toBeTiled[theChild.id] = false;\n      continue;\n    }\n\n    if (!this.getToBeTiled(theChild)) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n  }\n  this.toBeTiled[id] = true;\n  return true;\n};\n\n// Get degree of a node depending of its edges and independent of its children\nCoSELayout.prototype.getNodeDegree = function (node) {\n  var id = node.id;\n  var edges = node.getEdges();\n  var degree = 0;\n\n  // For the edges connected\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    if (edge.getSource().id !== edge.getTarget().id) {\n      degree = degree + 1;\n    }\n  }\n  return degree;\n};\n\n// Get degree of a node with its children\nCoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n  var degree = this.getNodeDegree(node);\n  if (node.getChild() == null) {\n    return degree;\n  }\n  var children = node.getChild().getNodes();\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    degree += this.getNodeDegreeWithChildren(child);\n  }\n  return degree;\n};\n\nCoSELayout.prototype.performDFSOnCompounds = function () {\n  this.compoundOrder = [];\n  this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n};\n\nCoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.getChild() != null) {\n      this.fillCompexOrderByDFS(child.getChild().getNodes());\n    }\n    if (this.getToBeTiled(child)) {\n      this.compoundOrder.push(child);\n    }\n  }\n};\n\n/**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/\nCoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {\n  x += compoundHorizontalMargin;\n  y += compoundVerticalMargin;\n\n  var left = x;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    var row = organization.rows[i];\n    x = left;\n    var maxHeight = 0;\n\n    for (var j = 0; j < row.length; j++) {\n      var lnode = row[j];\n\n      lnode.rect.x = x; // + lnode.rect.width / 2;\n      lnode.rect.y = y; // + lnode.rect.height / 2;\n\n      x += lnode.rect.width + organization.horizontalPadding;\n\n      if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n    }\n\n    y += maxHeight + organization.verticalPadding;\n  }\n};\n\nCoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n  var self = this;\n  this.tiledMemberPack = [];\n\n  Object.keys(childGraphMap).forEach(function (id) {\n    // Get the compound node\n    var compoundNode = idToNode[id];\n\n    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    compoundNode.rect.width = self.tiledMemberPack[id].width;\n    compoundNode.rect.height = self.tiledMemberPack[id].height;\n  });\n};\n\nCoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n  var organization = {\n    rows: [],\n    rowWidth: [],\n    rowHeight: [],\n    width: 0,\n    height: minWidth, // assume minHeight equals to minWidth\n    verticalPadding: verticalPadding,\n    horizontalPadding: horizontalPadding\n  };\n\n  // Sort the nodes in ascending order of their areas\n  nodes.sort(function (n1, n2) {\n    if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;\n    if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;\n    return 0;\n  });\n\n  // Create the organization -> tile members\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    if (organization.rows.length == 0) {\n      this.insertNodeToRow(organization, lNode, 0, minWidth);\n    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n      this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);\n    } else {\n      this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n    }\n\n    this.shiftToLastRow(organization);\n  }\n\n  return organization;\n};\n\nCoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n  var minCompoundSize = minWidth;\n\n  // Add new row if needed\n  if (rowIndex == organization.rows.length) {\n    var secondDimension = [];\n\n    organization.rows.push(secondDimension);\n    organization.rowWidth.push(minCompoundSize);\n    organization.rowHeight.push(0);\n  }\n\n  // Update row width\n  var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n  if (organization.rows[rowIndex].length > 0) {\n    w += organization.horizontalPadding;\n  }\n\n  organization.rowWidth[rowIndex] = w;\n  // Update compound width\n  if (organization.width < w) {\n    organization.width = w;\n  }\n\n  // Update height\n  var h = node.rect.height;\n  if (rowIndex > 0) h += organization.verticalPadding;\n\n  var extraHeight = 0;\n  if (h > organization.rowHeight[rowIndex]) {\n    extraHeight = organization.rowHeight[rowIndex];\n    organization.rowHeight[rowIndex] = h;\n    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n  }\n\n  organization.height += extraHeight;\n\n  // Insert node\n  organization.rows[rowIndex].push(node);\n};\n\n//Scans the rows of an organization and returns the one with the min width\nCoSELayout.prototype.getShortestRowIndex = function (organization) {\n  var r = -1;\n  var min = Number.MAX_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    if (organization.rowWidth[i] < min) {\n      r = i;\n      min = organization.rowWidth[i];\n    }\n  }\n  return r;\n};\n\n//Scans the rows of an organization and returns the one with the max width\nCoSELayout.prototype.getLongestRowIndex = function (organization) {\n  var r = -1;\n  var max = Number.MIN_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n\n    if (organization.rowWidth[i] > max) {\n      r = i;\n      max = organization.rowWidth[i];\n    }\n  }\n\n  return r;\n};\n\n/**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/\nCoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n\n  var sri = this.getShortestRowIndex(organization);\n\n  if (sri < 0) {\n    return true;\n  }\n\n  var min = organization.rowWidth[sri];\n\n  if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n\n  var hDiff = 0;\n\n  // Adding to an existing row\n  if (organization.rowHeight[sri] < extraHeight) {\n    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n  }\n\n  var add_to_row_ratio;\n  if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n  } else {\n    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  // Adding a new row for this node\n  hDiff = extraHeight + organization.verticalPadding;\n  var add_new_row_ratio;\n  if (organization.width < extraWidth) {\n    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n  } else {\n    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n\n  if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n\n  return add_to_row_ratio < add_new_row_ratio;\n};\n\n//If moving the last node from the longest row and adding it to the last\n//row makes the bounding box smaller, do it.\nCoSELayout.prototype.shiftToLastRow = function (organization) {\n  var longest = this.getLongestRowIndex(organization);\n  var last = organization.rowWidth.length - 1;\n  var row = organization.rows[longest];\n  var node = row[row.length - 1];\n\n  var diff = node.width + organization.horizontalPadding;\n\n  // Check if there is enough space on the last row\n  if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n    // Remove the last element of the longest row\n    row.splice(-1, 1);\n\n    // Push it to the last row\n    organization.rows[last].push(node);\n\n    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n    // Update heights of the organization\n    var maxHeight = Number.MIN_VALUE;\n    for (var i = 0; i < row.length; i++) {\n      if (row[i].height > maxHeight) maxHeight = row[i].height;\n    }\n    if (longest > 0) maxHeight += organization.verticalPadding;\n\n    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n\n    organization.rowHeight[longest] = maxHeight;\n    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n\n    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n    organization.height += finalTotal - prevTotal;\n\n    this.shiftToLastRow(organization);\n  }\n};\n\nCoSELayout.prototype.tilingPreLayout = function () {\n  if (CoSEConstants.TILE) {\n    // Find zero degree nodes and create a compound for each level\n    this.groupZeroDegreeMembers();\n    // Tile and clear children of each compound\n    this.clearCompounds();\n    // Separately tile and clear zero degree nodes for each level\n    this.clearZeroDegreeMembers();\n  }\n};\n\nCoSELayout.prototype.tilingPostLayout = function () {\n  if (CoSEConstants.TILE) {\n    this.repopulateZeroDegreeMembers();\n    this.repopulateCompounds();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Tree Reduction methods\n// -----------------------------------------------------------------------------\n// Reduce trees \nCoSELayout.prototype.reduceTrees = function () {\n  var prunedNodesAll = [];\n  var containsLeaf = true;\n  var node;\n\n  while (containsLeaf) {\n    var allNodes = this.graphManager.getAllNodes();\n    var prunedNodesInStepTemp = [];\n    containsLeaf = false;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n        prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n        containsLeaf = true;\n      }\n    }\n    if (containsLeaf == true) {\n      var prunedNodesInStep = [];\n      for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n        if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n          prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n          prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n        }\n      }\n      prunedNodesAll.push(prunedNodesInStep);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    }\n  }\n  this.prunedNodesAll = prunedNodesAll;\n};\n\n// Grow tree one step \nCoSELayout.prototype.growTree = function (prunedNodesAll) {\n  var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n  var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n\n  var nodeData;\n  for (var i = 0; i < prunedNodesInStep.length; i++) {\n    nodeData = prunedNodesInStep[i];\n\n    this.findPlaceforPrunedNode(nodeData);\n\n    nodeData[2].add(nodeData[0]);\n    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n  }\n\n  prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n  this.graphManager.resetAllNodes();\n  this.graphManager.resetAllEdges();\n};\n\n// Find an appropriate position to replace pruned node, this method can be improved\nCoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n\n  var gridForPrunedNode;\n  var nodeToConnect;\n  var prunedNode = nodeData[0];\n  if (prunedNode == nodeData[1].source) {\n    nodeToConnect = nodeData[1].target;\n  } else {\n    nodeToConnect = nodeData[1].source;\n  }\n  var startGridX = nodeToConnect.startX;\n  var finishGridX = nodeToConnect.finishX;\n  var startGridY = nodeToConnect.startY;\n  var finishGridY = nodeToConnect.finishY;\n\n  var upNodeCount = 0;\n  var downNodeCount = 0;\n  var rightNodeCount = 0;\n  var leftNodeCount = 0;\n  var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n  if (startGridY > 0) {\n    for (var i = startGridX; i <= finishGridX; i++) {\n      controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n    }\n  }\n  if (finishGridX < this.grid.length - 1) {\n    for (var i = startGridY; i <= finishGridY; i++) {\n      controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n    }\n  }\n  if (finishGridY < this.grid[0].length - 1) {\n    for (var i = startGridX; i <= finishGridX; i++) {\n      controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n    }\n  }\n  if (startGridX > 0) {\n    for (var i = startGridY; i <= finishGridY; i++) {\n      controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n    }\n  }\n  var min = Integer.MAX_VALUE;\n  var minCount;\n  var minIndex;\n  for (var j = 0; j < controlRegions.length; j++) {\n    if (controlRegions[j] < min) {\n      min = controlRegions[j];\n      minCount = 1;\n      minIndex = j;\n    } else if (controlRegions[j] == min) {\n      minCount++;\n    }\n  }\n\n  if (minCount == 3 && min == 0) {\n    if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n      gridForPrunedNode = 1;\n    } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 0;\n    } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 3;\n    } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 2;\n    }\n  } else if (minCount == 2 && min == 0) {\n    var random = Math.floor(Math.random() * 2);\n    if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n      ;\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 1;\n      }\n    } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 2;\n      }\n    } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 1;\n      } else {\n        gridForPrunedNode = 2;\n      }\n    } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 1;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    } else {\n      if (random == 0) {\n        gridForPrunedNode = 2;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    }\n  } else if (minCount == 4 && min == 0) {\n    var random = Math.floor(Math.random() * 4);\n    gridForPrunedNode = random;\n  } else {\n    gridForPrunedNode = minIndex;\n  }\n\n  if (gridForPrunedNode == 0) {\n    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n  } else if (gridForPrunedNode == 1) {\n    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n  } else if (gridForPrunedNode == 2) {\n    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n  } else {\n    prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n  }\n};\n\nmodule.exports = CoSELayout;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar coseBase = {};\n\ncoseBase.layoutBase = __webpack_require__(0);\ncoseBase.CoSEConstants = __webpack_require__(1);\ncoseBase.CoSEEdge = __webpack_require__(2);\ncoseBase.CoSEGraph = __webpack_require__(3);\ncoseBase.CoSEGraphManager = __webpack_require__(4);\ncoseBase.CoSELayout = __webpack_require__(6);\ncoseBase.CoSENode = __webpack_require__(5);\n\nmodule.exports = coseBase;\n\n/***/ })\n/******/ ]);\n});","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"cose-base\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"cose-base\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cytoscapeCoseBilkent\"] = factory(require(\"cose-base\"));\n\telse\n\t\troot[\"cytoscapeCoseBilkent\"] = factory(root[\"coseBase\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LayoutConstants = __webpack_require__(0).layoutBase.LayoutConstants;\nvar FDLayoutConstants = __webpack_require__(0).layoutBase.FDLayoutConstants;\nvar CoSEConstants = __webpack_require__(0).CoSEConstants;\nvar CoSELayout = __webpack_require__(0).CoSELayout;\nvar CoSENode = __webpack_require__(0).CoSENode;\nvar PointD = __webpack_require__(0).layoutBase.PointD;\nvar DimensionD = __webpack_require__(0).layoutBase.DimensionD;\n\nvar defaults = {\n  // Called on `layoutready`\n  ready: function ready() {},\n  // Called on `layoutstop`\n  stop: function stop() {},\n  // 'draft', 'default' or 'proof\" \n  // - 'draft' fast cooling rate \n  // - 'default' moderate cooling rate \n  // - \"proof\" slow cooling rate\n  quality: 'default',\n  // include labels in node dimensions\n  nodeDimensionsIncludeLabels: false,\n  // number of ticks per frame; higher is faster but more jerky\n  refresh: 30,\n  // Whether to fit the network view after when done\n  fit: true,\n  // Padding on fit\n  padding: 10,\n  // Whether to enable incremental mode\n  randomize: true,\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: 4500,\n  // Ideal edge (non nested) length\n  idealEdgeLength: 50,\n  // Divisor to compute edge forces\n  edgeElasticity: 0.45,\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 0.1,\n  // Gravity force (constant)\n  gravity: 0.25,\n  // Maximum number of iterations to perform\n  numIter: 2500,\n  // For enabling tiling\n  tile: true,\n  // Type of layout animation. The option set is {'during', 'end', false}\n  animate: 'end',\n  // Duration for animate:end\n  animationDuration: 500,\n  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingVertical: 10,\n  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingHorizontal: 10,\n  // Gravity range (constant) for compounds\n  gravityRangeCompound: 1.5,\n  // Gravity force (constant) for compounds\n  gravityCompound: 1.0,\n  // Gravity range (constant)\n  gravityRange: 3.8,\n  // Initial cooling factor for incremental layout\n  initialEnergyOnIncremental: 0.5\n};\n\nfunction extend(defaults, options) {\n  var obj = {};\n\n  for (var i in defaults) {\n    obj[i] = defaults[i];\n  }\n\n  for (var i in options) {\n    obj[i] = options[i];\n  }\n\n  return obj;\n};\n\nfunction _CoSELayout(_options) {\n  this.options = extend(defaults, _options);\n  getUserOptions(this.options);\n}\n\nvar getUserOptions = function getUserOptions(options) {\n  if (options.nodeRepulsion != null) CoSEConstants.DEFAULT_REPULSION_STRENGTH = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = options.nodeRepulsion;\n  if (options.idealEdgeLength != null) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;\n  if (options.edgeElasticity != null) CoSEConstants.DEFAULT_SPRING_STRENGTH = FDLayoutConstants.DEFAULT_SPRING_STRENGTH = options.edgeElasticity;\n  if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n  if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n  if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n  if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n  if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n  if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n  if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n\n  if (options.quality == 'draft') LayoutConstants.QUALITY = 0;else if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 1;\n\n  CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n  CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n  CoSEConstants.TILE = options.tile;\n  CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n  CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n};\n\n_CoSELayout.prototype.run = function () {\n  var ready;\n  var frameId;\n  var options = this.options;\n  var idToLNode = this.idToLNode = {};\n  var layout = this.layout = new CoSELayout();\n  var self = this;\n\n  self.stopped = false;\n\n  this.cy = this.options.cy;\n\n  this.cy.trigger({ type: 'layoutstart', layout: this });\n\n  var gm = layout.newGraphManager();\n  this.gm = gm;\n\n  var nodes = this.options.eles.nodes();\n  var edges = this.options.eles.edges();\n\n  this.root = gm.addRoot();\n  this.processChildrenList(this.root, this.getTopMostNodes(nodes), layout);\n\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    var sourceNode = this.idToLNode[edge.data(\"source\")];\n    var targetNode = this.idToLNode[edge.data(\"target\")];\n    if (sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n      var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n      e1.id = edge.id();\n    }\n  }\n\n  var getPositions = function getPositions(ele, i) {\n    if (typeof ele === \"number\") {\n      ele = i;\n    }\n    var theId = ele.data('id');\n    var lNode = self.idToLNode[theId];\n\n    return {\n      x: lNode.getRect().getCenterX(),\n      y: lNode.getRect().getCenterY()\n    };\n  };\n\n  /*\n   * Reposition nodes in iterations animatedly\n   */\n  var iterateAnimated = function iterateAnimated() {\n    // Thigs to perform after nodes are repositioned on screen\n    var afterReposition = function afterReposition() {\n      if (options.fit) {\n        options.cy.fit(options.eles, options.padding);\n      }\n\n      if (!ready) {\n        ready = true;\n        self.cy.one('layoutready', options.ready);\n        self.cy.trigger({ type: 'layoutready', layout: self });\n      }\n    };\n\n    var ticksPerFrame = self.options.refresh;\n    var isDone;\n\n    for (var i = 0; i < ticksPerFrame && !isDone; i++) {\n      isDone = self.stopped || self.layout.tick();\n    }\n\n    // If layout is done\n    if (isDone) {\n      // If the layout is not a sublayout and it is successful perform post layout.\n      if (layout.checkLayoutSuccess() && !layout.isSubLayout) {\n        layout.doPostLayout();\n      }\n\n      // If layout has a tilingPostLayout function property call it.\n      if (layout.tilingPostLayout) {\n        layout.tilingPostLayout();\n      }\n\n      layout.isLayoutFinished = true;\n\n      self.options.eles.nodes().positions(getPositions);\n\n      afterReposition();\n\n      // trigger layoutstop when the layout stops (e.g. finishes)\n      self.cy.one('layoutstop', self.options.stop);\n      self.cy.trigger({ type: 'layoutstop', layout: self });\n\n      if (frameId) {\n        cancelAnimationFrame(frameId);\n      }\n\n      ready = false;\n      return;\n    }\n\n    var animationData = self.layout.getPositionsData(); // Get positions of layout nodes note that all nodes may not be layout nodes because of tiling\n\n    // Position nodes, for the nodes whose id does not included in data (because they are removed from their parents and included in dummy compounds)\n    // use position of their ancestors or dummy ancestors\n    options.eles.nodes().positions(function (ele, i) {\n      if (typeof ele === \"number\") {\n        ele = i;\n      }\n      // If ele is a compound node, then its position will be defined by its children\n      if (!ele.isParent()) {\n        var theId = ele.id();\n        var pNode = animationData[theId];\n        var temp = ele;\n        // If pNode is undefined search until finding position data of its first ancestor (It may be dummy as well)\n        while (pNode == null) {\n          pNode = animationData[temp.data('parent')] || animationData['DummyCompound_' + temp.data('parent')];\n          animationData[theId] = pNode;\n          temp = temp.parent()[0];\n          if (temp == undefined) {\n            break;\n          }\n        }\n        if (pNode != null) {\n          return {\n            x: pNode.x,\n            y: pNode.y\n          };\n        } else {\n          return {\n            x: ele.position('x'),\n            y: ele.position('y')\n          };\n        }\n      }\n    });\n\n    afterReposition();\n\n    frameId = requestAnimationFrame(iterateAnimated);\n  };\n\n  /*\n  * Listen 'layoutstarted' event and start animated iteration if animate option is 'during'\n  */\n  layout.addListener('layoutstarted', function () {\n    if (self.options.animate === 'during') {\n      frameId = requestAnimationFrame(iterateAnimated);\n    }\n  });\n\n  layout.runLayout(); // Run cose layout\n\n  /*\n   * If animate option is not 'during' ('end' or false) perform these here (If it is 'during' similar things are already performed)\n   */\n  if (this.options.animate !== \"during\") {\n    self.options.eles.nodes().not(\":parent\").layoutPositions(self, self.options, getPositions); // Use layout positions to reposition the nodes it considers the options parameter\n    ready = false;\n  }\n\n  return this; // chaining\n};\n\n//Get the top most ones of a list of nodes\n_CoSELayout.prototype.getTopMostNodes = function (nodes) {\n  var nodesMap = {};\n  for (var i = 0; i < nodes.length; i++) {\n    nodesMap[nodes[i].id()] = true;\n  }\n  var roots = nodes.filter(function (ele, i) {\n    if (typeof ele === \"number\") {\n      ele = i;\n    }\n    var parent = ele.parent()[0];\n    while (parent != null) {\n      if (nodesMap[parent.id()]) {\n        return false;\n      }\n      parent = parent.parent()[0];\n    }\n    return true;\n  });\n\n  return roots;\n};\n\n_CoSELayout.prototype.processChildrenList = function (parent, children, layout) {\n  var size = children.length;\n  for (var i = 0; i < size; i++) {\n    var theChild = children[i];\n    var children_of_children = theChild.children();\n    var theNode;\n\n    var dimensions = theChild.layoutDimensions({\n      nodeDimensionsIncludeLabels: this.options.nodeDimensionsIncludeLabels\n    });\n\n    if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n      theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n    } else {\n      theNode = parent.add(new CoSENode(this.graphManager));\n    }\n    // Attach id to the layout node\n    theNode.id = theChild.data(\"id\");\n    // Attach the paddings of cy node to layout node\n    theNode.paddingLeft = parseInt(theChild.css('padding'));\n    theNode.paddingTop = parseInt(theChild.css('padding'));\n    theNode.paddingRight = parseInt(theChild.css('padding'));\n    theNode.paddingBottom = parseInt(theChild.css('padding'));\n\n    //Attach the label properties to compound if labels will be included in node dimensions  \n    if (this.options.nodeDimensionsIncludeLabels) {\n      if (theChild.isParent()) {\n        var labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false }).w;\n        var labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false }).h;\n        var labelPos = theChild.css(\"text-halign\");\n        theNode.labelWidth = labelWidth;\n        theNode.labelHeight = labelHeight;\n        theNode.labelPos = labelPos;\n      }\n    }\n\n    // Map the layout node\n    this.idToLNode[theChild.data(\"id\")] = theNode;\n\n    if (isNaN(theNode.rect.x)) {\n      theNode.rect.x = 0;\n    }\n\n    if (isNaN(theNode.rect.y)) {\n      theNode.rect.y = 0;\n    }\n\n    if (children_of_children != null && children_of_children.length > 0) {\n      var theNewGraph;\n      theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n      this.processChildrenList(theNewGraph, children_of_children, layout);\n    }\n  }\n};\n\n/**\n * @brief : called on continuous layouts to stop them before they finish\n */\n_CoSELayout.prototype.stop = function () {\n  this.stopped = true;\n\n  return this; // chaining\n};\n\nvar register = function register(cytoscape) {\n  //  var Layout = getLayout( cytoscape );\n\n  cytoscape('layout', 'cose-bilkent', _CoSELayout);\n};\n\n// auto reg for globals\nif (typeof cytoscape !== 'undefined') {\n  register(cytoscape);\n}\n\nmodule.exports = register;\n\n/***/ })\n/******/ ]);\n});"],"names":["root","factory","module","this","modules","installedModules","__webpack_require__","moduleId","value","exports","name","getter","object","property","LayoutConstants","LGraphObject","IGeometry","IMath","LEdge","source","target","vEdge","prop","node","graph","otherEnd","clipPointCoordinates","vGraphObject","Integer","RectangleD","RandomSeed","PointD","LNode","gm","loc","size","vNode","width","height","upperLeft","dimension","cx","cy","x","y","dx","dy","to","edgeList","self","edge","other","neighbors","withNeighborsList","childNode","children","nodes","i","noOfChildren","randomCenterX","randomCenterY","minX","maxX","minY","maxY","childGraph","trans","left","top","leftTop","vLeftTop","pt","dim","LGraphManager","Point","LinkedList","LGraph","parent","obj2","vGraph","obj1","sourceNode","targetNode","newNode","newEdge","obj","edgesToBeRemoved","s","index","sourceIndex","targetIndex","nodeTop","nodeLeft","margin","lNode","recursive","right","bottom","nodeRight","nodeBottom","boundingRect","queue","visited","currentNode","neighborEdges","currentNeighbor","childrenOfNode","neighborEdge","childrenOfNeighbor","noOfVisitedInThisGraph","visitedNode","layout","ngraph","nnode","newGraph","parentNode","sourceGraph","targetGraph","lObj","nodesToBeRemoved","nodeList","graphs","firstNode","secondNode","ownerGraph","sourceAncestorGraph","targetAncestorGraph","edges","firstOwnerGraph","secondOwnerGraph","depth","FDLayoutConstants","rectA","rectB","overlapAmount","separationBuffer","directions","slope","moveByY","moveByX","result","p1x","p1y","p2x","p2y","topLeftAx","topLeftAy","topRightAx","bottomLeftAx","bottomLeftAy","bottomRightAx","halfWidthA","halfHeightA","topLeftBx","topLeftBy","topRightBx","bottomLeftBx","bottomLeftBy","bottomRightBx","halfWidthB","halfHeightB","clipPointAFound","clipPointBFound","slopeA","slopeB","slopePrime","cardinalDirectionA","cardinalDirectionB","tempPointAx","tempPointAy","tempPointBx","tempPointBy","line","s1","s2","f1","f2","x1","y1","x2","y2","x3","y3","x4","y4","a1","a2","b1","b2","c1","c2","denom","Cx","Cy","Nx","Ny","C_angle","p1","p2","p3","p4","a","b","c","d","p","q","r","det","lambda","gamma","_createClass","defineProperties","props","descriptor","Constructor","protoProps","staticProps","_classCallCheck","instance","nodeFrom","add","prev","next","list","_remove","vals","_this","v","val","otherNode","current","_typeof","UniqueIDGeneretor","id","arg","type","_toConsumableArray","arr","arr2","Transform","Emitter","Layout","isRemoteUse","isLayoutSuccessfull","allEdges","newLeftTop","flatForest","isForest","allNodes","isFlat","toBeVisited","parents","unProcessedNodes","temp","dummyNodes","dummyNode","dummyEdge","k","lEdge","path","ebp","sliderValue","defaultValue","minDiv","maxMul","minValue","maxValue","removedNodes","remainingDegrees","foundCenter","centerNode","degree","tempList","tempList2","neighbours","neighbour","otherDegree","newDegree","wox","woy","wex","wey","dox","doy","dex","dey","xDevice","worldExtX","yDevice","worldExtY","xWorld","deviceExtX","yWorld","deviceExtY","inPoint","outPoint","FDLayout","lcaDepth","sizeOfSourceInLca","sizeOfTargetInLca","lEdges","gridUpdateAllowed","forceToNodeSurroundingUpdate","j","nodeA","nodeB","lNodes","processedNodeSet","idealLength","length","springForce","springForceX","springForceY","clipPoints","distanceX","distanceY","distanceSquared","distance","repulsionForce","repulsionForceX","repulsionForceY","childrenConstant","ownerCenterX","ownerCenterY","absDistanceX","absDistanceY","estimatedSize","converged","oscilating","sizeX","sizeY","grid","startX","finishX","startY","finishY","surrounding","FDLayoutEdge","FDLayoutNode","_startX","_finishX","_startY","_finishY","DimensionD","HashMap","key","theId","HashSet","keys","Quicksort","A","compareFunction","NeedlemanWunsch","sequence1","sequence2","match_score","mismatch_penalty","gap_penalty","_i","_j","_i2","_j2","diag","up","maxOf","indices","inProcessAlignments","indexes","array","layoutBase","event","callback","l","data","require$$0","__WEBPACK_EXTERNAL_MODULE_0__","CoSEConstants","CoSEEdge","CoSEGraph","graphMgr","CoSEGraphManager","CoSENode","dX","dY","pred1","processed","CoSELayout","createBendsAsNeeded","intersection","forest","pData","rect","layoutEnded","multiEdge","currentStartingPoint","numberOfColumns","currentY","currentX","point","tree","startingPoint","radialSep","bounds","transform","bottomRight","parentOfNode","startAngle","endAngle","radialSeparation","halfInterval","nodeAngle","teta","x_","y_","childCount","branchCount","incEdgesCount","startIndex","stepAngle","childStartAngle","childEndAngle","maxDiagonal","diagonal","tempMemberGroups","zeroDegree","p_id","dummyCompoundId","dummyCompound","dummyParentGraph","parentGraph","childGraphMap","idToNode","tiledZeroDegreePack","compoundNode","lCompoundNode","horizontalMargin","verticalMargin","tiledPack","theChild","child","organization","compoundHorizontalMargin","compoundVerticalMargin","row","maxHeight","lnode","minWidth","verticalPadding","horizontalPadding","n1","n2","rowIndex","minCompoundSize","secondDimension","w","h","extraHeight","min","max","extraWidth","sri","hDiff","add_to_row_ratio","add_new_row_ratio","longest","last","diff","prevTotal","finalTotal","prunedNodesAll","containsLeaf","prunedNodesInStepTemp","prunedNodesInStep","lengthOfPrunedNodesInStep","nodeData","gridForPrunedNode","nodeToConnect","prunedNode","startGridX","finishGridX","startGridY","finishGridY","upNodeCount","downNodeCount","rightNodeCount","leftNodeCount","controlRegions","minCount","minIndex","random","coseBase","defaults","extend","options","_CoSELayout","_options","getUserOptions","ready","frameId","e1","getPositions","ele","iterateAnimated","afterReposition","ticksPerFrame","isDone","animationData","pNode","nodesMap","roots","children_of_children","theNode","dimensions","labelWidth","labelHeight","labelPos","theNewGraph","register","cytoscape"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,KAAC,SAA0CA,GAAMC,GAAS;AAExD,MAAAC,EAAA,UAAiBD;IAOlB,GAAEE,GAAM,WAAW;AACpB;AAAA;AAAA,QAAiB,SAASC,GAAS;AAEzB,cAAIC,IAAmB,CAAA;AAGvB,mBAASC,EAAoBC,GAAU;AAGtC,gBAAGF,EAAiBE,CAAQ;AAC3B,qBAAOF,EAAiBE,CAAQ,EAAE;AAGnC,gBAAIL,IAASG,EAAiBE,CAAQ,IAAI;AAAA;AAAA,cACzC,GAAGA;AAAA;AAAA,cACH,GAAG;AAAA;AAAA,cACH,SAAS,CAAE;AAAA;AAAA,YACvB;AAGW,mBAAAH,EAAQG,CAAQ,EAAE,KAAKL,EAAO,SAASA,GAAQA,EAAO,SAASI,CAAmB,GAGlFJ,EAAO,IAAI,IAGJA,EAAO;AAAA,UACd;AAID,iBAAAI,EAAoB,IAAIF,GAGxBE,EAAoB,IAAID,GAGxBC,EAAoB,IAAI,SAASE,GAAO;AAAE,mBAAOA;AAAA,UAAM,GAGvDF,EAAoB,IAAI,SAASG,GAASC,GAAMC,GAAQ;AACvD,YAAIL,EAAoB,EAAEG,GAASC,CAAI,KACtC,OAAO,eAAeD,GAASC,GAAM;AAAA;AAAA,cACpC,cAAc;AAAA;AAAA,cACd,YAAY;AAAA;AAAA,cACZ,KAAKC;AAAA;AAAA,YAClB,CAAa;AAAA,UAEb,GAGUL,EAAoB,IAAI,SAASJ,GAAQ;AACxC,gBAAIS,IAAST,KAAUA,EAAO;AAAA;AAAA,cAC7B,WAAsB;AAAE,uBAAOA,EAAO;AAAA,cAAa;AAAA;AAAA;AAAA,cACnD,WAA4B;AAAE,uBAAOA;AAAA;;AACtC,mBAAAI,EAAoB,EAAEK,GAAQ,KAAKA,CAAM,GAClCA;AAAA,UAClB,GAGUL,EAAoB,IAAI,SAASM,GAAQC,GAAU;AAAE,mBAAO,OAAO,UAAU,eAAe,KAAKD,GAAQC,CAAQ;AAAA,UAAE,GAGnHP,EAAoB,IAAI,IAGjBA,EAAoBA,EAAoB,IAAI,EAAE;AAAA,QACrD,EAEA;AAAA;AAAA;AAAA,UAEH,SAASJ,GAAQO,GAASH,GAAqB;AAKtD,qBAASQ,IAAkB;AAAA,YAAE;AAK7B,YAAAA,EAAgB,UAAU,GAK1BA,EAAgB,iCAAiC,IACjDA,EAAgB,sBAAsB,IACtCA,EAAgB,8BAA8B,IAC9CA,EAAgB,kCAAkC,IAClDA,EAAgB,2BAA2B,IAC3CA,EAAgB,kCAAkC,IASlDA,EAAgB,uBAAuB,IAKvCA,EAAgB,iCAAiC,IAKjDA,EAAgB,mBAAmB,IAKnCA,EAAgB,wBAAwBA,EAAgB,mBAAmB,GAM3EA,EAAgB,2BAA2B,IAK3CA,EAAgB,kBAAkB,GAKlCA,EAAgB,iBAAiB,KAKjCA,EAAgB,yBAAyBA,EAAgB,iBAAiB,KAK1EA,EAAgB,iBAAiB,MACjCA,EAAgB,iBAAiB,KAEjCZ,EAAO,UAAUY;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAASZ,GAAQO,GAASH,GAAqB;AAKtD,gBAAIS,IAAeT,EAAoB,CAAC,GACpCU,IAAYV,EAAoB,CAAC,GACjCW,IAAQX,EAAoB,CAAC;AAEjC,qBAASY,EAAMC,GAAQC,GAAQC,GAAO;AACpC,cAAAN,EAAa,KAAK,MAAMM,CAAK,GAE7B,KAAK,8BAA8B,IACnC,KAAK,eAAeA,GACpB,KAAK,aAAa,IAClB,KAAK,SAASF,GACd,KAAK,SAASC;AAAA,YACf;AAED,YAAAF,EAAM,YAAY,OAAO,OAAOH,EAAa,SAAS;AAEtD,qBAASO,KAAQP;AACf,cAAAG,EAAMI,CAAI,IAAIP,EAAaO,CAAI;AAGjC,YAAAJ,EAAM,UAAU,YAAY,WAAY;AACtC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAM,UAAU,YAAY,WAAY;AACtC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAM,UAAU,eAAe,WAAY;AACzC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAM,UAAU,YAAY,WAAY;AACtC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAM,UAAU,8BAA8B,WAAY;AACxD,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAM,UAAU,gBAAgB,WAAY;AAC1C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAM,UAAU,SAAS,WAAY;AACnC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAM,UAAU,iBAAiB,WAAY;AAC3C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAM,UAAU,iBAAiB,WAAY;AAC3C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAM,UAAU,cAAc,SAAUK,GAAM;AAC5C,kBAAI,KAAK,WAAWA;AAClB,uBAAO,KAAK;AACP,kBAAI,KAAK,WAAWA;AACzB,uBAAO,KAAK;AAEZ,oBAAM;AAAA,YAEV,GAEAL,EAAM,UAAU,qBAAqB,SAAUK,GAAMC,GAAO;AAI1D,uBAHIC,IAAW,KAAK,YAAYF,CAAI,GAChCvB,IAAOwB,EAAM,gBAAiB,EAAC,QAAO,OAE7B;AACX,oBAAIC,EAAS,SAAU,KAAID;AACzB,yBAAOC;AAGT,oBAAIA,EAAS,SAAU,KAAIzB;AACzB;AAGF,gBAAAyB,IAAWA,EAAS,SAAU,EAAC,UAAS;AAAA,cACzC;AAED,qBAAO;AAAA,YACT,GAEAP,EAAM,UAAU,eAAe,WAAY;AACzC,kBAAIQ,IAAuB,IAAI,MAAM,CAAC;AAEtC,mBAAK,8BAA8BV,EAAU,gBAAgB,KAAK,OAAO,QAAS,GAAE,KAAK,OAAO,QAAS,GAAEU,CAAoB,GAE1H,KAAK,gCACR,KAAK,UAAUA,EAAqB,CAAC,IAAIA,EAAqB,CAAC,GAC/D,KAAK,UAAUA,EAAqB,CAAC,IAAIA,EAAqB,CAAC,GAE3D,KAAK,IAAI,KAAK,OAAO,IAAI,MAC3B,KAAK,UAAUT,EAAM,KAAK,KAAK,OAAO,IAGpC,KAAK,IAAI,KAAK,OAAO,IAAI,MAC3B,KAAK,UAAUA,EAAM,KAAK,KAAK,OAAO,IAGxC,KAAK,SAAS,KAAK,KAAK,KAAK,UAAU,KAAK,UAAU,KAAK,UAAU,KAAK,OAAO;AAAA,YAErF,GAEAC,EAAM,UAAU,qBAAqB,WAAY;AAC/C,mBAAK,UAAU,KAAK,OAAO,WAAU,IAAK,KAAK,OAAO,cACtD,KAAK,UAAU,KAAK,OAAO,WAAU,IAAK,KAAK,OAAO,cAElD,KAAK,IAAI,KAAK,OAAO,IAAI,MAC3B,KAAK,UAAUD,EAAM,KAAK,KAAK,OAAO,IAGpC,KAAK,IAAI,KAAK,OAAO,IAAI,MAC3B,KAAK,UAAUA,EAAM,KAAK,KAAK,OAAO,IAGxC,KAAK,SAAS,KAAK,KAAK,KAAK,UAAU,KAAK,UAAU,KAAK,UAAU,KAAK,OAAO;AAAA,YACnF,GAEAf,EAAO,UAAUgB;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAShB,GAAQO,GAASH,GAAqB;AAKtD,qBAASS,EAAaY,GAAc;AAClC,mBAAK,eAAeA;AAAA,YACrB;AAED,YAAAzB,EAAO,UAAUa;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAASb,GAAQO,GAASH,GAAqB;AAKtD,gBAAIS,IAAeT,EAAoB,CAAC,GACpCsB,IAAUtB,EAAoB,EAAE,GAChCuB,IAAavB,EAAoB,EAAE,GACnCQ,IAAkBR,EAAoB,CAAC,GACvCwB,IAAaxB,EAAoB,EAAE,GACnCyB,IAASzB,EAAoB,CAAC;AAElC,qBAAS0B,EAAMC,GAAIC,GAAKC,GAAMC,GAAO;AAEnC,cAAID,KAAQ,QAAQC,KAAS,SAC3BA,IAAQF,IAGVnB,EAAa,KAAK,MAAMqB,CAAK,GAGzBH,EAAG,gBAAgB,SAAMA,IAAKA,EAAG,eAErC,KAAK,gBAAgBL,EAAQ,WAC7B,KAAK,qBAAqBA,EAAQ,WAClC,KAAK,eAAeQ,GACpB,KAAK,QAAQ,IACb,KAAK,eAAeH,GAEhBE,KAAQ,QAAQD,KAAO,OAAM,KAAK,OAAO,IAAIL,EAAWK,EAAI,GAAGA,EAAI,GAAGC,EAAK,OAAOA,EAAK,MAAM,IAAO,KAAK,OAAO,IAAIN;YACzH;AAED,YAAAG,EAAM,YAAY,OAAO,OAAOjB,EAAa,SAAS;AACtD,qBAASO,KAAQP;AACf,cAAAiB,EAAMV,CAAI,IAAIP,EAAaO,CAAI;AAGjC,YAAAU,EAAM,UAAU,WAAW,WAAY;AACrC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAM,UAAU,WAAW,WAAY;AACrC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAM,UAAU,WAAW,WAAY;AAOrC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAM,UAAU,WAAW,WAAY;AACrC,qBAAO,KAAK,KAAK;AAAA,YACnB,GAEAA,EAAM,UAAU,WAAW,SAAUK,GAAO;AAC1C,mBAAK,KAAK,QAAQA;AAAA,YACpB,GAEAL,EAAM,UAAU,YAAY,WAAY;AACtC,qBAAO,KAAK,KAAK;AAAA,YACnB,GAEAA,EAAM,UAAU,YAAY,SAAUM,GAAQ;AAC5C,mBAAK,KAAK,SAASA;AAAA,YACrB,GAEAN,EAAM,UAAU,aAAa,WAAY;AACvC,qBAAO,KAAK,KAAK,IAAI,KAAK,KAAK,QAAQ;AAAA,YACzC,GAEAA,EAAM,UAAU,aAAa,WAAY;AACvC,qBAAO,KAAK,KAAK,IAAI,KAAK,KAAK,SAAS;AAAA,YAC1C,GAEAA,EAAM,UAAU,YAAY,WAAY;AACtC,qBAAO,IAAID,EAAO,KAAK,KAAK,IAAI,KAAK,KAAK,QAAQ,GAAG,KAAK,KAAK,IAAI,KAAK,KAAK,SAAS,CAAC;AAAA,YACzF,GAEAC,EAAM,UAAU,cAAc,WAAY;AACxC,qBAAO,IAAID,EAAO,KAAK,KAAK,GAAG,KAAK,KAAK,CAAC;AAAA,YAC5C,GAEAC,EAAM,UAAU,UAAU,WAAY;AACpC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAM,UAAU,cAAc,WAAY;AACxC,qBAAO,KAAK,KAAK,KAAK,KAAK,QAAQ,KAAK,KAAK,QAAQ,KAAK,KAAK,SAAS,KAAK,KAAK,MAAM;AAAA,YAC1F,GAKAA,EAAM,UAAU,qBAAqB,WAAY;AAC/C,qBAAO,KAAK,KAAK,KAAK,KAAK,SAAS,KAAK,KAAK,SAAS,KAAK,KAAK,QAAQ,KAAK,KAAK,KAAK,IAAI;AAAA,YAC9F,GAEAA,EAAM,UAAU,UAAU,SAAUO,GAAWC,GAAW;AACxD,mBAAK,KAAK,IAAID,EAAU,GACxB,KAAK,KAAK,IAAIA,EAAU,GACxB,KAAK,KAAK,QAAQC,EAAU,OAC5B,KAAK,KAAK,SAASA,EAAU;AAAA,YAC/B,GAEAR,EAAM,UAAU,YAAY,SAAUS,GAAIC,GAAI;AAC5C,mBAAK,KAAK,IAAID,IAAK,KAAK,KAAK,QAAQ,GACrC,KAAK,KAAK,IAAIC,IAAK,KAAK,KAAK,SAAS;AAAA,YACxC,GAEAV,EAAM,UAAU,cAAc,SAAUW,GAAGC,GAAG;AAC5C,mBAAK,KAAK,IAAID,GACd,KAAK,KAAK,IAAIC;AAAA,YAChB,GAEAZ,EAAM,UAAU,SAAS,SAAUa,GAAIC,GAAI;AACzC,mBAAK,KAAK,KAAKD,GACf,KAAK,KAAK,KAAKC;AAAA,YACjB,GAEAd,EAAM,UAAU,oBAAoB,SAAUe,GAAI;AAChD,kBAAIC,IAAW,CAAA,GAEXC,IAAO;AAEX,qBAAAA,EAAK,MAAM,QAAQ,SAAUC,GAAM;AAEjC,oBAAIA,EAAK,UAAUH,GAAI;AACrB,sBAAIG,EAAK,UAAUD;AAAM,0BAAM;AAE/B,kBAAAD,EAAS,KAAKE,CAAI;AAAA,gBACnB;AAAA,cACL,CAAG,GAEMF;AAAA,YACT,GAEAhB,EAAM,UAAU,kBAAkB,SAAUmB,GAAO;AACjD,kBAAIH,IAAW,CAAA,GAGXC,IAAO;AACX,qBAAAA,EAAK,MAAM,QAAQ,SAAUC,GAAM;AAEjC,oBAAI,EAAEA,EAAK,UAAUD,KAAQC,EAAK,UAAUD;AAAO,wBAAM;AAEzD,iBAAIC,EAAK,UAAUC,KAASD,EAAK,UAAUC,MACzCH,EAAS,KAAKE,CAAI;AAAA,cAExB,CAAG,GAEMF;AAAA,YACT,GAEAhB,EAAM,UAAU,mBAAmB,WAAY;AAC7C,kBAAIoB,IAAY,oBAAI,OAEhBH,IAAO;AACX,qBAAAA,EAAK,MAAM,QAAQ,SAAUC,GAAM;AAEjC,oBAAIA,EAAK,UAAUD;AACjB,kBAAAG,EAAU,IAAIF,EAAK,MAAM;AAAA,qBACpB;AACL,sBAAIA,EAAK,UAAUD;AACjB,0BAAM;AAGR,kBAAAG,EAAU,IAAIF,EAAK,MAAM;AAAA,gBAC1B;AAAA,cACL,CAAG,GAEME;AAAA,YACT,GAEApB,EAAM,UAAU,eAAe,WAAY;AACzC,kBAAIqB,IAAoB,oBAAI,OACxBC,GACAC;AAIJ,kBAFAF,EAAkB,IAAI,IAAI,GAEtB,KAAK,SAAS;AAEhB,yBADIG,IAAQ,KAAK,MAAM,SAAQ,GACtBC,IAAI,GAAGA,IAAID,EAAM,QAAQC;AAChC,kBAAAH,IAAYE,EAAMC,CAAC,GACnBF,IAAWD,EAAU,gBACrBC,EAAS,QAAQ,SAAUhC,GAAM;AAC/B,oBAAA8B,EAAkB,IAAI9B,CAAI;AAAA,kBAClC,CAAO;AAIL,qBAAO8B;AAAA,YACT,GAEArB,EAAM,UAAU,kBAAkB,WAAY;AAC5C,kBAAI0B,IAAe,GACfJ;AAEJ,kBAAI,KAAK,SAAS;AAChB,gBAAAI,IAAe;AAAA;AAGf,yBADIF,IAAQ,KAAK,MAAM,SAAQ,GACtBC,IAAI,GAAGA,IAAID,EAAM,QAAQC;AAChC,kBAAAH,IAAYE,EAAMC,CAAC,GAEnBC,KAAgBJ,EAAU;AAI9B,qBAAII,KAAgB,MAClBA,IAAe,IAEVA;AAAA,YACT,GAEA1B,EAAM,UAAU,mBAAmB,WAAY;AAC7C,kBAAI,KAAK,iBAAiBJ,EAAQ;AAChC,sBAAM;AAER,qBAAO,KAAK;AAAA,YACd,GAEAI,EAAM,UAAU,oBAAoB,WAAY;AAC9C,qBAAI,KAAK,SAAS,OACT,KAAK,iBAAiB,KAAK,KAAK,QAAQ,KAAK,KAAK,UAAU,KAEnE,KAAK,gBAAgB,KAAK,MAAM,kBAAiB,GACjD,KAAK,KAAK,QAAQ,KAAK,eACvB,KAAK,KAAK,SAAS,KAAK,eAEjB,KAAK;AAAA,YAEhB,GAEAA,EAAM,UAAU,UAAU,WAAY;AACpC,kBAAI2B,GACAC,GAEAC,IAAO,CAAC/C,EAAgB,wBACxBgD,IAAOhD,EAAgB;AAC3B,cAAA6C,IAAgB7C,EAAgB,iBAAiBgB,EAAW,WAAU,KAAMgC,IAAOD,KAAQA;AAE3F,kBAAIE,IAAO,CAACjD,EAAgB,wBACxBkD,IAAOlD,EAAgB;AAC3B,cAAA8C,IAAgB9C,EAAgB,iBAAiBgB,EAAW,WAAU,KAAMkC,IAAOD,KAAQA,GAE3F,KAAK,KAAK,IAAIJ,GACd,KAAK,KAAK,IAAIC;AAAA,YAChB,GAEA5B,EAAM,UAAU,eAAe,WAAY;AACzC,kBAAI,KAAK,SAAU,KAAI;AACrB,sBAAM;AAER,kBAAI,KAAK,SAAU,EAAC,SAAQ,EAAG,UAAU,GAAG;AAE1C,oBAAIiC,IAAa,KAAK;AAUtB,oBATAA,EAAW,aAAa,EAAI,GAE5B,KAAK,KAAK,IAAIA,EAAW,QAAO,GAChC,KAAK,KAAK,IAAIA,EAAW,OAAM,GAE/B,KAAK,SAASA,EAAW,SAAU,IAAGA,EAAW,QAAO,CAAE,GAC1D,KAAK,UAAUA,EAAW,UAAW,IAAGA,EAAW,OAAM,CAAE,GAGvDnD,EAAgB,gCAAgC;AAElD,sBAAIuB,IAAQ4B,EAAW,SAAU,IAAGA,EAAW,QAAO,GAClD3B,IAAS2B,EAAW,UAAW,IAAGA,EAAW,OAAM;AAEvD,kBAAI,KAAK,aAAa5B,MACpB,KAAK,KAAK,MAAM,KAAK,aAAaA,KAAS,GAC3C,KAAK,SAAS,KAAK,UAAU,IAG3B,KAAK,cAAcC,MACjB,KAAK,YAAY,WACnB,KAAK,KAAK,MAAM,KAAK,cAAcA,KAAU,IACpC,KAAK,YAAY,UAC1B,KAAK,KAAK,KAAK,KAAK,cAAcA,IAEpC,KAAK,UAAU,KAAK,WAAW;AAAA,gBAElC;AAAA,cACF;AAAA,YACH,GAEAN,EAAM,UAAU,wBAAwB,WAAY;AAClD,kBAAI,KAAK,sBAAsBJ,EAAQ;AACrC,sBAAM;AAER,qBAAO,KAAK;AAAA,YACd,GAEAI,EAAM,UAAU,YAAY,SAAUkC,GAAO;AAC3C,kBAAIC,IAAO,KAAK,KAAK;AAErB,cAAIA,IAAOrD,EAAgB,iBACzBqD,IAAOrD,EAAgB,iBACdqD,IAAO,CAACrD,EAAgB,mBACjCqD,IAAO,CAACrD,EAAgB;AAG1B,kBAAIsD,IAAM,KAAK,KAAK;AAEpB,cAAIA,IAAMtD,EAAgB,iBACxBsD,IAAMtD,EAAgB,iBACbsD,IAAM,CAACtD,EAAgB,mBAChCsD,IAAM,CAACtD,EAAgB;AAGzB,kBAAIuD,IAAU,IAAItC,EAAOoC,GAAMC,CAAG,GAC9BE,IAAWJ,EAAM,sBAAsBG,CAAO;AAElD,mBAAK,YAAYC,EAAS,GAAGA,EAAS,CAAC;AAAA,YACzC,GAEAtC,EAAM,UAAU,UAAU,WAAY;AACpC,qBAAO,KAAK,KAAK;AAAA,YACnB,GAEAA,EAAM,UAAU,WAAW,WAAY;AACrC,qBAAO,KAAK,KAAK,IAAI,KAAK,KAAK;AAAA,YACjC,GAEAA,EAAM,UAAU,SAAS,WAAY;AACnC,qBAAO,KAAK,KAAK;AAAA,YACnB,GAEAA,EAAM,UAAU,YAAY,WAAY;AACtC,qBAAO,KAAK,KAAK,IAAI,KAAK,KAAK;AAAA,YACjC,GAEAA,EAAM,UAAU,YAAY,WAAY;AACtC,qBAAI,KAAK,SAAS,OACT,OAGF,KAAK,MAAM;YACpB,GAEA9B,EAAO,UAAU8B;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAS9B,GAAQO,GAASH,GAAqB;AAKtD,qBAASyB,EAAOY,GAAGC,GAAG;AACpB,cAAID,KAAK,QAAQC,KAAK,QACpB,KAAK,IAAI,GACT,KAAK,IAAI,MAET,KAAK,IAAID,GACT,KAAK,IAAIC;AAAA,YAEZ;AAED,YAAAb,EAAO,UAAU,OAAO,WAAY;AAClC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAO,UAAU,OAAO,WAAY;AAClC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAO,UAAU,OAAO,SAAUY,GAAG;AACnC,mBAAK,IAAIA;AAAA,YACX,GAEAZ,EAAO,UAAU,OAAO,SAAUa,GAAG;AACnC,mBAAK,IAAIA;AAAA,YACX,GAEAb,EAAO,UAAU,gBAAgB,SAAUwC,GAAI;AAC7C,qBAAO,IAAI,WAAW,KAAK,IAAIA,EAAG,GAAG,KAAK,IAAIA,EAAG,CAAC;AAAA,YACpD,GAEAxC,EAAO,UAAU,UAAU,WAAY;AACrC,qBAAO,IAAIA,EAAO,KAAK,GAAG,KAAK,CAAC;AAAA,YAClC,GAEAA,EAAO,UAAU,YAAY,SAAUyC,GAAK;AAC1C,0BAAK,KAAKA,EAAI,OACd,KAAK,KAAKA,EAAI,QACP;AAAA,YACT,GAEAtE,EAAO,UAAU6B;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAS7B,GAAQO,GAASH,GAAqB;AAKtD,gBAAIS,IAAeT,EAAoB,CAAC,GACpCsB,IAAUtB,EAAoB,EAAE,GAChCQ,IAAkBR,EAAoB,CAAC,GACvCmE,IAAgBnE,EAAoB,CAAC,GACrC0B,IAAQ1B,EAAoB,CAAC,GAC7BY,IAAQZ,EAAoB,CAAC,GAC7BuB,IAAavB,EAAoB,EAAE,GACnCoE,IAAQpE,EAAoB,EAAE,GAC9BqE,IAAarE,EAAoB,EAAE;AAEvC,qBAASsE,EAAOC,GAAQC,GAAMC,GAAQ;AACpC,cAAAhE,EAAa,KAAK,MAAMgE,CAAM,GAC9B,KAAK,gBAAgBnD,EAAQ,WAC7B,KAAK,SAASd,EAAgB,sBAC9B,KAAK,QAAQ,IACb,KAAK,QAAQ,IACb,KAAK,cAAc,IACnB,KAAK,SAAS+D,GAEVC,KAAQ,QAAQA,aAAgBL,IAClC,KAAK,eAAeK,IACXA,KAAQ,QAAQA,aAAgB,WACzC,KAAK,eAAeA,EAAK;AAAA,YAE5B;AAED,YAAAF,EAAO,YAAY,OAAO,OAAO7D,EAAa,SAAS;AACvD,qBAASO,KAAQP;AACf,cAAA6D,EAAOtD,CAAI,IAAIP,EAAaO,CAAI;AAGlC,YAAAsD,EAAO,UAAU,WAAW,WAAY;AACtC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAO,UAAU,WAAW,WAAY;AACtC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAO,UAAU,kBAAkB,WAAY;AAC7C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAO,UAAU,YAAY,WAAY;AACvC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAO,UAAU,UAAU,WAAY;AACrC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAO,UAAU,WAAW,WAAY;AACtC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAO,UAAU,SAAS,WAAY;AACpC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAO,UAAU,YAAY,WAAY;AACvC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAO,UAAU,cAAc,WAAY;AACzC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAO,UAAU,MAAM,SAAUI,GAAMC,GAAYC,GAAY;AAC7D,kBAAID,KAAc,QAAQC,KAAc,MAAM;AAC5C,oBAAIC,IAAUH;AACd,oBAAI,KAAK,gBAAgB;AACvB,wBAAM;AAER,oBAAI,KAAK,SAAU,EAAC,QAAQG,CAAO,IAAI;AACrC,wBAAM;AAER,uBAAAA,EAAQ,QAAQ,MAChB,KAAK,SAAQ,EAAG,KAAKA,CAAO,GAErBA;AAAA,cACX,OAAS;AACL,oBAAIC,IAAUJ;AACd,oBAAI,EAAE,KAAK,SAAQ,EAAG,QAAQC,CAAU,IAAI,MAAM,KAAK,SAAU,EAAC,QAAQC,CAAU,IAAI;AACtF,wBAAM;AAGR,oBAAI,EAAED,EAAW,SAASC,EAAW,SAASD,EAAW,SAAS;AAChE,wBAAM;AAGR,uBAAIA,EAAW,SAASC,EAAW,QAC1B,QAITE,EAAQ,SAASH,GACjBG,EAAQ,SAASF,GAGjBE,EAAQ,eAAe,IAGvB,KAAK,SAAQ,EAAG,KAAKA,CAAO,GAG5BH,EAAW,MAAM,KAAKG,CAAO,GAEzBF,KAAcD,KAChBC,EAAW,MAAM,KAAKE,CAAO,GAGxBA;AAAA,cACR;AAAA,YACH,GAEAR,EAAO,UAAU,SAAS,SAAUS,GAAK;AACvC,kBAAI9D,IAAO8D;AACX,kBAAIA,aAAerD,GAAO;AACxB,oBAAIT,KAAQ;AACV,wBAAM;AAER,oBAAI,EAAEA,EAAK,SAAS,QAAQA,EAAK,SAAS;AACxC,wBAAM;AAER,oBAAI,KAAK,gBAAgB;AACvB,wBAAM;AAMR,yBAHI+D,IAAmB/D,EAAK,MAAM,MAAK,GACnC2B,GACAqC,IAAID,EAAiB,QAChB7B,IAAI,GAAGA,IAAI8B,GAAG9B;AACrB,kBAAAP,IAAOoC,EAAiB7B,CAAC,GAErBP,EAAK,eACP,KAAK,aAAa,OAAOA,CAAI,IAE7BA,EAAK,OAAO,MAAM,OAAOA,CAAI;AAKjC,oBAAIsC,IAAQ,KAAK,MAAM,QAAQjE,CAAI;AACnC,oBAAIiE,KAAS;AACX,wBAAM;AAGR,qBAAK,MAAM,OAAOA,GAAO,CAAC;AAAA,cAC9B,WAAaH,aAAenE,GAAO;AAC/B,oBAAIgC,IAAOmC;AACX,oBAAInC,KAAQ;AACV,wBAAM;AAER,oBAAI,EAAEA,EAAK,UAAU,QAAQA,EAAK,UAAU;AAC1C,wBAAM;AAER,oBAAI,EAAEA,EAAK,OAAO,SAAS,QAAQA,EAAK,OAAO,SAAS,QAAQA,EAAK,OAAO,SAAS,QAAQA,EAAK,OAAO,SAAS;AAChH,wBAAM;AAGR,oBAAIuC,IAAcvC,EAAK,OAAO,MAAM,QAAQA,CAAI,GAC5CwC,IAAcxC,EAAK,OAAO,MAAM,QAAQA,CAAI;AAChD,oBAAI,EAAEuC,IAAc,MAAMC,IAAc;AACtC,wBAAM;AAGR,gBAAAxC,EAAK,OAAO,MAAM,OAAOuC,GAAa,CAAC,GAEnCvC,EAAK,UAAUA,EAAK,UACtBA,EAAK,OAAO,MAAM,OAAOwC,GAAa,CAAC;AAGzC,oBAAIF,IAAQtC,EAAK,OAAO,MAAM,WAAW,QAAQA,CAAI;AACrD,oBAAIsC,KAAS;AACX,wBAAM;AAGR,gBAAAtC,EAAK,OAAO,MAAM,SAAU,EAAC,OAAOsC,GAAO,CAAC;AAAA,cAC7C;AAAA,YACH,GAEAZ,EAAO,UAAU,gBAAgB,WAAY;AAU3C,uBATIR,IAAMxC,EAAQ,WACduC,IAAOvC,EAAQ,WACf+D,GACAC,GACAC,GAEArC,IAAQ,KAAK,YACb+B,IAAI/B,EAAM,QAELC,IAAI,GAAGA,IAAI8B,GAAG9B,KAAK;AAC1B,oBAAIqC,IAAQtC,EAAMC,CAAC;AACnB,gBAAAkC,IAAUG,EAAM,UAChBF,IAAWE,EAAM,WAEb1B,IAAMuB,MACRvB,IAAMuB,IAGJxB,IAAOyB,MACTzB,IAAOyB;AAAA,cAEV;AAGD,qBAAIxB,KAAOxC,EAAQ,YACV,QAGL4B,EAAM,CAAC,EAAE,UAAS,EAAG,eAAe,OACtCqC,IAASrC,EAAM,CAAC,EAAE,UAAS,EAAG,cAE9BqC,IAAS,KAAK,QAGhB,KAAK,OAAO1B,IAAO0B,GACnB,KAAK,MAAMzB,IAAMyB,GAGV,IAAInB,EAAM,KAAK,MAAM,KAAK,GAAG;AAAA,YACtC,GAEAE,EAAO,UAAU,eAAe,SAAUmB,GAAW;AAcnD,uBAZI5B,IAAOvC,EAAQ,WACfoE,IAAQ,CAACpE,EAAQ,WACjBwC,IAAMxC,EAAQ,WACdqE,IAAS,CAACrE,EAAQ,WAClBgE,GACAM,GACAP,GACAQ,GACAN,GAEArC,IAAQ,KAAK,OACb+B,IAAI/B,EAAM,QACLC,IAAI,GAAGA,IAAI8B,GAAG9B,KAAK;AAC1B,oBAAIqC,IAAQtC,EAAMC,CAAC;AAEnB,gBAAIsC,KAAaD,EAAM,SAAS,QAC9BA,EAAM,aAAY,GAEpBF,IAAWE,EAAM,WACjBI,IAAYJ,EAAM,YAClBH,IAAUG,EAAM,UAChBK,IAAaL,EAAM,aAEf3B,IAAOyB,MACTzB,IAAOyB,IAGLI,IAAQE,MACVF,IAAQE,IAGN9B,IAAMuB,MACRvB,IAAMuB,IAGJM,IAASE,MACXF,IAASE;AAAA,cAEZ;AAED,kBAAIC,IAAe,IAAIvE,EAAWsC,GAAMC,GAAK4B,IAAQ7B,GAAM8B,IAAS7B,CAAG;AACvE,cAAID,KAAQvC,EAAQ,cAClB,KAAK,OAAO,KAAK,OAAO,QAAO,GAC/B,KAAK,QAAQ,KAAK,OAAO,SAAQ,GACjC,KAAK,MAAM,KAAK,OAAO,OAAM,GAC7B,KAAK,SAAS,KAAK,OAAO,UAAS,IAGjC4B,EAAM,CAAC,EAAE,UAAS,EAAG,eAAe,OACtCqC,IAASrC,EAAM,CAAC,EAAE,UAAS,EAAG,cAE9BqC,IAAS,KAAK,QAGhB,KAAK,OAAOO,EAAa,IAAIP,GAC7B,KAAK,QAAQO,EAAa,IAAIA,EAAa,QAAQP,GACnD,KAAK,MAAMO,EAAa,IAAIP,GAC5B,KAAK,SAASO,EAAa,IAAIA,EAAa,SAASP;AAAA,YACvD,GAEAjB,EAAO,kBAAkB,SAAUpB,GAAO;AAYxC,uBAXIW,IAAOvC,EAAQ,WACfoE,IAAQ,CAACpE,EAAQ,WACjBwC,IAAMxC,EAAQ,WACdqE,IAAS,CAACrE,EAAQ,WAClBgE,GACAM,GACAP,GACAQ,GAEAZ,IAAI/B,EAAM,QAELC,IAAI,GAAGA,IAAI8B,GAAG9B,KAAK;AAC1B,oBAAIqC,IAAQtC,EAAMC,CAAC;AACnB,gBAAAmC,IAAWE,EAAM,WACjBI,IAAYJ,EAAM,YAClBH,IAAUG,EAAM,UAChBK,IAAaL,EAAM,aAEf3B,IAAOyB,MACTzB,IAAOyB,IAGLI,IAAQE,MACVF,IAAQE,IAGN9B,IAAMuB,MACRvB,IAAMuB,IAGJM,IAASE,MACXF,IAASE;AAAA,cAEZ;AAED,kBAAIC,IAAe,IAAIvE,EAAWsC,GAAMC,GAAK4B,IAAQ7B,GAAM8B,IAAS7B,CAAG;AAEvE,qBAAOgC;AAAA,YACT,GAEAxB,EAAO,UAAU,wBAAwB,WAAY;AACnD,qBAAI,QAAQ,KAAK,aAAa,QAAO,IAC5B,IAEA,KAAK,OAAO;YAEvB,GAEAA,EAAO,UAAU,mBAAmB,WAAY;AAC9C,kBAAI,KAAK,iBAAiBhD,EAAQ;AAChC,sBAAM;AAER,qBAAO,KAAK;AAAA,YACd,GAEAgD,EAAO,UAAU,oBAAoB,WAAY;AAK/C,uBAJIzC,IAAO,GACPqB,IAAQ,KAAK,OACb+B,IAAI/B,EAAM,QAELC,IAAI,GAAGA,IAAI8B,GAAG9B,KAAK;AAC1B,oBAAIqC,IAAQtC,EAAMC,CAAC;AACnB,gBAAAtB,KAAQ2D,EAAM;cACf;AAED,qBAAI3D,KAAQ,IACV,KAAK,gBAAgBrB,EAAgB,2BAErC,KAAK,gBAAgBqB,IAAO,KAAK,KAAK,KAAK,MAAM,MAAM,GAGlD,KAAK;AAAA,YACd,GAEAyC,EAAO,UAAU,kBAAkB,WAAY;AAC7C,kBAAI3B,IAAO;AACX,kBAAI,KAAK,MAAM,UAAU,GAAG;AAC1B,qBAAK,cAAc;AACnB;AAAA,cACD;AAED,kBAAIoD,IAAQ,IAAI1B,KACZ2B,IAAU,oBAAI,OACdC,IAAc,KAAK,MAAM,CAAC,GAC1BC,GACAC,GACAC,IAAiBH,EAAY;AAMjC,mBALAG,EAAe,QAAQ,SAAUnF,GAAM;AACrC,gBAAA8E,EAAM,KAAK9E,CAAI,GACf+E,EAAQ,IAAI/E,CAAI;AAAA,cACpB,CAAG,GAEM8E,EAAM,WAAW,KAAG;AACzB,gBAAAE,IAAcF,EAAM,SAGpBG,IAAgBD,EAAY;AAE5B,yBADIpE,IAAOqE,EAAc,QAChB/C,IAAI,GAAGA,IAAItB,GAAMsB,KAAK;AAC7B,sBAAIkD,IAAeH,EAAc/C,CAAC;AAIlC,sBAHAgD,IAAkBE,EAAa,mBAAmBJ,GAAa,IAAI,GAG/DE,KAAmB,QAAQ,CAACH,EAAQ,IAAIG,CAAe,GAAG;AAC5D,wBAAIG,IAAqBH,EAAgB;AAEzC,oBAAAG,EAAmB,QAAQ,SAAUrF,GAAM;AACzC,sBAAA8E,EAAM,KAAK9E,CAAI,GACf+E,EAAQ,IAAI/E,CAAI;AAAA,oBAC1B,CAAS;AAAA,kBACF;AAAA,gBACF;AAAA,cACF;AAID,kBAFA,KAAK,cAAc,IAEf+E,EAAQ,QAAQ,KAAK,MAAM,QAAQ;AACrC,oBAAIO,IAAyB;AAE7B,gBAAAP,EAAQ,QAAQ,SAAUQ,GAAa;AACrC,kBAAIA,EAAY,SAAS7D,KACvB4D;AAAA,gBAER,CAAK,GAEGA,KAA0B,KAAK,MAAM,WACvC,KAAK,cAAc;AAAA,cAEtB;AAAA,YACH,GAEA3G,EAAO,UAAU0E;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAS1E,GAAQO,GAASH,GAAqB;AAKtD,gBAAIsE,GACA1D,IAAQZ,EAAoB,CAAC;AAEjC,qBAASmE,EAAcsC,GAAQ;AAC7B,cAAAnC,IAAStE,EAAoB,CAAC,GAC9B,KAAK,SAASyG,GAEd,KAAK,SAAS,IACd,KAAK,QAAQ;YACd;AAED,YAAAtC,EAAc,UAAU,UAAU,WAAY;AAC5C,kBAAIuC,IAAS,KAAK,OAAO,SAAQ,GAC7BC,IAAQ,KAAK,OAAO,QAAQ,IAAI,GAChCjH,IAAO,KAAK,IAAIgH,GAAQC,CAAK;AACjC,0BAAK,aAAajH,CAAI,GACf,KAAK;AAAA,YACd,GAEAyE,EAAc,UAAU,MAAM,SAAUyC,GAAUC,GAAY/B,GAASH,GAAYC,GAAY;AAE7F,kBAAIE,KAAW,QAAQH,KAAc,QAAQC,KAAc,MAAM;AAC/D,oBAAIgC,KAAY;AACd,wBAAM;AAER,oBAAIC,KAAc;AAChB,wBAAM;AAER,oBAAI,KAAK,OAAO,QAAQD,CAAQ,IAAI;AAClC,wBAAM;AAKR,oBAFA,KAAK,OAAO,KAAKA,CAAQ,GAErBA,EAAS,UAAU;AACrB,wBAAM;AAER,oBAAIC,EAAW,SAAS;AACtB,wBAAM;AAGR,uBAAAD,EAAS,SAASC,GAClBA,EAAW,QAAQD,GAEZA;AAAA,cACX,OAAS;AAEL,gBAAAhC,IAAaE,GACbH,IAAakC,GACb/B,IAAU8B;AACV,oBAAIE,IAAcnC,EAAW,YACzBoC,IAAcnC,EAAW;AAE7B,oBAAI,EAAEkC,KAAe,QAAQA,EAAY,gBAAe,KAAM;AAC5D,wBAAM;AAER,oBAAI,EAAEC,KAAe,QAAQA,EAAY,gBAAe,KAAM;AAC5D,wBAAM;AAGR,oBAAID,KAAeC;AACjB,yBAAAjC,EAAQ,eAAe,IAChBgC,EAAY,IAAIhC,GAASH,GAAYC,CAAU;AAStD,oBAPAE,EAAQ,eAAe,IAGvBA,EAAQ,SAASH,GACjBG,EAAQ,SAASF,GAGb,KAAK,MAAM,QAAQE,CAAO,IAAI;AAChC,wBAAM;AAMR,oBAHA,KAAK,MAAM,KAAKA,CAAO,GAGnB,EAAEA,EAAQ,UAAU,QAAQA,EAAQ,UAAU;AAChD,wBAAM;AAGR,oBAAI,EAAEA,EAAQ,OAAO,MAAM,QAAQA,CAAO,KAAK,MAAMA,EAAQ,OAAO,MAAM,QAAQA,CAAO,KAAK;AAC5F,wBAAM;AAGR,uBAAAA,EAAQ,OAAO,MAAM,KAAKA,CAAO,GACjCA,EAAQ,OAAO,MAAM,KAAKA,CAAO,GAE1BA;AAAA,cAEV;AAAA,YACH,GAEAX,EAAc,UAAU,SAAS,SAAU6C,GAAM;AAC/C,kBAAIA,aAAgB1C,GAAQ;AAC1B,oBAAIpD,IAAQ8F;AACZ,oBAAI9F,EAAM,gBAAiB,KAAI;AAC7B,wBAAM;AAER,oBAAI,EAAEA,KAAS,KAAK,aAAaA,EAAM,UAAU,QAAQA,EAAM,OAAO,gBAAgB;AACpF,wBAAM;AAIR,oBAAI8D,IAAmB,CAAA;AAEvB,gBAAAA,IAAmBA,EAAiB,OAAO9D,EAAM,SAAU,CAAA;AAI3D,yBAFI0B,GACAqC,IAAID,EAAiB,QAChB7B,IAAI,GAAGA,IAAI8B,GAAG9B;AACrB,kBAAAP,IAAOoC,EAAiB7B,CAAC,GACzBjC,EAAM,OAAO0B,CAAI;AAInB,oBAAIqE,IAAmB,CAAA;AAEvB,gBAAAA,IAAmBA,EAAiB,OAAO/F,EAAM,SAAU,CAAA;AAE3D,oBAAID;AACJ,gBAAAgE,IAAIgC,EAAiB;AACrB,yBAAS9D,IAAI,GAAGA,IAAI8B,GAAG9B;AACrB,kBAAAlC,IAAOgG,EAAiB9D,CAAC,GACzBjC,EAAM,OAAOD,CAAI;AAInB,gBAAIC,KAAS,KAAK,aAChB,KAAK,aAAa,IAAI;AAIxB,oBAAIgE,IAAQ,KAAK,OAAO,QAAQhE,CAAK;AACrC,qBAAK,OAAO,OAAOgE,GAAO,CAAC,GAG3BhE,EAAM,SAAS;AAAA,cACnB,WAAa8F,aAAgBpG,GAAO;AAEhC,oBADAgC,IAAOoE,GACHpE,KAAQ;AACV,wBAAM;AAER,oBAAI,CAACA,EAAK;AACR,wBAAM;AAER,oBAAI,EAAEA,EAAK,UAAU,QAAQA,EAAK,UAAU;AAC1C,wBAAM;AAKR,oBAAI,EAAEA,EAAK,OAAO,MAAM,QAAQA,CAAI,KAAK,MAAMA,EAAK,OAAO,MAAM,QAAQA,CAAI,KAAK;AAChF,wBAAM;AAGR,oBAAIsC,IAAQtC,EAAK,OAAO,MAAM,QAAQA,CAAI;AAO1C,oBANAA,EAAK,OAAO,MAAM,OAAOsC,GAAO,CAAC,GACjCA,IAAQtC,EAAK,OAAO,MAAM,QAAQA,CAAI,GACtCA,EAAK,OAAO,MAAM,OAAOsC,GAAO,CAAC,GAI7B,EAAEtC,EAAK,OAAO,SAAS,QAAQA,EAAK,OAAO,MAAM,gBAAiB,KAAI;AACxE,wBAAM;AAER,oBAAIA,EAAK,OAAO,MAAM,gBAAe,EAAG,MAAM,QAAQA,CAAI,KAAK;AAC7D,wBAAM;AAGR,oBAAIsC,IAAQtC,EAAK,OAAO,MAAM,gBAAe,EAAG,MAAM,QAAQA,CAAI;AAClE,gBAAAA,EAAK,OAAO,MAAM,gBAAe,EAAG,MAAM,OAAOsC,GAAO,CAAC;AAAA,cAC1D;AAAA,YACH,GAEAf,EAAc,UAAU,eAAe,WAAY;AACjD,mBAAK,UAAU,aAAa,EAAI;AAAA,YAClC,GAEAA,EAAc,UAAU,YAAY,WAAY;AAC9C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAc,UAAU,cAAc,WAAY;AAChD,kBAAI,KAAK,YAAY,MAAM;AAIzB,yBAHI+C,IAAW,CAAA,GACXC,IAAS,KAAK,aACdlC,IAAIkC,EAAO,QACNhE,IAAI,GAAGA,IAAI8B,GAAG9B;AACrB,kBAAA+D,IAAWA,EAAS,OAAOC,EAAOhE,CAAC,EAAE,SAAQ,CAAE;AAEjD,qBAAK,WAAW+D;AAAA,cACjB;AACD,qBAAO,KAAK;AAAA,YACd,GAEA/C,EAAc,UAAU,gBAAgB,WAAY;AAClD,mBAAK,WAAW;AAAA,YAClB,GAEAA,EAAc,UAAU,gBAAgB,WAAY;AAClD,mBAAK,WAAW;AAAA,YAClB,GAEAA,EAAc,UAAU,kCAAkC,WAAY;AACpE,mBAAK,6BAA6B;AAAA,YACpC,GAEAA,EAAc,UAAU,cAAc,WAAY;AAChD,kBAAI,KAAK,YAAY,MAAM;AACzB,oBAAIzB,IAAW,CAAA,GACXyE,IAAS,KAAK;AACV,gBAAAA,EAAO;AACf,yBAAShE,IAAI,GAAGA,IAAIgE,EAAO,QAAQhE;AACjC,kBAAAT,IAAWA,EAAS,OAAOyE,EAAOhE,CAAC,EAAE,SAAQ,CAAE;AAGjD,gBAAAT,IAAWA,EAAS,OAAO,KAAK,KAAK,GAErC,KAAK,WAAWA;AAAA,cACjB;AACD,qBAAO,KAAK;AAAA,YACd,GAEAyB,EAAc,UAAU,gCAAgC,WAAY;AAClE,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAc,UAAU,gCAAgC,SAAU+C,GAAU;AAC1E,kBAAI,KAAK,8BAA8B;AACrC,sBAAM;AAGR,mBAAK,6BAA6BA;AAAA,YACpC,GAEA/C,EAAc,UAAU,UAAU,WAAY;AAC5C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAc,UAAU,eAAe,SAAUjD,GAAO;AACtD,kBAAIA,EAAM,gBAAiB,KAAI;AAC7B,sBAAM;AAGR,mBAAK,YAAYA,GAEbA,EAAM,UAAU,SAClBA,EAAM,SAAS,KAAK,OAAO,QAAQ,WAAW;AAAA,YAElD,GAEAiD,EAAc,UAAU,YAAY,WAAY;AAC9C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAc,UAAU,uBAAuB,SAAUiD,GAAWC,GAAY;AAC9E,kBAAI,EAAED,KAAa,QAAQC,KAAc;AACvC,sBAAM;AAGR,kBAAID,KAAaC;AACf,uBAAO;AAGT,kBAAIC,IAAaF,EAAU,YACvBP;AAEJ,iBAAG;AAGD,oBAFAA,IAAaS,EAAW,aAEpBT,KAAc;AAChB;AAGF,oBAAIA,KAAcQ;AAChB,yBAAO;AAIT,oBADAC,IAAaT,EAAW,YACpBS,KAAc;AAChB;AAAA,cAEH,SAAQ;AAET,cAAAA,IAAaD,EAAW;AAExB,iBAAG;AAGD,oBAFAR,IAAaS,EAAW,aAEpBT,KAAc;AAChB;AAGF,oBAAIA,KAAcO;AAChB,yBAAO;AAIT,oBADAE,IAAaT,EAAW,YACpBS,KAAc;AAChB;AAAA,cAEH,SAAQ;AAET,qBAAO;AAAA,YACT,GAEAnD,EAAc,UAAU,4BAA4B,WAAY;AAS9D,uBARIvB,GACA+B,GACAC,GACA2C,GACAC,GAEAC,IAAQ,KAAK,eACbxC,IAAIwC,EAAM,QACLtE,IAAI,GAAGA,IAAI8B,GAAG9B,KAAK;AAS1B,oBARAP,IAAO6E,EAAMtE,CAAC,GAEdwB,IAAa/B,EAAK,QAClBgC,IAAahC,EAAK,QAClBA,EAAK,MAAM,MACXA,EAAK,cAAc+B,GACnB/B,EAAK,cAAcgC,GAEfD,KAAcC,GAAY;AAC5B,kBAAAhC,EAAK,MAAM+B,EAAW;AACtB;AAAA,gBACD;AAID,qBAFA4C,IAAsB5C,EAAW,YAE1B/B,EAAK,OAAO,QAAM;AAIvB,uBAHAA,EAAK,cAAcgC,GACnB4C,IAAsB5C,EAAW,YAE1BhC,EAAK,OAAO,QAAM;AACvB,wBAAI4E,KAAuBD,GAAqB;AAC9C,sBAAA3E,EAAK,MAAM4E;AACX;AAAA,oBACD;AAED,wBAAIA,KAAuB,KAAK;AAC9B;AAGF,wBAAI5E,EAAK,OAAO;AACd,4BAAM;AAER,oBAAAA,EAAK,cAAc4E,EAAoB,aACvCA,IAAsB5E,EAAK,YAAY;kBACxC;AAED,sBAAI2E,KAAuB,KAAK;AAC9B;AAGF,kBAAI3E,EAAK,OAAO,SACdA,EAAK,cAAc2E,EAAoB,aACvCA,IAAsB3E,EAAK,YAAY;gBAE1C;AAED,oBAAIA,EAAK,OAAO;AACd,wBAAM;AAAA,cAET;AAAA,YACH,GAEAuB,EAAc,UAAU,2BAA2B,SAAUiD,GAAWC,GAAY;AAClF,kBAAID,KAAaC;AACf,uBAAOD,EAAU;AAEnB,kBAAIM,IAAkBN,EAAU;AAEhC,iBAAG;AACD,oBAAIM,KAAmB;AACrB;AAEF,oBAAIC,IAAmBN,EAAW;AAElC,mBAAG;AACD,sBAAIM,KAAoB;AACtB;AAGF,sBAAIA,KAAoBD;AACtB,2BAAOC;AAET,kBAAAA,IAAmBA,EAAiB,UAAW,EAAC,SAAQ;AAAA,gBACzD,SAAQ;AAET,gBAAAD,IAAkBA,EAAgB,UAAW,EAAC,SAAQ;AAAA,cACvD,SAAQ;AAET,qBAAOA;AAAA,YACT,GAEAvD,EAAc,UAAU,0BAA0B,SAAUjD,GAAO0G,GAAO;AACxE,cAAI1G,KAAS,QAAQ0G,KAAS,SAC5B1G,IAAQ,KAAK,WACb0G,IAAQ;AAMV,uBAJI3G,GAEAiC,IAAQhC,EAAM,YACd+D,IAAI/B,EAAM,QACLC,IAAI,GAAGA,IAAI8B,GAAG9B;AACrB,gBAAAlC,IAAOiC,EAAMC,CAAC,GACdlC,EAAK,qBAAqB2G,GAEtB3G,EAAK,SAAS,QAChB,KAAK,wBAAwBA,EAAK,OAAO2G,IAAQ,CAAC;AAAA,YAGxD,GAEAzD,EAAc,UAAU,sBAAsB,WAAY;AAIxD,uBAHIvB,GAEAqC,IAAI,KAAK,MAAM,QACV9B,IAAI,GAAGA,IAAI8B,GAAG9B;AAGrB,oBAFAP,IAAO,KAAK,MAAMO,CAAC,GAEf,KAAK,qBAAqBP,EAAK,QAAQA,EAAK,MAAM;AACpD,yBAAO;AAGX,qBAAO;AAAA,YACT,GAEAhD,EAAO,UAAUuE;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAASvE,GAAQO,GAASH,GAAqB;AAKtD,gBAAIQ,IAAkBR,EAAoB,CAAC;AAE3C,qBAAS6H,IAAoB;AAAA,YAAE;AAG/B,qBAAS7G,KAAQR;AACf,cAAAqH,EAAkB7G,CAAI,IAAIR,EAAgBQ,CAAI;AAGhD,YAAA6G,EAAkB,iBAAiB,MAEnCA,EAAkB,sBAAsB,IACxCA,EAAkB,0BAA0B,MAC5CA,EAAkB,6BAA6B,MAC/CA,EAAkB,2BAA2B,KAC7CA,EAAkB,oCAAoC,GACtDA,EAAkB,+BAA+B,KACjDA,EAAkB,wCAAwC,KAC1DA,EAAkB,kDAAkD,IACpEA,EAAkB,gDAAgD,IAClEA,EAAkB,qCAAqC,KACvDA,EAAkB,4BAA4B,MAC9CA,EAAkB,8BAA8B,KAChDA,EAAkB,8BAA8B,KAChDA,EAAkB,oCAAoC,KACtDA,EAAkB,wBAAwBA,EAAkB,oCAAoC,GAChGA,EAAkB,qBAAqBA,EAAkB,sBAAsB,IAC/EA,EAAkB,2BAA2B,KAC7CA,EAAkB,qCAAqC,KACvDA,EAAkB,kBAAkB,GACpCA,EAAkB,gCAAgC,IAElDjI,EAAO,UAAUiI;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAASjI,GAAQO,GAASH,GAAqB;AAYtD,gBAAIoE,IAAQpE,EAAoB,EAAE;AAElC,qBAASU,IAAY;AAAA,YAAE;AASvB,YAAAA,EAAU,uBAAuB,SAAUoH,GAAOC,GAAOC,GAAeC,GAAkB;AACxF,kBAAI,CAACH,EAAM,WAAWC,CAAK;AACzB,sBAAM;AAGR,kBAAIG,IAAa,IAAI,MAAM,CAAC;AAE5B,mBAAK,oCAAoCJ,GAAOC,GAAOG,CAAU,GAEjEF,EAAc,CAAC,IAAI,KAAK,IAAIF,EAAM,SAAQ,GAAIC,EAAM,SAAQ,CAAE,IAAI,KAAK,IAAID,EAAM,GAAGC,EAAM,CAAC,GAC3FC,EAAc,CAAC,IAAI,KAAK,IAAIF,EAAM,UAAS,GAAIC,EAAM,UAAS,CAAE,IAAI,KAAK,IAAID,EAAM,GAAGC,EAAM,CAAC,GAGzFD,EAAM,UAAUC,EAAM,KAAI,KAAMD,EAAM,SAAU,KAAIC,EAAM,aAY5DC,EAAc,CAAC,KAAK,KAAK,IAAID,EAAM,KAAM,IAAGD,EAAM,KAAI,GAAIA,EAAM,SAAU,IAAGC,EAAM,SAAQ,CAAE,IACpFA,EAAM,KAAM,KAAID,EAAM,UAAUC,EAAM,SAAQ,KAAMD,EAAM,SAAQ,MAY3EE,EAAc,CAAC,KAAK,KAAK,IAAIF,EAAM,KAAM,IAAGC,EAAM,KAAI,GAAIA,EAAM,SAAU,IAAGD,EAAM,SAAQ,CAAE,IAE3FA,EAAM,UAAUC,EAAM,KAAI,KAAMD,EAAM,UAAW,KAAIC,EAAM,cAc7DC,EAAc,CAAC,KAAK,KAAK,IAAID,EAAM,KAAM,IAAGD,EAAM,KAAI,GAAIA,EAAM,UAAW,IAAGC,EAAM,UAAS,CAAE,IACtFA,EAAM,KAAM,KAAID,EAAM,UAAUC,EAAM,UAAS,KAAMD,EAAM,UAAS,MAc7EE,EAAc,CAAC,KAAK,KAAK,IAAIF,EAAM,KAAM,IAAGC,EAAM,KAAI,GAAIA,EAAM,UAAW,IAAGD,EAAM,UAAS,CAAE;AAIjG,kBAAIK,IAAQ,KAAK,KAAKJ,EAAM,WAAU,IAAKD,EAAM,WAAY,MAAKC,EAAM,WAAU,IAAKD,EAAM,WAAY,EAAC;AAE1G,cAAIC,EAAM,iBAAiBD,EAAM,WAAU,KAAMC,EAAM,WAAY,MAAKD,EAAM,iBAE5EK,IAAQ;AAGV,kBAAIC,IAAUD,IAAQH,EAAc,CAAC,GACjCK,IAAUL,EAAc,CAAC,IAAIG;AACjC,cAAIH,EAAc,CAAC,IAAIK,IACrBA,IAAUL,EAAc,CAAC,IAEzBI,IAAUJ,EAAc,CAAC,GAI3BA,EAAc,CAAC,IAAI,KAAKE,EAAW,CAAC,KAAKG,IAAU,IAAIJ,IACvDD,EAAc,CAAC,IAAI,KAAKE,EAAW,CAAC,KAAKE,IAAU,IAAIH;AAAA,YACzD,GAUAvH,EAAU,sCAAsC,SAAUoH,GAAOC,GAAOG,GAAY;AAClF,cAAIJ,EAAM,WAAU,IAAKC,EAAM,WAAU,IACvCG,EAAW,CAAC,IAAI,KAEhBA,EAAW,CAAC,IAAI,GAGdJ,EAAM,WAAU,IAAKC,EAAM,WAAU,IACvCG,EAAW,CAAC,IAAI,KAEhBA,EAAW,CAAC,IAAI;AAAA,YAEpB,GAQAxH,EAAU,mBAAmB,SAAUoH,GAAOC,GAAOO,GAAQ;AAE3D,kBAAIC,IAAMT,EAAM,cACZU,IAAMV,EAAM,cACZW,IAAMV,EAAM,cACZW,IAAMX,EAAM;AAGhB,kBAAID,EAAM,WAAWC,CAAK;AACxB,uBAAAO,EAAO,CAAC,IAAIC,GACZD,EAAO,CAAC,IAAIE,GACZF,EAAO,CAAC,IAAIG,GACZH,EAAO,CAAC,IAAII,GACL;AAGT,kBAAIC,IAAYb,EAAM,QAClBc,IAAYd,EAAM,QAClBe,IAAaf,EAAM,YACnBgB,IAAehB,EAAM,QACrBiB,IAAejB,EAAM,aACrBkB,IAAgBlB,EAAM,YACtBmB,IAAanB,EAAM,gBACnBoB,IAAcpB,EAAM,iBAEpBqB,IAAYpB,EAAM,QAClBqB,IAAYrB,EAAM,QAClBsB,IAAatB,EAAM,YACnBuB,IAAevB,EAAM,QACrBwB,IAAexB,EAAM,aACrByB,IAAgBzB,EAAM,YACtB0B,IAAa1B,EAAM,gBACnB2B,IAAc3B,EAAM,iBAGpB4B,IAAkB,IAClBC,IAAkB;AAGtB,kBAAIrB,MAAQE,GAAK;AACf,oBAAID,IAAME;AACR,yBAAAJ,EAAO,CAAC,IAAIC,GACZD,EAAO,CAAC,IAAIM,GACZN,EAAO,CAAC,IAAIG,GACZH,EAAO,CAAC,IAAIiB,GACL;AACF,oBAAIf,IAAME;AACf,yBAAAJ,EAAO,CAAC,IAAIC,GACZD,EAAO,CAAC,IAAIS,GACZT,EAAO,CAAC,IAAIG,GACZH,EAAO,CAAC,IAAIc,GACL;AAAA,cAIV,WAEQZ,MAAQE,GAAK;AAClB,oBAAIH,IAAME;AACR,yBAAAH,EAAO,CAAC,IAAIK,GACZL,EAAO,CAAC,IAAIE,GACZF,EAAO,CAAC,IAAIe,GACZf,EAAO,CAAC,IAAII,GACL;AACF,oBAAIH,IAAME;AACf,yBAAAH,EAAO,CAAC,IAAIO,GACZP,EAAO,CAAC,IAAIE,GACZF,EAAO,CAAC,IAAIa,GACZb,EAAO,CAAC,IAAII,GACL;AAAA,cAIf,OAAW;AAEL,oBAAImB,IAAS/B,EAAM,SAASA,EAAM,OAC9BgC,IAAS/B,EAAM,SAASA,EAAM,OAG9BgC,KAAcrB,IAAMF,MAAQC,IAAMF,IAClCyB,IAAqB,QACrBC,IAAqB,QACrBC,IAAc,QACdC,IAAc,QACdC,IAAc,QACdC,IAAc;AAiDlB,oBA9CI,CAACR,MAAWE,IACVxB,IAAME,KACRH,EAAO,CAAC,IAAIQ,GACZR,EAAO,CAAC,IAAIS,GACZY,IAAkB,OAElBrB,EAAO,CAAC,IAAIO,GACZP,EAAO,CAAC,IAAIM,GACZe,IAAkB,MAEXE,MAAWE,MAChBxB,IAAME,KACRH,EAAO,CAAC,IAAIK,GACZL,EAAO,CAAC,IAAIM,GACZe,IAAkB,OAElBrB,EAAO,CAAC,IAAIU,GACZV,EAAO,CAAC,IAAIS,GACZY,IAAkB,MAKlB,CAACG,MAAWC,IACVtB,IAAMF,KACRD,EAAO,CAAC,IAAIgB,GACZhB,EAAO,CAAC,IAAIiB,GACZK,IAAkB,OAElBtB,EAAO,CAAC,IAAIe,GACZf,EAAO,CAAC,IAAIc,GACZQ,IAAkB,MAEXE,MAAWC,MAChBtB,IAAMF,KACRD,EAAO,CAAC,IAAIa,GACZb,EAAO,CAAC,IAAIc,GACZQ,IAAkB,OAElBtB,EAAO,CAAC,IAAIkB,GACZlB,EAAO,CAAC,IAAIiB,GACZK,IAAkB,MAKlBD,KAAmBC;AACrB,yBAAO;AAsBT,oBAlBIrB,IAAME,IACJD,IAAME,KACRsB,IAAqB,KAAK,qBAAqBH,GAAQE,GAAY,CAAC,GACpEE,IAAqB,KAAK,qBAAqBH,GAAQC,GAAY,CAAC,MAEpEC,IAAqB,KAAK,qBAAqB,CAACH,GAAQE,GAAY,CAAC,GACrEE,IAAqB,KAAK,qBAAqB,CAACH,GAAQC,GAAY,CAAC,KAGnEvB,IAAME,KACRsB,IAAqB,KAAK,qBAAqB,CAACH,GAAQE,GAAY,CAAC,GACrEE,IAAqB,KAAK,qBAAqB,CAACH,GAAQC,GAAY,CAAC,MAErEC,IAAqB,KAAK,qBAAqBH,GAAQE,GAAY,CAAC,GACpEE,IAAqB,KAAK,qBAAqBH,GAAQC,GAAY,CAAC,IAIpE,CAACJ;AACH,0BAAQK,GAAkB;AAAA,oBACxB,KAAK;AACH,sBAAAG,IAAcvB,GACdsB,IAAc3B,IAAM,CAACW,IAAca,GACnCzB,EAAO,CAAC,IAAI4B,GACZ5B,EAAO,CAAC,IAAI6B;AACZ;AAAA,oBACF,KAAK;AACH,sBAAAD,IAAclB,GACdmB,IAAc3B,IAAMS,IAAac,GACjCzB,EAAO,CAAC,IAAI4B,GACZ5B,EAAO,CAAC,IAAI6B;AACZ;AAAA,oBACF,KAAK;AACH,sBAAAA,IAAcpB,GACdmB,IAAc3B,IAAMW,IAAca,GAClCzB,EAAO,CAAC,IAAI4B,GACZ5B,EAAO,CAAC,IAAI6B;AACZ;AAAA,oBACF,KAAK;AACH,sBAAAD,IAAcpB,GACdqB,IAAc3B,IAAM,CAACS,IAAac,GAClCzB,EAAO,CAAC,IAAI4B,GACZ5B,EAAO,CAAC,IAAI6B;AACZ;AAAA,kBACH;AAEH,oBAAI,CAACP;AACH,0BAAQK,GAAkB;AAAA,oBACxB,KAAK;AACH,sBAAAI,IAAcjB,GACdgB,IAAc3B,IAAM,CAACiB,IAAcK,GACnCzB,EAAO,CAAC,IAAI8B,GACZ9B,EAAO,CAAC,IAAI+B;AACZ;AAAA,oBACF,KAAK;AACH,sBAAAD,IAAcZ,GACda,IAAc3B,IAAMe,IAAaM,GACjCzB,EAAO,CAAC,IAAI8B,GACZ9B,EAAO,CAAC,IAAI+B;AACZ;AAAA,oBACF,KAAK;AACH,sBAAAA,IAAcd,GACda,IAAc3B,IAAMiB,IAAcK,GAClCzB,EAAO,CAAC,IAAI8B,GACZ9B,EAAO,CAAC,IAAI+B;AACZ;AAAA,oBACF,KAAK;AACH,sBAAAD,IAAcd,GACde,IAAc3B,IAAM,CAACe,IAAaM,GAClCzB,EAAO,CAAC,IAAI8B,GACZ9B,EAAO,CAAC,IAAI+B;AACZ;AAAA,kBACH;AAAA,cAEJ;AACH,qBAAO;AAAA,YACT,GASA3J,EAAU,uBAAuB,SAAUyH,GAAO4B,GAAYO,GAAM;AAClE,qBAAInC,IAAQ4B,IACHO,IAEA,IAAIA,IAAO;AAAA,YAEtB,GAMA5J,EAAU,kBAAkB,SAAU6J,GAAIC,GAAIC,GAAIC,GAAI;AACpD,kBAAIA,KAAM;AACR,uBAAO,KAAK,iBAAiBH,GAAIC,GAAIC,CAAE;AAGzC,kBAAIE,IAAKJ,EAAG,GACRK,IAAKL,EAAG,GACRM,IAAKL,EAAG,GACRM,IAAKN,EAAG,GACRO,IAAKN,EAAG,GACRO,IAAKP,EAAG,GACRQ,IAAKP,EAAG,GACRQ,IAAKR,EAAG,GACRrI,IAAI,QACJC,IAAI,QACJ6I,IAAK,QACLC,IAAK,QACLC,IAAK,QACLC,IAAK,QACLC,IAAK,QACLC,IAAK,QACLC,IAAQ;AAYZ,qBAVAN,IAAKL,IAAKF,GACVS,IAAKV,IAAKE,GACVU,IAAKV,IAAKD,IAAKD,IAAKG,GAEpBM,IAAKF,IAAKF,GACVM,IAAKP,IAAKE,GACVO,IAAKP,IAAKD,IAAKD,IAAKG,GAEpBO,IAAQN,IAAKG,IAAKF,IAAKC,GAEnBI,MAAU,IACL,QAGTpJ,KAAKgJ,IAAKG,IAAKF,IAAKC,KAAME,GAC1BnJ,KAAK8I,IAAKG,IAAKJ,IAAKK,KAAMC,GAEnB,IAAIrH,EAAM/B,GAAGC,CAAC;AAAA,YACvB,GAMA5B,EAAU,gBAAgB,SAAUgL,GAAIC,GAAIC,GAAIC,GAAI;AAClD,kBAAIC,IAAU;AAEd,qBAAIJ,MAAOE,KACTE,IAAU,KAAK,MAAMD,IAAKF,MAAOC,IAAKF,EAAG,GAErCE,IAAKF,IACPI,KAAW,KAAK,KACPD,IAAKF,MACdG,KAAW,KAAK,WAETD,IAAKF,IACdG,IAAU,KAAK,kBAEfA,IAAU,KAAK,SAGVA;AAAA,YACT,GAOApL,EAAU,cAAc,SAAUqL,GAAIC,GAAIC,GAAIC,GAAI;AAChD,kBAAIC,IAAIJ,EAAG,GACPK,IAAIL,EAAG,GACPM,IAAIL,EAAG,GACPM,IAAIN,EAAG,GACPO,IAAIN,EAAG,GACPO,IAAIP,EAAG,GACPQ,IAAIP,EAAG,GACPjH,IAAIiH,EAAG,GACPQ,KAAOL,IAAIF,MAAMlH,IAAIuH,MAAMC,IAAIF,MAAMD,IAAIF;AAE7C,kBAAIM,MAAQ;AACV,uBAAO;AAEP,kBAAIC,MAAW1H,IAAIuH,MAAMC,IAAIN,MAAMI,IAAIE,MAAMxH,IAAImH,MAAMM,GACnDE,MAAUR,IAAIE,MAAMG,IAAIN,MAAME,IAAIF,MAAMlH,IAAImH,MAAMM;AACtD,qBAAO,IAAIC,KAAUA,IAAS,KAAK,IAAIC,KAASA,IAAQ;AAAA,YAE5D,GAQAlM,EAAU,UAAU,MAAM,KAAK,IAC/BA,EAAU,kBAAkB,MAAM,KAAK,IACvCA,EAAU,SAAS,IAAM,KAAK,IAC9BA,EAAU,WAAW,IAAM,KAAK,IAEhCd,EAAO,UAAUc;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAASd,GAAQO,GAASH,GAAqB;AAKtD,qBAASW,IAAQ;AAAA,YAAE;AAKnB,YAAAA,EAAM,OAAO,SAAUT,GAAO;AAC5B,qBAAIA,IAAQ,IACH,IACEA,IAAQ,IACV,KAEA;AAAA,YAEX,GAEAS,EAAM,QAAQ,SAAUT,GAAO;AAC7B,qBAAOA,IAAQ,IAAI,KAAK,KAAKA,CAAK,IAAI,KAAK,MAAMA,CAAK;AAAA,YACxD,GAEAS,EAAM,OAAO,SAAUT,GAAO;AAC5B,qBAAOA,IAAQ,IAAI,KAAK,MAAMA,CAAK,IAAI,KAAK,KAAKA,CAAK;AAAA,YACxD,GAEAN,EAAO,UAAUe;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAASf,GAAQO,GAASH,GAAqB;AAKtD,qBAASsB,IAAU;AAAA,YAAE;AAErB,YAAAA,EAAQ,YAAY,YACpBA,EAAQ,YAAY,aAEpB1B,EAAO,UAAU0B;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAS1B,GAAQO,GAASH,GAAqB;AAKtD,gBAAI6M,IAAe,WAAY;AAAE,uBAASC,EAAiBhM,GAAQiM,GAAO;AAAE,yBAAS5J,IAAI,GAAGA,IAAI4J,EAAM,QAAQ5J,KAAK;AAAE,sBAAI6J,IAAaD,EAAM5J,CAAC;AAAG,kBAAA6J,EAAW,aAAaA,EAAW,cAAc,IAAOA,EAAW,eAAe,IAAU,WAAWA,MAAYA,EAAW,WAAW,KAAM,OAAO,eAAelM,GAAQkM,EAAW,KAAKA,CAAU;AAAA,gBAAE;AAAA,cAAI;AAAC,qBAAO,SAAUC,GAAaC,GAAYC,GAAa;AAAE,uBAAID,KAAYJ,EAAiBG,EAAY,WAAWC,CAAU,GAAOC,KAAaL,EAAiBG,GAAaE,CAAW,GAAUF;AAAA,cAAc;AAAA,YAAG,EAAA;AAEjjB,qBAASG,EAAgBC,GAAUJ,GAAa;AAAE,kBAAI,EAAEI,aAAoBJ;AAAgB,sBAAM,IAAI,UAAU,mCAAmC;AAAA,YAAM;AAEzJ,gBAAIK,IAAW,SAAkBpN,GAAO;AACtC,qBAAO,EAAE,OAAOA,GAAO,MAAM,MAAM,MAAM;YAC3C,GAEIqN,IAAM,SAAaC,GAAMvM,GAAMwM,GAAMC,GAAM;AAC7C,qBAAIF,MAAS,OACXA,EAAK,OAAOvM,IAEZyM,EAAK,OAAOzM,GAGVwM,MAAS,OACXA,EAAK,OAAOxM,IAEZyM,EAAK,OAAOzM,GAGdA,EAAK,OAAOuM,GACZvM,EAAK,OAAOwM,GAEZC,EAAK,UAEEzM;AAAA,YACT,GAEI0M,IAAU,SAAiB1M,GAAMyM,GAAM;AACzC,kBAAIF,IAAOvM,EAAK,MACZwM,IAAOxM,EAAK;AAGhB,qBAAIuM,MAAS,OACXA,EAAK,OAAOC,IAEZC,EAAK,OAAOD,GAGVA,MAAS,OACXA,EAAK,OAAOD,IAEZE,EAAK,OAAOF,GAGdvM,EAAK,OAAOA,EAAK,OAAO,MAExByM,EAAK,UAEEzM;AAAA,YACT,GAEIoD,IAAa,WAAY;AAC3B,uBAASA,EAAWuJ,GAAM;AACxB,oBAAIC,IAAQ;AAEZ,gBAAAT,EAAgB,MAAM/I,CAAU,GAEhC,KAAK,SAAS,GACd,KAAK,OAAO,MACZ,KAAK,OAAO,MAERuJ,KAAQ,QACVA,EAAK,QAAQ,SAAUE,GAAG;AACxB,yBAAOD,EAAM,KAAKC,CAAC;AAAA,gBAC3B,CAAO;AAAA,cAEJ;AAED,qBAAAjB,EAAaxI,GAAY,CAAC;AAAA,gBACxB,KAAK;AAAA,gBACL,OAAO,WAAgB;AACrB,yBAAO,KAAK;AAAA,gBACb;AAAA,cACL,GAAK;AAAA,gBACD,KAAK;AAAA,gBACL,OAAO,SAAsB0J,GAAKC,GAAW;AAC3C,yBAAOT,EAAIS,EAAU,MAAMV,EAASS,CAAG,GAAGC,GAAW,IAAI;AAAA,gBAC1D;AAAA,cACL,GAAK;AAAA,gBACD,KAAK;AAAA,gBACL,OAAO,SAAqBD,GAAKC,GAAW;AAC1C,yBAAOT,EAAIS,GAAWV,EAASS,CAAG,GAAGC,EAAU,MAAM,IAAI;AAAA,gBAC1D;AAAA,cACL,GAAK;AAAA,gBACD,KAAK;AAAA,gBACL,OAAO,SAA0BnJ,GAASmJ,GAAW;AACnD,yBAAOT,EAAIS,EAAU,MAAMnJ,GAASmJ,GAAW,IAAI;AAAA,gBACpD;AAAA,cACL,GAAK;AAAA,gBACD,KAAK;AAAA,gBACL,OAAO,SAAyBnJ,GAASmJ,GAAW;AAClD,yBAAOT,EAAIS,GAAWnJ,GAASmJ,EAAU,MAAM,IAAI;AAAA,gBACpD;AAAA,cACL,GAAK;AAAA,gBACD,KAAK;AAAA,gBACL,OAAO,SAAcD,GAAK;AACxB,yBAAOR,EAAI,KAAK,MAAMD,EAASS,CAAG,GAAG,MAAM,IAAI;AAAA,gBAChD;AAAA,cACL,GAAK;AAAA,gBACD,KAAK;AAAA,gBACL,OAAO,SAAiBA,GAAK;AAC3B,yBAAOR,EAAI,MAAMD,EAASS,CAAG,GAAG,KAAK,MAAM,IAAI;AAAA,gBAChD;AAAA,cACL,GAAK;AAAA,gBACD,KAAK;AAAA,gBACL,OAAO,SAAgB9M,GAAM;AAC3B,yBAAO0M,EAAQ1M,GAAM,IAAI;AAAA,gBAC1B;AAAA,cACL,GAAK;AAAA,gBACD,KAAK;AAAA,gBACL,OAAO,WAAe;AACpB,yBAAO0M,EAAQ,KAAK,MAAM,IAAI,EAAE;AAAA,gBACjC;AAAA,cACL,GAAK;AAAA,gBACD,KAAK;AAAA,gBACL,OAAO,WAAmB;AACxB,yBAAOA,EAAQ,KAAK,MAAM,IAAI;AAAA,gBAC/B;AAAA,cACL,GAAK;AAAA,gBACD,KAAK;AAAA,gBACL,OAAO,WAAiB;AACtB,yBAAOA,EAAQ,KAAK,MAAM,IAAI,EAAE;AAAA,gBACjC;AAAA,cACL,GAAK;AAAA,gBACD,KAAK;AAAA,gBACL,OAAO,WAAqB;AAC1B,yBAAOA,EAAQ,KAAK,MAAM,IAAI;AAAA,gBAC/B;AAAA,cACL,GAAK;AAAA,gBACD,KAAK;AAAA,gBACL,OAAO,SAAuBzI,GAAO;AACnC,sBAAIA,KAAS,KAAK,UAAU;AAG1B,6BAFI/B,IAAI,GACJ8K,IAAU,KAAK,MACZ9K,IAAI+B;AACT,sBAAA+I,IAAUA,EAAQ,MAClB9K;AAEF,2BAAO8K,EAAQ;AAAA,kBAChB;AAAA,gBACF;AAAA,cACL,GAAK;AAAA,gBACD,KAAK;AAAA,gBACL,OAAO,SAAuB/I,GAAOhF,GAAO;AAC1C,sBAAIgF,KAAS,KAAK,UAAU;AAG1B,6BAFI/B,IAAI,GACJ8K,IAAU,KAAK,MACZ9K,IAAI+B;AACT,sBAAA+I,IAAUA,EAAQ,MAClB9K;AAEF,oBAAA8K,EAAQ,QAAQ/N;AAAA,kBACjB;AAAA,gBACF;AAAA,cACF,CAAA,CAAC,GAEKmE;AAAA,YACT;AAEA,YAAAzE,EAAO,UAAUyE;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAASzE,GAAQO,GAASH,GAAqB;AAQtD,qBAASoE,EAAM/B,GAAGC,GAAGiK,GAAG;AACtB,mBAAK,IAAI,MACT,KAAK,IAAI,MACLlK,KAAK,QAAQC,KAAK,QAAQiK,KAAK,QACjC,KAAK,IAAI,GACT,KAAK,IAAI,KACA,OAAOlK,KAAK,YAAY,OAAOC,KAAK,YAAYiK,KAAK,QAC9D,KAAK,IAAIlK,GACT,KAAK,IAAIC,KACAD,EAAE,YAAY,QAAQ,WAAWC,KAAK,QAAQiK,KAAK,SAC5DA,IAAIlK,GACJ,KAAK,IAAIkK,EAAE,GACX,KAAK,IAAIA,EAAE;AAAA,YAEd;AAED,YAAAnI,EAAM,UAAU,OAAO,WAAY;AACjC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAM,UAAU,OAAO,WAAY;AACjC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAM,UAAU,cAAc,WAAY;AACxC,qBAAO,IAAIA,EAAM,KAAK,GAAG,KAAK,CAAC;AAAA,YACjC,GAEAA,EAAM,UAAU,cAAc,SAAU/B,GAAGC,GAAGiK,GAAG;AAC/C,cAAIlK,EAAE,YAAY,QAAQ,WAAWC,KAAK,QAAQiK,KAAK,QACrDA,IAAIlK,GACJ,KAAK,YAAYkK,EAAE,GAAGA,EAAE,CAAC,KAChB,OAAOlK,KAAK,YAAY,OAAOC,KAAK,YAAYiK,KAAK,SAE1D,SAASlK,CAAC,KAAKA,KAAK,SAASC,CAAC,KAAKA,IACrC,KAAK,KAAKD,GAAGC,CAAC,KAEd,KAAK,IAAI,KAAK,MAAMD,IAAI,GAAG,GAC3B,KAAK,IAAI,KAAK,MAAMC,IAAI,GAAG;AAAA,YAGjC,GAEA8B,EAAM,UAAU,OAAO,SAAU/B,GAAGC,GAAG;AACrC,mBAAK,IAAID,GACT,KAAK,IAAIC;AAAA,YACX,GAEA8B,EAAM,UAAU,YAAY,SAAU7B,GAAIC,GAAI;AAC5C,mBAAK,KAAKD,GACV,KAAK,KAAKC;AAAA,YACZ,GAEA4B,EAAM,UAAU,SAAS,SAAUW,GAAK;AACtC,kBAAIA,EAAI,YAAY,QAAQ,SAAS;AACnC,oBAAId,IAAKc;AACT,uBAAO,KAAK,KAAKd,EAAG,KAAK,KAAK,KAAKA,EAAG;AAAA,cACvC;AACD,qBAAO,QAAQc;AAAA,YACjB,GAEAX,EAAM,UAAU,WAAW,WAAY;AACrC,qBAAO,IAAIA,EAAK,EAAG,YAAY,OAAO,QAAQ,KAAK,IAAI,QAAQ,KAAK,IAAI;AAAA,YAC1E,GAEAxE,EAAO,UAAUwE;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAASxE,GAAQO,GAASH,GAAqB;AAKtD,qBAASuB,EAAWc,GAAGC,GAAGP,GAAOC,GAAQ;AACvC,mBAAK,IAAI,GACT,KAAK,IAAI,GACT,KAAK,QAAQ,GACb,KAAK,SAAS,GAEVK,KAAK,QAAQC,KAAK,QAAQP,KAAS,QAAQC,KAAU,SACvD,KAAK,IAAIK,GACT,KAAK,IAAIC,GACT,KAAK,QAAQP,GACb,KAAK,SAASC;AAAA,YAEjB;AAED,YAAAT,EAAW,UAAU,OAAO,WAAY;AACtC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAW,UAAU,OAAO,SAAUc,GAAG;AACvC,mBAAK,IAAIA;AAAA,YACX,GAEAd,EAAW,UAAU,OAAO,WAAY;AACtC,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAW,UAAU,OAAO,SAAUe,GAAG;AACvC,mBAAK,IAAIA;AAAA,YACX,GAEAf,EAAW,UAAU,WAAW,WAAY;AAC1C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAW,UAAU,WAAW,SAAUQ,GAAO;AAC/C,mBAAK,QAAQA;AAAA,YACf,GAEAR,EAAW,UAAU,YAAY,WAAY;AAC3C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAW,UAAU,YAAY,SAAUS,GAAQ;AACjD,mBAAK,SAASA;AAAA,YAChB,GAEAT,EAAW,UAAU,WAAW,WAAY;AAC1C,qBAAO,KAAK,IAAI,KAAK;AAAA,YACvB,GAEAA,EAAW,UAAU,YAAY,WAAY;AAC3C,qBAAO,KAAK,IAAI,KAAK;AAAA,YACvB,GAEAA,EAAW,UAAU,aAAa,SAAU4K,GAAG;AAa7C,qBAZI,OAAK,aAAaA,EAAE,KAIpB,KAAK,cAAcA,EAAE,KAIrBA,EAAE,aAAa,KAAK,KAIpBA,EAAE,cAAc,KAAK;AAAA,YAK3B,GAEA5K,EAAW,UAAU,aAAa,WAAY;AAC5C,qBAAO,KAAK,IAAI,KAAK,QAAQ;AAAA,YAC/B,GAEAA,EAAW,UAAU,UAAU,WAAY;AACzC,qBAAO,KAAK;YACd,GAEAA,EAAW,UAAU,UAAU,WAAY;AACzC,qBAAO,KAAK,SAAS,KAAK;AAAA,YAC5B,GAEAA,EAAW,UAAU,aAAa,WAAY;AAC5C,qBAAO,KAAK,IAAI,KAAK,SAAS;AAAA,YAChC,GAEAA,EAAW,UAAU,UAAU,WAAY;AACzC,qBAAO,KAAK;YACd,GAEAA,EAAW,UAAU,UAAU,WAAY;AACzC,qBAAO,KAAK,SAAS,KAAK;AAAA,YAC5B,GAEAA,EAAW,UAAU,eAAe,WAAY;AAC9C,qBAAO,KAAK,QAAQ;AAAA,YACtB,GAEAA,EAAW,UAAU,gBAAgB,WAAY;AAC/C,qBAAO,KAAK,SAAS;AAAA,YACvB,GAEA3B,EAAO,UAAU2B;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAS3B,GAAQO,GAASH,GAAqB;AAKtD,gBAAIkO,IAAU,OAAO,UAAW,cAAc,OAAO,OAAO,YAAa,WAAW,SAAUnJ,GAAK;AAAE,qBAAO,OAAOA;AAAA,YAAM,IAAG,SAAUA,GAAK;AAAE,qBAAOA,KAAO,OAAO,UAAW,cAAcA,EAAI,gBAAgB,UAAUA,MAAQ,OAAO,YAAY,WAAW,OAAOA;AAAA,YAAI;AAE1Q,qBAASoJ,IAAoB;AAAA,YAAE;AAE/B,YAAAA,EAAkB,SAAS,GAE3BA,EAAkB,WAAW,SAAUpJ,GAAK;AAC1C,qBAAIoJ,EAAkB,YAAYpJ,CAAG,IAC5BA,KAELA,EAAI,YAAY,SAGpBA,EAAI,WAAWoJ,EAAkB,aACjCA,EAAkB,WACXpJ,EAAI;AAAA,YACb,GAEAoJ,EAAkB,YAAY,SAAUC,GAAI;AAC1C,qBAAIA,KAAM,SAAMA,IAAKD,EAAkB,SAChC,YAAYC;AAAA,YACrB,GAEAD,EAAkB,cAAc,SAAUE,GAAK;AAC7C,kBAAIC,IAAO,OAAOD,IAAQ,MAAc,cAAcH,EAAQG,CAAG;AACjE,qBAAOA,KAAO,QAAQC,KAAQ,YAAYA,KAAQ;AAAA,YACpD,GAEA1O,EAAO,UAAUuO;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAASvO,GAAQO,GAASH,GAAqB;AAKtD,qBAASuO,EAAmBC,GAAK;AAAE,kBAAI,MAAM,QAAQA,CAAG,GAAG;AAAE,yBAASrL,IAAI,GAAGsL,IAAO,MAAMD,EAAI,MAAM,GAAGrL,IAAIqL,EAAI,QAAQrL;AAAO,kBAAAsL,EAAKtL,CAAC,IAAIqL,EAAIrL,CAAC;AAAK,uBAAOsL;AAAA,cAAO;AAAQ,uBAAO,MAAM,KAAKD,CAAG;AAAA,YAAM;AAEnM,gBAAIhO,IAAkBR,EAAoB,CAAC,GACvCmE,IAAgBnE,EAAoB,CAAC,GACrC0B,IAAQ1B,EAAoB,CAAC,GAC7BY,IAAQZ,EAAoB,CAAC,GAC7BsE,IAAStE,EAAoB,CAAC,GAC9ByB,IAASzB,EAAoB,CAAC,GAC9B0O,IAAY1O,EAAoB,EAAE,GAClC2O,IAAU3O,EAAoB,EAAE;AAEpC,qBAAS4O,EAAOC,GAAa;AAC3B,cAAAF,EAAQ,KAAK,IAAI,GAGjB,KAAK,gBAAgBnO,EAAgB,SAErC,KAAK,sBAAsBA,EAAgB,gCAE3C,KAAK,cAAcA,EAAgB,qBAEnC,KAAK,oBAAoBA,EAAgB,6BAEzC,KAAK,wBAAwBA,EAAgB,iCAE7C,KAAK,kBAAkBA,EAAgB,0BAOvC,KAAK,uBAAuBA,EAAgB,iCAK5C,KAAK,mBAAmB,oBAAI,OAC5B,KAAK,eAAe,IAAI2D,EAAc,IAAI,GAC1C,KAAK,mBAAmB,IACxB,KAAK,cAAc,IACnB,KAAK,cAAc,IAEf0K,KAAe,SACjB,KAAK,cAAcA;AAAA,YAEtB;AAED,YAAAD,EAAO,cAAc,GAErBA,EAAO,YAAY,OAAO,OAAOD,EAAQ,SAAS,GAElDC,EAAO,UAAU,kBAAkB,WAAY;AAC7C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAO,UAAU,cAAc,WAAY;AACzC,qBAAO,KAAK,aAAa;YAC3B,GAEAA,EAAO,UAAU,cAAc,WAAY;AACzC,qBAAO,KAAK,aAAa;YAC3B,GAEAA,EAAO,UAAU,gCAAgC,WAAY;AAC3D,qBAAO,KAAK,aAAa;YAC3B,GAEAA,EAAO,UAAU,kBAAkB,WAAY;AAC7C,kBAAIjN,IAAK,IAAIwC,EAAc,IAAI;AAC/B,0BAAK,eAAexC,GACbA;AAAA,YACT,GAEAiN,EAAO,UAAU,WAAW,SAAUnK,GAAQ;AAC5C,qBAAO,IAAIH,EAAO,MAAM,KAAK,cAAcG,CAAM;AAAA,YACnD,GAEAmK,EAAO,UAAU,UAAU,SAAU9M,GAAO;AAC1C,qBAAO,IAAIJ,EAAM,KAAK,cAAcI,CAAK;AAAA,YAC3C,GAEA8M,EAAO,UAAU,UAAU,SAAU7N,GAAO;AAC1C,qBAAO,IAAIH,EAAM,MAAM,MAAMG,CAAK;AAAA,YACpC,GAEA6N,EAAO,UAAU,qBAAqB,WAAY;AAChD,qBAAO,KAAK,aAAa,QAAS,KAAI,QAAQ,KAAK,aAAa,QAAS,EAAC,SAAQ,EAAG,UAAU,KAAK,KAAK,aAAa;YACxH,GAEAA,EAAO,UAAU,YAAY,WAAY;AACvC,mBAAK,mBAAmB,IAEpB,KAAK,mBACP,KAAK,gBAAe,GAGtB,KAAK,eAAc;AACnB,kBAAIE;AAQJ,qBANI,KAAK,uBACPA,IAAsB,KAEtBA,IAAsB,KAAK,UAGzBtO,EAAgB,YAAY,WAGvB,MAGLsO,MACG,KAAK,eACR,KAAK,aAAY,IAIjB,KAAK,oBACP,KAAK,iBAAgB,GAGvB,KAAK,mBAAmB,IAEjBA;AAAA,YACT,GAKAF,EAAO,UAAU,eAAe,WAAY;AAG1C,cAAK,KAAK,eACR,KAAK,UAAS,GAEhB,KAAK,OAAM;AAAA,YACb,GAMAA,EAAO,UAAU,UAAU,WAAY;AAWrC,kBATI,KAAK,wBACP,KAAK,+BAA8B,GAGnC,KAAK,aAAa,kBAKhB,CAAC,KAAK,aAAa;AAIrB,yBADIG,IAAW,KAAK,aAAa,YAAW,GACnC5L,IAAI,GAAGA,IAAI4L,EAAS,QAAQ5L;AAC5B,kBAAA4L,EAAS5L,CAAC;AAOnB,yBADID,IAAQ,KAAK,aAAa,QAAS,EAAC,SAAQ,GACvCC,IAAI,GAAGA,IAAID,EAAM,QAAQC;AACzB,kBAAAD,EAAMC,CAAC;AAKhB,qBAAK,OAAO,KAAK,aAAa,QAAS,CAAA;AAAA,cACxC;AAAA,YACH,GAEAyL,EAAO,UAAU,SAAS,SAAU7J,GAAK;AACvC,kBAAIA,KAAO;AACT,qBAAK,QAAO;AAAA,uBACHA,aAAerD,GAAO;AAC/B,oBAAIT,IAAO8D;AACX,oBAAI9D,EAAK,SAAU,KAAI;AAGrB,2BADIiC,IAAQjC,EAAK,SAAU,EAAC,SAAQ,GAC3BkC,IAAI,GAAGA,IAAID,EAAM,QAAQC;AAChC,2BAAOD,EAAMC,CAAC,CAAC;AAOnB,oBAAIlC,EAAK,gBAAgB,MAAM;AAE7B,sBAAIa,IAAQb,EAAK;AAGjB,kBAAAa,EAAM,OAAOb,CAAI;AAAA,gBAClB;AAAA,cACL,WAAa8D,aAAenE,GAAO;AAC/B,oBAAIgC,IAAOmC;AAKX,oBAAInC,EAAK,gBAAgB,MAAM;AAE7B,sBAAI7B,IAAQ6B,EAAK;AAGjB,kBAAA7B,EAAM,OAAO6B,CAAI;AAAA,gBAClB;AAAA,cACL,WAAamC,aAAeT,GAAQ;AAChC,oBAAIpD,IAAQ6D;AAKZ,oBAAI7D,EAAM,gBAAgB,MAAM;AAE9B,sBAAIuD,IAASvD,EAAM;AAGnB,kBAAAuD,EAAO,OAAOvD,CAAK;AAAA,gBACpB;AAAA,cACF;AAAA,YACH,GAMA0N,EAAO,UAAU,iBAAiB,WAAY;AAC5C,cAAK,KAAK,gBACR,KAAK,gBAAgBpO,EAAgB,SACrC,KAAK,wBAAwBA,EAAgB,iCAC7C,KAAK,kBAAkBA,EAAgB,0BACvC,KAAK,oBAAoBA,EAAgB,6BACzC,KAAK,cAAcA,EAAgB,qBACnC,KAAK,sBAAsBA,EAAgB,gCAC3C,KAAK,uBAAuBA,EAAgB,kCAG1C,KAAK,0BACP,KAAK,oBAAoB;AAAA,YAE7B,GAEAoO,EAAO,UAAU,YAAY,SAAUI,GAAY;AACjD,kBAAIA,KAAc;AAChB,qBAAK,UAAU,IAAIvN,EAAO,GAAG,CAAC,CAAC;AAAA,mBAC1B;AAML,oBAAImC,IAAQ,IAAI8K,KACZ3K,IAAU,KAAK,aAAa,QAAS,EAAC,cAAa;AAEvD,oBAAIA,KAAW,MAAM;AACnB,kBAAAH,EAAM,aAAaoL,EAAW,CAAC,GAC/BpL,EAAM,aAAaoL,EAAW,CAAC,GAE/BpL,EAAM,cAAcG,EAAQ,CAAC,GAC7BH,EAAM,cAAcG,EAAQ,CAAC;AAK7B,2BAHIb,IAAQ,KAAK,eACbjC,GAEKkC,IAAI,GAAGA,IAAID,EAAM,QAAQC;AAChC,oBAAAlC,IAAOiC,EAAMC,CAAC,GACdlC,EAAK,UAAU2C,CAAK;AAAA,gBAEvB;AAAA,cACF;AAAA,YACH,GAEAgL,EAAO,UAAU,wBAAwB,SAAU1N,GAAO;AAExD,kBAAIA,KAAS;AAEX,qBAAK,sBAAsB,KAAK,gBAAe,EAAG,QAAS,CAAA,GAC3D,KAAK,gBAAe,EAAG,QAAS,EAAC,aAAa,EAAI;AAAA;AAMlD,yBAJIsE,GACA7B,GAEAT,IAAQhC,EAAM,YACTiC,IAAI,GAAGA,IAAID,EAAM,QAAQC;AAChC,kBAAAqC,IAAQtC,EAAMC,CAAC,GACfQ,IAAa6B,EAAM,YAEf7B,KAAc,QAEPA,EAAW,WAAW,UAAU,IADzC6B,EAAM,QAAO,KAIb,KAAK,sBAAsB7B,CAAU,GACrC6B,EAAM,aAAY;AAAA,YAI1B,GAQAoJ,EAAO,UAAU,gBAAgB,WAAY;AAW3C,uBAVIK,IAAa,CAAA,GACbC,IAAW,IAIXC,IAAW,KAAK,aAAa,QAAS,EAAC,SAAQ,GAG/CC,IAAS,IAEJjM,IAAI,GAAGA,IAAIgM,EAAS,QAAQhM;AACnC,gBAAIgM,EAAShM,CAAC,EAAE,SAAQ,KAAM,SAC5BiM,IAAS;AAKb,kBAAI,CAACA;AACH,uBAAOH;AAKT,kBAAIjJ,IAAU,oBAAI,OACdqJ,IAAc,CAAA,GACdC,IAAU,oBAAI,OACdC,IAAmB,CAAA;AAQvB,mBANAA,IAAmBA,EAAiB,OAAOJ,CAAQ,GAM5CI,EAAiB,SAAS,KAAKL,KAAU;AAK9C,qBAJAG,EAAY,KAAKE,EAAiB,CAAC,CAAC,GAI7BF,EAAY,SAAS,KAAKH,KAAU;AAEzC,sBAAIjJ,IAAcoJ,EAAY,CAAC;AAC/B,kBAAAA,EAAY,OAAO,GAAG,CAAC,GACvBrJ,EAAQ,IAAIC,CAAW;AAKvB,2BAFIC,IAAgBD,EAAY,YAEvB9C,IAAI,GAAGA,IAAI+C,EAAc,QAAQ/C,KAAK;AAC7C,wBAAIgD,IAAkBD,EAAc/C,CAAC,EAAE,YAAY8C,CAAW;AAG9D,wBAAIqJ,EAAQ,IAAIrJ,CAAW,KAAKE;AAE9B,0BAAI,CAACH,EAAQ,IAAIG,CAAe;AAC9B,wBAAAkJ,EAAY,KAAKlJ,CAAe,GAChCmJ,EAAQ,IAAInJ,GAAiBF,CAAW;AAAA,2BAMrC;AACD,wBAAAiJ,IAAW;AACX;AAAA,sBACD;AAAA,kBAEN;AAAA,gBACF;AAID,oBAAI,CAACA;AACH,kBAAAD,IAAa,CAAA;AAAA,qBAKV;AACD,sBAAIO,IAAO,CAAA,EAAG,OAAOjB,EAAmBvI,CAAO,CAAC;AAChD,kBAAAiJ,EAAW,KAAKO,CAAI;AAGpB,2BAASrM,IAAI,GAAGA,IAAIqM,EAAK,QAAQrM,KAAK;AACpC,wBAAIjD,IAAQsP,EAAKrM,CAAC,GACd+B,IAAQqK,EAAiB,QAAQrP,CAAK;AAC1C,oBAAIgF,IAAQ,MACVqK,EAAiB,OAAOrK,GAAO,CAAC;AAAA,kBAEnC;AACD,kBAAAc,IAAU,oBAAI,OACdsJ,IAAU,oBAAI;gBACf;AAAA,cACJ;AAED,qBAAOL;AAAA,YACT,GAOAL,EAAO,UAAU,gCAAgC,SAAUhM,GAAM;AAM/D,uBALI6M,IAAa,CAAA,GACbjC,IAAO5K,EAAK,QAEZ1B,IAAQ,KAAK,aAAa,yBAAyB0B,EAAK,QAAQA,EAAK,MAAM,GAEtEO,IAAI,GAAGA,IAAIP,EAAK,WAAW,QAAQO,KAAK;AAE/C,oBAAIuM,IAAY,KAAK,QAAQ,IAAI;AACjC,gBAAAA,EAAU,QAAQ,IAAI,MAAM,GAAG,CAAC,GAAG,IAAI,UAAU,GAAG,CAAC,CAAC,GAEtDxO,EAAM,IAAIwO,CAAS;AAGnB,oBAAIC,IAAY,KAAK,QAAQ,IAAI;AACjC,qBAAK,aAAa,IAAIA,GAAWnC,GAAMkC,CAAS,GAEhDD,EAAW,IAAIC,CAAS,GACxBlC,IAAOkC;AAAA,cACR;AAED,kBAAIC,IAAY,KAAK,QAAQ,IAAI;AACjC,0BAAK,aAAa,IAAIA,GAAWnC,GAAM5K,EAAK,MAAM,GAElD,KAAK,iBAAiB,IAAIA,GAAM6M,CAAU,GAGtC7M,EAAK,iBACP,KAAK,aAAa,OAAOA,CAAI,IAI3B1B,EAAM,OAAO0B,CAAI,GAGd6M;AAAA,YACT,GAMAb,EAAO,UAAU,iCAAiC,WAAY;AAC5D,kBAAInH,IAAQ,CAAA;AACZ,cAAAA,IAAQA,EAAM,OAAO,KAAK,aAAa,YAAW,CAAE,GACpDA,IAAQ,CAAE,EAAC,OAAO8G,EAAmB,KAAK,iBAAiB,MAAM,CAAC,EAAE,OAAO9G,CAAK;AAEhF,uBAASmI,IAAI,GAAGA,IAAInI,EAAM,QAAQmI,KAAK;AACrC,oBAAIC,IAAQpI,EAAMmI,CAAC;AAEnB,oBAAIC,EAAM,WAAW,SAAS,GAAG;AAG/B,2BAFIC,IAAO,KAAK,iBAAiB,IAAID,CAAK,GAEjC1M,IAAI,GAAGA,IAAI2M,EAAK,QAAQ3M,KAAK;AACpC,wBAAIuM,IAAYI,EAAK3M,CAAC,GAClBoJ,IAAI,IAAI9K,EAAOiO,EAAU,WAAU,GAAIA,EAAU,WAAU,CAAE,GAG7DK,IAAMF,EAAM,WAAW,IAAI1M,CAAC;AAChC,oBAAA4M,EAAI,IAAIxD,EAAE,GACVwD,EAAI,IAAIxD,EAAE,GAIVmD,EAAU,SAAQ,EAAG,OAAOA,CAAS;AAAA,kBACtC;AAGD,uBAAK,aAAa,IAAIG,GAAOA,EAAM,QAAQA,EAAM,MAAM;AAAA,gBACxD;AAAA,cACF;AAAA,YACH,GAEAjB,EAAO,YAAY,SAAUoB,GAAaC,GAAcC,GAAQC,GAAQ;AACtE,kBAAID,KAAU,QAAaC,KAAU,MAAW;AAC9C,oBAAIjQ,IAAQ+P;AAEZ,oBAAID,KAAe,IAAI;AACrB,sBAAII,IAAWH,IAAeC;AAC9B,kBAAAhQ,MAAU+P,IAAeG,KAAY,MAAM,KAAKJ;AAAA,gBACtD,OAAW;AACL,sBAAIK,IAAWJ,IAAeE;AAC9B,kBAAAjQ,MAAUmQ,IAAWJ,KAAgB,MAAMD,IAAc;AAAA,gBAC1D;AAED,uBAAO9P;AAAA,cACX,OAAS;AACL,oBAAIiM,GAAGC;AAEP,uBAAI4D,KAAe,MACjB7D,IAAI,IAAM8D,IAAe,KACzB7D,IAAI6D,IAAe,OAEnB9D,IAAI,IAAM8D,IAAe,IACzB7D,IAAI,KAAK6D,IAGJ9D,IAAI6D,IAAc5D;AAAA,cAC1B;AAAA,YACH,GAMAwC,EAAO,mBAAmB,SAAU1L,GAAO;AACzC,kBAAIwK,IAAO,CAAA;AACX,cAAAA,IAAOA,EAAK,OAAOxK,CAAK;AAExB,kBAAIoN,IAAe,CAAA,GACfC,IAAmB,oBAAI,OACvBC,IAAc,IACdC,IAAa;AAEjB,eAAI/C,EAAK,UAAU,KAAKA,EAAK,UAAU,OACrC8C,IAAc,IACdC,IAAa/C,EAAK,CAAC;AAGrB,uBAASvK,IAAI,GAAGA,IAAIuK,EAAK,QAAQvK,KAAK;AACpC,oBAAIlC,IAAOyM,EAAKvK,CAAC,GACbuN,IAASzP,EAAK,iBAAgB,EAAG;AACrC,gBAAAsP,EAAiB,IAAItP,GAAMA,EAAK,iBAAgB,EAAG,IAAI,GAEnDyP,KAAU,KACZJ,EAAa,KAAKrP,CAAI;AAAA,cAEzB;AAED,kBAAI0P,IAAW,CAAA;AAGf,mBAFAA,IAAWA,EAAS,OAAOL,CAAY,GAEhC,CAACE,KAAa;AACnB,oBAAII,IAAY,CAAA;AAChB,gBAAAA,IAAYA,EAAU,OAAOD,CAAQ,GACrCA,IAAW,CAAA;AAEX,yBAASxN,IAAI,GAAGA,IAAIuK,EAAK,QAAQvK,KAAK;AACpC,sBAAIlC,IAAOyM,EAAKvK,CAAC,GAEb+B,IAAQwI,EAAK,QAAQzM,CAAI;AAC7B,kBAAIiE,KAAS,KACXwI,EAAK,OAAOxI,GAAO,CAAC;AAGtB,sBAAI2L,IAAa5P,EAAK;AAEtB,kBAAA4P,EAAW,QAAQ,SAAUC,GAAW;AACtC,wBAAIR,EAAa,QAAQQ,CAAS,IAAI,GAAG;AACvC,0BAAIC,IAAcR,EAAiB,IAAIO,CAAS,GAC5CE,IAAYD,IAAc;AAE9B,sBAAIC,KAAa,KACfL,EAAS,KAAKG,CAAS,GAGzBP,EAAiB,IAAIO,GAAWE,CAAS;AAAA,oBAC1C;AAAA,kBACT,CAAO;AAAA,gBACF;AAED,gBAAAV,IAAeA,EAAa,OAAOK,CAAQ,IAEvCjD,EAAK,UAAU,KAAKA,EAAK,UAAU,OACrC8C,IAAc,IACdC,IAAa/C,EAAK,CAAC;AAAA,cAEtB;AAED,qBAAO+C;AAAA,YACT,GAMA7B,EAAO,UAAU,kBAAkB,SAAUjN,GAAI;AAC/C,mBAAK,eAAeA;AAAA,YACtB,GAEA/B,EAAO,UAAUgP;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAShP,GAAQO,GAASH,GAAqB;AAKtD,qBAASwB,IAAa;AAAA,YAAE;AAExB,YAAAA,EAAW,OAAO,GAClBA,EAAW,IAAI,GAEfA,EAAW,aAAa,WAAY;AAClC,qBAAAA,EAAW,IAAI,KAAK,IAAIA,EAAW,MAAM,IAAI,KACtCA,EAAW,IAAI,KAAK,MAAMA,EAAW,CAAC;AAAA,YAC/C,GAEA5B,EAAO,UAAU4B;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAS5B,GAAQO,GAASH,GAAqB;AAKtD,gBAAIyB,IAASzB,EAAoB,CAAC;AAElC,qBAAS0O,EAAUrM,GAAGC,GAAG;AACvB,mBAAK,aAAa,GAClB,KAAK,aAAa,GAClB,KAAK,cAAc,GACnB,KAAK,cAAc,GACnB,KAAK,aAAa,GAClB,KAAK,aAAa,GAClB,KAAK,cAAc,GACnB,KAAK,cAAc;AAAA,YACpB;AAED,YAAAoM,EAAU,UAAU,eAAe,WAAY;AAC7C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAU,UAAU,eAAe,SAAUuC,GAAK;AAChD,mBAAK,aAAaA;AAAA,YACpB,GAEAvC,EAAU,UAAU,eAAe,WAAY;AAC7C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAU,UAAU,eAAe,SAAUwC,GAAK;AAChD,mBAAK,aAAaA;AAAA,YACpB,GAEAxC,EAAU,UAAU,eAAe,WAAY;AAC7C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAU,UAAU,eAAe,SAAUyC,GAAK;AAChD,mBAAK,aAAaA;AAAA,YACpB,GAEAzC,EAAU,UAAU,eAAe,WAAY;AAC7C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAU,UAAU,eAAe,SAAU0C,GAAK;AAChD,mBAAK,aAAaA;AAAA,YACpB,GAIA1C,EAAU,UAAU,gBAAgB,WAAY;AAC9C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAU,UAAU,gBAAgB,SAAU2C,GAAK;AACjD,mBAAK,cAAcA;AAAA,YACrB,GAEA3C,EAAU,UAAU,gBAAgB,WAAY;AAC9C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAU,UAAU,gBAAgB,SAAU4C,GAAK;AACjD,mBAAK,cAAcA;AAAA,YACrB,GAEA5C,EAAU,UAAU,gBAAgB,WAAY;AAC9C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAU,UAAU,gBAAgB,SAAU6C,GAAK;AACjD,mBAAK,cAAcA;AAAA,YACrB,GAEA7C,EAAU,UAAU,gBAAgB,WAAY;AAC9C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAU,UAAU,gBAAgB,SAAU8C,GAAK;AACjD,mBAAK,cAAcA;AAAA,YACrB,GAEA9C,EAAU,UAAU,aAAa,SAAUrM,GAAG;AAC5C,kBAAIoP,IAAU,GACVC,IAAY,KAAK;AACrB,qBAAIA,KAAa,MACfD,IAAU,KAAK,eAAepP,IAAI,KAAK,cAAc,KAAK,cAAcqP,IAGnED;AAAA,YACT,GAEA/C,EAAU,UAAU,aAAa,SAAUpM,GAAG;AAC5C,kBAAIqP,IAAU,GACVC,IAAY,KAAK;AACrB,qBAAIA,KAAa,MACfD,IAAU,KAAK,eAAerP,IAAI,KAAK,cAAc,KAAK,cAAcsP,IAGnED;AAAA,YACT,GAEAjD,EAAU,UAAU,oBAAoB,SAAUrM,GAAG;AACnD,kBAAIwP,IAAS,GACTC,IAAa,KAAK;AACtB,qBAAIA,KAAc,MAChBD,IAAS,KAAK,cAAcxP,IAAI,KAAK,eAAe,KAAK,aAAayP,IAGjED;AAAA,YACT,GAEAnD,EAAU,UAAU,oBAAoB,SAAUpM,GAAG;AACnD,kBAAIyP,IAAS,GACTC,IAAa,KAAK;AACtB,qBAAIA,KAAc,MAChBD,IAAS,KAAK,cAAczP,IAAI,KAAK,eAAe,KAAK,aAAa0P,IAEjED;AAAA,YACT,GAEArD,EAAU,UAAU,wBAAwB,SAAUuD,GAAS;AAC7D,kBAAIC,IAAW,IAAIzQ,EAAO,KAAK,kBAAkBwQ,EAAQ,CAAC,GAAG,KAAK,kBAAkBA,EAAQ,CAAC,CAAC;AAC9F,qBAAOC;AAAA,YACT,GAEAtS,EAAO,UAAU8O;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAS9O,GAAQO,GAASH,GAAqB;AAKtD,qBAASuO,EAAmBC,GAAK;AAAE,kBAAI,MAAM,QAAQA,CAAG,GAAG;AAAE,yBAASrL,IAAI,GAAGsL,IAAO,MAAMD,EAAI,MAAM,GAAGrL,IAAIqL,EAAI,QAAQrL;AAAO,kBAAAsL,EAAKtL,CAAC,IAAIqL,EAAIrL,CAAC;AAAK,uBAAOsL;AAAA,cAAO;AAAQ,uBAAO,MAAM,KAAKD,CAAG;AAAA,YAAM;AAEnM,gBAAII,IAAS5O,EAAoB,EAAE,GAC/B6H,IAAoB7H,EAAoB,CAAC,GACzCQ,IAAkBR,EAAoB,CAAC,GACvCU,IAAYV,EAAoB,CAAC,GACjCW,IAAQX,EAAoB,CAAC;AAEjC,qBAASmS,IAAW;AAClB,cAAAvD,EAAO,KAAK,IAAI,GAEhB,KAAK,qCAAqC/G,EAAkB,iDAC5D,KAAK,kBAAkBA,EAAkB,qBACzC,KAAK,iBAAiBA,EAAkB,yBACxC,KAAK,oBAAoBA,EAAkB,4BAC3C,KAAK,kBAAkBA,EAAkB,0BACzC,KAAK,0BAA0BA,EAAkB,mCACjD,KAAK,qBAAqBA,EAAkB,8BAC5C,KAAK,6BAA6BA,EAAkB,uCACpD,KAAK,+BAA+B,IAAMA,EAAkB,sBAAsB,KAClF,KAAK,gBAAgBA,EAAkB,oCACvC,KAAK,uBAAuBA,EAAkB,oCAC9C,KAAK,oBAAoB,GACzB,KAAK,uBAAuB,GAC5B,KAAK,gBAAgBA,EAAkB;AAAA,YACxC;AAED,YAAAsK,EAAS,YAAY,OAAO,OAAOvD,EAAO,SAAS;AAEnD,qBAAS5N,KAAQ4N;AACf,cAAAuD,EAASnR,CAAI,IAAI4N,EAAO5N,CAAI;AAG9B,YAAAmR,EAAS,UAAU,iBAAiB,WAAY;AAC9C,cAAAvD,EAAO,UAAU,eAAe,KAAK,MAAM,SAAS,GAEpD,KAAK,kBAAkB,GACvB,KAAK,wBAAwB,GAE7B,KAAK,mBAAmB/G,EAAkB,+CAE1C,KAAK,OAAO;YACd,GAEAsK,EAAS,UAAU,uBAAuB,WAAY;AASpD,uBARIvP,GACAwP,GACAvR,GACAC,GACAuR,GACAC,GAEAvD,IAAW,KAAK,gBAAiB,EAAC,YAAW,GACxC5L,IAAI,GAAGA,IAAI4L,EAAS,QAAQ5L;AACnC,gBAAAP,IAAOmM,EAAS5L,CAAC,GAEjBP,EAAK,cAAc,KAAK,iBAEpBA,EAAK,iBACP/B,IAAS+B,EAAK,aACd9B,IAAS8B,EAAK,aAEdyP,IAAoBzP,EAAK,eAAgB,EAAC,iBAAgB,GAC1D0P,IAAoB1P,EAAK,eAAgB,EAAC,iBAAgB,GAEtD,KAAK,uCACPA,EAAK,eAAeyP,IAAoBC,IAAoB,IAAI9R,EAAgB,mBAGlF4R,IAAWxP,EAAK,OAAQ,EAAC,sBAAqB,GAE9CA,EAAK,eAAeiF,EAAkB,sBAAsBA,EAAkB,sCAAsChH,EAAO,sBAAqB,IAAKC,EAAO,sBAAuB,IAAG,IAAIsR;AAAA,YAGhM,GAEAD,EAAS,UAAU,qBAAqB,WAAY;AAElD,kBAAIlN,IAAI,KAAK,YAAW,EAAG;AAC3B,cAAI,KAAK,eACHA,IAAI4C,EAAkB,gCACxB,KAAK,gBAAgB,KAAK,IAAI,KAAK,gBAAgBA,EAAkB,2BAA2B,KAAK,iBAAiB5C,IAAI4C,EAAkB,gCAAgCA,EAAkB,8BAA8BA,EAAkB,+BAA+B,KAAK,iBAAiB,IAAIA,EAAkB,0BAA0B,IAErV,KAAK,sBAAsBA,EAAkB,sCAEzC5C,IAAI4C,EAAkB,8BACxB,KAAK,gBAAgB,KAAK,IAAIA,EAAkB,2BAA2B,KAAO5C,IAAI4C,EAAkB,gCAAgCA,EAAkB,8BAA8BA,EAAkB,gCAAgC,IAAIA,EAAkB,0BAA0B,IAE1R,KAAK,gBAAgB,GAEvB,KAAK,uBAAuB,KAAK,eACjC,KAAK,sBAAsBA,EAAkB,wBAG/C,KAAK,gBAAgB,KAAK,IAAI,KAAK,YAAa,EAAC,SAAS,GAAG,KAAK,aAAa,GAE/E,KAAK,6BAA6B,KAAK,+BAA+B,KAAK,YAAa,EAAC,QAEzF,KAAK,iBAAiB,KAAK;YAC7B,GAEAsK,EAAS,UAAU,mBAAmB,WAAY;AAIhD,uBAHII,IAAS,KAAK,eACd3P,GAEKO,IAAI,GAAGA,IAAIoP,EAAO,QAAQpP;AACjC,gBAAAP,IAAO2P,EAAOpP,CAAC,GAEf,KAAK,gBAAgBP,GAAMA,EAAK,WAAW;AAAA,YAE/C,GAEAuP,EAAS,UAAU,sBAAsB,WAAY;AACnD,kBAAIK,IAAoB,UAAU,SAAS,KAAK,UAAU,CAAC,MAAM,SAAY,UAAU,CAAC,IAAI,IACxFC,IAA+B,UAAU,SAAS,KAAK,UAAU,CAAC,MAAM,SAAY,UAAU,CAAC,IAAI,IAEnGtP,GAAGuP,GACHC,GAAOC,GACPC,IAAS,KAAK,eACdC;AAEJ,kBAAI,KAAK;AAQP,qBAPI,KAAK,kBAAkBjL,EAAkB,iCAAiC,KAAK2K,KACjF,KAAK,WAAU,GAGjBM,IAAmB,oBAAI,OAGlB3P,IAAI,GAAGA,IAAI0P,EAAO,QAAQ1P;AAC7B,kBAAAwP,IAAQE,EAAO1P,CAAC,GAChB,KAAK,+BAA+BwP,GAAOG,GAAkBN,GAAmBC,CAA4B,GAC5GK,EAAiB,IAAIH,CAAK;AAAA;AAG5B,qBAAKxP,IAAI,GAAGA,IAAI0P,EAAO,QAAQ1P;AAG7B,uBAFAwP,IAAQE,EAAO1P,CAAC,GAEXuP,IAAIvP,IAAI,GAAGuP,IAAIG,EAAO,QAAQH;AAIjC,oBAHAE,IAAQC,EAAOH,CAAC,GAGZC,EAAM,SAAQ,KAAMC,EAAM,SAAQ,KAItC,KAAK,mBAAmBD,GAAOC,CAAK;AAAA,YAI5C,GAEAT,EAAS,UAAU,0BAA0B,WAAY;AAIvD,uBAHIlR,GACA4R,IAAS,KAAK,iCAET1P,IAAI,GAAGA,IAAI0P,EAAO,QAAQ1P;AACjC,gBAAAlC,IAAO4R,EAAO1P,CAAC,GACf,KAAK,uBAAuBlC,CAAI;AAAA,YAEpC,GAEAkR,EAAS,UAAU,YAAY,WAAY;AAIzC,uBAHIU,IAAS,KAAK,eACd5R,GAEKkC,IAAI,GAAGA,IAAI0P,EAAO,QAAQ1P;AACjC,gBAAAlC,IAAO4R,EAAO1P,CAAC,GACflC,EAAK,KAAI;AAAA,YAEb,GAEAkR,EAAS,UAAU,kBAAkB,SAAUvP,GAAMmQ,GAAa;AAChE,kBAAIpO,IAAa/B,EAAK,aAClBgC,IAAahC,EAAK,aAElBoQ,GACAC,GACAC,GACAC;AAGJ,kBAAI,KAAK,wBAAwBxO,EAAW,SAAQ,KAAM,QAAQC,EAAW,SAAU,KAAI;AACzF,gBAAAhC,EAAK,mBAAkB;AAAA,uBAEvBA,EAAK,aAAY,GAEbA,EAAK;AACP;AAMJ,cAFAoQ,IAASpQ,EAAK,aAEVoQ,KAAU,MAGdC,IAAc,KAAK,kBAAkBD,IAASD,IAG9CG,IAAeD,KAAerQ,EAAK,UAAUoQ,IAC7CG,IAAeF,KAAerQ,EAAK,UAAUoQ,IAG7CrO,EAAW,gBAAgBuO,GAC3BvO,EAAW,gBAAgBwO,GAC3BvO,EAAW,gBAAgBsO,GAC3BtO,EAAW,gBAAgBuO;AAAA,YAC7B,GAEAhB,EAAS,UAAU,qBAAqB,SAAUQ,GAAOC,GAAO;AAC9D,kBAAI9K,IAAQ6K,EAAM,WACd5K,IAAQ6K,EAAM,WACd5K,IAAgB,IAAI,MAAM,CAAC,GAC3BoL,IAAa,IAAI,MAAM,CAAC,GACxBC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC;AAEJ,kBAAI7L,EAAM,WAAWC,CAAK,GACxB;AAEE,gBAAArH,EAAU,qBAAqBoH,GAAOC,GAAOC,GAAeH,EAAkB,sBAAsB,CAAG,GAEvG6L,IAAkB,IAAI1L,EAAc,CAAC,GACrC2L,IAAkB,IAAI3L,EAAc,CAAC;AAErC,oBAAI4L,IAAmBjB,EAAM,eAAeC,EAAM,gBAAgBD,EAAM,eAAeC,EAAM;AAG7F,gBAAAD,EAAM,mBAAmBiB,IAAmBF,GAC5Cf,EAAM,mBAAmBiB,IAAmBD,GAC5Cf,EAAM,mBAAmBgB,IAAmBF,GAC5Cd,EAAM,mBAAmBgB,IAAmBD;AAAA,cAC7C;AAIC,gBAAI,KAAK,wBAAwBhB,EAAM,SAAU,KAAI,QAAQC,EAAM,SAAQ,KAAM,QAE7ES,IAAYtL,EAAM,WAAY,IAAGD,EAAM,WAAU,GACjDwL,IAAYvL,EAAM,WAAY,IAAGD,EAAM,WAAU,MAGjDpH,EAAU,gBAAgBoH,GAAOC,GAAOqL,CAAU,GAElDC,IAAYD,EAAW,CAAC,IAAIA,EAAW,CAAC,GACxCE,IAAYF,EAAW,CAAC,IAAIA,EAAW,CAAC,IAIxC,KAAK,IAAIC,CAAS,IAAIxL,EAAkB,uBAC1CwL,IAAY1S,EAAM,KAAK0S,CAAS,IAAIxL,EAAkB,qBAGpD,KAAK,IAAIyL,CAAS,IAAIzL,EAAkB,uBAC1CyL,IAAY3S,EAAM,KAAK2S,CAAS,IAAIzL,EAAkB,qBAGxD0L,IAAkBF,IAAYA,IAAYC,IAAYA,GACtDE,IAAW,KAAK,KAAKD,CAAe,GAEpCE,IAAiB,KAAK,oBAAoBd,EAAM,eAAeC,EAAM,eAAeW,GAGpFG,IAAkBD,IAAiBJ,IAAYG,GAC/CG,IAAkBF,IAAiBH,IAAYE,GAG/Cb,EAAM,mBAAmBe,GACzBf,EAAM,mBAAmBgB,GACzBf,EAAM,mBAAmBc,GACzBd,EAAM,mBAAmBe;AAAA,YAE/B,GAEAxB,EAAS,UAAU,yBAAyB,SAAUlR,GAAM;AAC1D,kBAAIqG,GACAuM,GACAC,GACAT,GACAC,GACAS,GACAC,GACAC;AACJ,cAAA3M,IAAarG,EAAK,YAElB4S,KAAgBvM,EAAW,SAAQ,IAAKA,EAAW,QAAS,KAAI,GAChEwM,KAAgBxM,EAAW,OAAM,IAAKA,EAAW,UAAW,KAAI,GAChE+L,IAAYpS,EAAK,WAAY,IAAG4S,GAChCP,IAAYrS,EAAK,WAAY,IAAG6S,GAChCC,IAAe,KAAK,IAAIV,CAAS,IAAIpS,EAAK,SAAU,IAAG,GACvD+S,IAAe,KAAK,IAAIV,CAAS,IAAIrS,EAAK,UAAW,IAAG,GAEpDA,EAAK,SAAQ,KAAM,KAAK,aAAa,QAAS,KAE9CgT,IAAgB3M,EAAW,qBAAqB,KAAK,qBAEjDyM,IAAeE,KAAiBD,IAAeC,OACjDhT,EAAK,oBAAoB,CAAC,KAAK,kBAAkBoS,GACjDpS,EAAK,oBAAoB,CAAC,KAAK,kBAAkBqS,OAInDW,IAAgB3M,EAAW,qBAAqB,KAAK,6BAEjDyM,IAAeE,KAAiBD,IAAeC,OACjDhT,EAAK,oBAAoB,CAAC,KAAK,kBAAkBoS,IAAY,KAAK,yBAClEpS,EAAK,oBAAoB,CAAC,KAAK,kBAAkBqS,IAAY,KAAK;AAAA,YAG1E,GAEAnB,EAAS,UAAU,cAAc,WAAY;AAC3C,kBAAI+B,GACAC,IAAa;AAEjB,qBAAI,KAAK,kBAAkB,KAAK,gBAAgB,MAC9CA,IAAa,KAAK,IAAI,KAAK,oBAAoB,KAAK,oBAAoB,IAAI,IAG9ED,IAAY,KAAK,oBAAoB,KAAK,4BAE1C,KAAK,uBAAuB,KAAK,mBAE1BA,KAAaC;AAAA,YACtB,GAEAhC,EAAS,UAAU,UAAU,WAAY;AACvC,cAAI,KAAK,yBAAyB,CAAC,KAAK,gBAClC,KAAK,yBAAyB,KAAK,mBACrC,KAAK,OAAM,GACX,KAAK,wBAAwB,KAE7B,KAAK;AAAA,YAGX,GAGAA,EAAS,UAAU,8BAA8B,WAAY;AAI3D,uBAHIlR,GACAkO,IAAW,KAAK,aAAa,YAAW,GAEnChM,IAAI,GAAGA,IAAIgM,EAAS,QAAQhM;AACnC,gBAAAlC,IAAOkO,EAAShM,CAAC,GACjBlC,EAAK,eAAeA,EAAK;YAE7B,GAMAkR,EAAS,UAAU,WAAW,SAAUjR,GAAO;AAE7C,kBAAIkT,IAAQ,GACRC,IAAQ;AAEZ,cAAAD,IAAQ,SAAS,KAAK,MAAMlT,EAAM,aAAaA,EAAM,QAAS,KAAI,KAAK,cAAc,CAAC,GACtFmT,IAAQ,SAAS,KAAK,MAAMnT,EAAM,cAAcA,EAAM,OAAQ,KAAI,KAAK,cAAc,CAAC;AAItF,uBAFIoT,IAAO,IAAI,MAAMF,CAAK,GAEjBjR,IAAI,GAAGA,IAAIiR,GAAOjR;AACzB,gBAAAmR,EAAKnR,CAAC,IAAI,IAAI,MAAMkR,CAAK;AAG3B,uBAASlR,IAAI,GAAGA,IAAIiR,GAAOjR;AACzB,yBAASuP,IAAI,GAAGA,IAAI2B,GAAO3B;AACzB,kBAAA4B,EAAKnR,CAAC,EAAEuP,CAAC,IAAI,IAAI,MAAK;AAI1B,qBAAO4B;AAAA,YACT,GAEAnC,EAAS,UAAU,gBAAgB,SAAUrE,GAAGjK,GAAMC,GAAK;AAEzD,kBAAIyQ,IAAS,GACTC,IAAU,GACVC,IAAS,GACTC,IAAU;AAEd,cAAAH,IAAS,SAAS,KAAK,OAAOzG,EAAE,QAAS,EAAC,IAAIjK,KAAQ,KAAK,cAAc,CAAC,GAC1E2Q,IAAU,SAAS,KAAK,OAAO1G,EAAE,UAAU,QAAQA,EAAE,QAAS,EAAC,IAAIjK,KAAQ,KAAK,cAAc,CAAC,GAC/F4Q,IAAS,SAAS,KAAK,OAAO3G,EAAE,QAAS,EAAC,IAAIhK,KAAO,KAAK,cAAc,CAAC,GACzE4Q,IAAU,SAAS,KAAK,OAAO5G,EAAE,UAAU,SAASA,EAAE,QAAS,EAAC,IAAIhK,KAAO,KAAK,cAAc,CAAC;AAE/F,uBAASX,IAAIoR,GAAQpR,KAAKqR,GAASrR;AACjC,yBAASuP,IAAI+B,GAAQ/B,KAAKgC,GAAShC;AACjC,uBAAK,KAAKvP,CAAC,EAAEuP,CAAC,EAAE,KAAK5E,CAAC,GACtBA,EAAE,mBAAmByG,GAAQC,GAASC,GAAQC,CAAO;AAAA,YAG3D,GAEAvC,EAAS,UAAU,aAAa,WAAY;AAC1C,kBAAIhP,GACAwP,GACAE,IAAS,KAAK;AAKlB,mBAHA,KAAK,OAAO,KAAK,SAAS,KAAK,aAAa,QAAO,CAAE,GAGhD1P,IAAI,GAAGA,IAAI0P,EAAO,QAAQ1P;AAC7B,gBAAAwP,IAAQE,EAAO1P,CAAC,GAChB,KAAK,cAAcwP,GAAO,KAAK,aAAa,QAAS,EAAC,QAAS,GAAE,KAAK,aAAa,QAAO,EAAG,OAAQ,CAAA;AAAA,YAEzG,GAEAR,EAAS,UAAU,iCAAiC,SAAUQ,GAAOG,GAAkBN,GAAmBC,GAA8B;AAEtI,kBAAI,KAAK,kBAAkB5K,EAAkB,iCAAiC,KAAK2K,KAAqBC,GAA8B;AACpI,oBAAIkC,IAAc,oBAAI;AACtB,gBAAAhC,EAAM,cAAc,IAAI;AAIxB,yBAHIC,GACA0B,IAAO,KAAK,MAEPnR,IAAIwP,EAAM,SAAS,GAAGxP,IAAIwP,EAAM,UAAU,GAAGxP;AACpD,2BAASuP,IAAIC,EAAM,SAAS,GAAGD,IAAIC,EAAM,UAAU,GAAGD;AACpD,wBAAI,EAAEvP,IAAI,KAAKuP,IAAI,KAAKvP,KAAKmR,EAAK,UAAU5B,KAAK4B,EAAK,CAAC,EAAE;AACvD,+BAAS1E,IAAI,GAAGA,IAAI0E,EAAKnR,CAAC,EAAEuP,CAAC,EAAE,QAAQ9C;AAKrC,4BAJAgD,IAAQ0B,EAAKnR,CAAC,EAAEuP,CAAC,EAAE9C,CAAC,GAIhB,EAAA+C,EAAM,cAAcC,EAAM,SAAU,KAAID,KAASC,MAMjD,CAACE,EAAiB,IAAIF,CAAK,KAAK,CAAC+B,EAAY,IAAI/B,CAAK,GAAG;AAC3D,8BAAIS,IAAY,KAAK,IAAIV,EAAM,WAAU,IAAKC,EAAM,WAAU,CAAE,KAAKD,EAAM,SAAQ,IAAK,IAAIC,EAAM,SAAQ,IAAK,IAC3GU,IAAY,KAAK,IAAIX,EAAM,WAAU,IAAKC,EAAM,WAAU,CAAE,KAAKD,EAAM,UAAS,IAAK,IAAIC,EAAM,UAAS,IAAK;AAIjH,0BAAIS,KAAa,KAAK,kBAAkBC,KAAa,KAAK,kBAExDqB,EAAY,IAAI/B,CAAK;AAAA,wBAExB;AAAA;AAMT,gBAAAD,EAAM,cAAc,CAAE,EAAC,OAAOpE,EAAmBoG,CAAW,CAAC;AAAA,cAC9D;AACD,mBAAKxR,IAAI,GAAGA,IAAIwP,EAAM,YAAY,QAAQxP;AACxC,qBAAK,mBAAmBwP,GAAOA,EAAM,YAAYxP,CAAC,CAAC;AAAA,YAEvD,GAEAgP,EAAS,UAAU,qBAAqB,WAAY;AAClD,qBAAO;AAAA,YACT,GAEAvS,EAAO,UAAUuS;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAASvS,GAAQO,GAASH,GAAqB;AAKtD,gBAAIY,IAAQZ,EAAoB,CAAC,GAC7B6H,IAAoB7H,EAAoB,CAAC;AAE7C,qBAAS4U,EAAa/T,GAAQC,GAAQC,GAAO;AAC3C,cAAAH,EAAM,KAAK,MAAMC,GAAQC,GAAQC,CAAK,GACtC,KAAK,cAAc8G,EAAkB;AAAA,YACtC;AAED,YAAA+M,EAAa,YAAY,OAAO,OAAOhU,EAAM,SAAS;AAEtD,qBAASI,KAAQJ;AACf,cAAAgU,EAAa5T,CAAI,IAAIJ,EAAMI,CAAI;AAGjC,YAAApB,EAAO,UAAUgV;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAShV,GAAQO,GAASH,GAAqB;AAKtD,gBAAI0B,IAAQ1B,EAAoB,CAAC;AAEjC,qBAAS6U,EAAalT,GAAIC,GAAKC,GAAMC,GAAO;AAE1C,cAAAJ,EAAM,KAAK,MAAMC,GAAIC,GAAKC,GAAMC,CAAK,GAErC,KAAK,eAAe,GACpB,KAAK,eAAe,GACpB,KAAK,kBAAkB,GACvB,KAAK,kBAAkB,GACvB,KAAK,oBAAoB,GACzB,KAAK,oBAAoB,GAEzB,KAAK,gBAAgB,GACrB,KAAK,gBAAgB,GAGrB,KAAK,SAAS,GACd,KAAK,UAAU,GACf,KAAK,SAAS,GACd,KAAK,UAAU,GAGf,KAAK,cAAc;YACpB;AAED,YAAA+S,EAAa,YAAY,OAAO,OAAOnT,EAAM,SAAS;AAEtD,qBAASV,KAAQU;AACf,cAAAmT,EAAa7T,CAAI,IAAIU,EAAMV,CAAI;AAGjC,YAAA6T,EAAa,UAAU,qBAAqB,SAAUC,GAASC,GAAUC,GAASC,GAAU;AAC1F,mBAAK,SAASH,GACd,KAAK,UAAUC,GACf,KAAK,SAASC,GACd,KAAK,UAAUC;AAAA,YACjB,GAEArV,EAAO,UAAUiV;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAASjV,GAAQO,GAASH,GAAqB;AAKtD,qBAASkV,EAAWnT,GAAOC,GAAQ;AACjC,mBAAK,QAAQ,GACb,KAAK,SAAS,GACVD,MAAU,QAAQC,MAAW,SAC/B,KAAK,SAASA,GACd,KAAK,QAAQD;AAAA,YAEhB;AAED,YAAAmT,EAAW,UAAU,WAAW,WAAY;AAC1C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAW,UAAU,WAAW,SAAUnT,GAAO;AAC/C,mBAAK,QAAQA;AAAA,YACf,GAEAmT,EAAW,UAAU,YAAY,WAAY;AAC3C,qBAAO,KAAK;AAAA,YACd,GAEAA,EAAW,UAAU,YAAY,SAAUlT,GAAQ;AACjD,mBAAK,SAASA;AAAA,YAChB,GAEApC,EAAO,UAAUsV;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAStV,GAAQO,GAASH,GAAqB;AAKtD,gBAAImO,IAAoBnO,EAAoB,EAAE;AAE9C,qBAASmV,IAAU;AACjB,mBAAK,MAAM,IACX,KAAK,OAAO;YACb;AAED,YAAAA,EAAQ,UAAU,MAAM,SAAUC,GAAKlV,GAAO;AAC5C,kBAAImV,IAAQlH,EAAkB,SAASiH,CAAG;AAC1C,cAAK,KAAK,SAASC,CAAK,MACtB,KAAK,IAAIA,CAAK,IAAInV,GAClB,KAAK,KAAK,KAAKkV,CAAG;AAAA,YAEtB,GAEAD,EAAQ,UAAU,WAAW,SAAUC,GAAK;AAC9B,qBAAAjH,EAAkB,SAASiH,CAAG,GACnC,KAAK,IAAIA,CAAG,KAAK;AAAA,YAC1B,GAEAD,EAAQ,UAAU,MAAM,SAAUC,GAAK;AACrC,kBAAIC,IAAQlH,EAAkB,SAASiH,CAAG;AAC1C,qBAAO,KAAK,IAAIC,CAAK;AAAA,YACvB,GAEAF,EAAQ,UAAU,SAAS,WAAY;AACrC,qBAAO,KAAK;AAAA,YACd,GAEAvV,EAAO,UAAUuV;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAASvV,GAAQO,GAASH,GAAqB;AAKtD,gBAAImO,IAAoBnO,EAAoB,EAAE;AAE9C,qBAASsV,IAAU;AACjB,mBAAK,MAAM;YACZ;AAGD,YAAAA,EAAQ,UAAU,MAAM,SAAUvQ,GAAK;AACrC,kBAAIsQ,IAAQlH,EAAkB,SAASpJ,CAAG;AAC1C,cAAK,KAAK,SAASsQ,CAAK,MAAG,KAAK,IAAIA,CAAK,IAAItQ;AAAA,YAC/C,GAEAuQ,EAAQ,UAAU,SAAS,SAAUvQ,GAAK;AACxC,qBAAO,KAAK,IAAIoJ,EAAkB,SAASpJ,CAAG,CAAC;AAAA,YACjD,GAEAuQ,EAAQ,UAAU,QAAQ,WAAY;AACpC,mBAAK,MAAM;YACb,GAEAA,EAAQ,UAAU,WAAW,SAAUvQ,GAAK;AAC1C,qBAAO,KAAK,IAAIoJ,EAAkB,SAASpJ,CAAG,CAAC,KAAKA;AAAA,YACtD,GAEAuQ,EAAQ,UAAU,UAAU,WAAY;AACtC,qBAAO,KAAK,KAAM,MAAK;AAAA,YACzB,GAEAA,EAAQ,UAAU,OAAO,WAAY;AACnC,qBAAO,OAAO,KAAK,KAAK,GAAG,EAAE;AAAA,YAC/B,GAGAA,EAAQ,UAAU,WAAW,SAAU5H,GAAM;AAG3C,uBAFI6H,IAAO,OAAO,KAAK,KAAK,GAAG,GAC3BvC,IAASuC,EAAK,QACTpS,IAAI,GAAGA,IAAI6P,GAAQ7P;AAC1B,gBAAAuK,EAAK,KAAK,KAAK,IAAI6H,EAAKpS,CAAC,CAAC,CAAC;AAAA,YAE/B,GAEAmS,EAAQ,UAAU,OAAO,WAAY;AACnC,qBAAO,OAAO,KAAK,KAAK,GAAG,EAAE;AAAA,YAC/B,GAEAA,EAAQ,UAAU,SAAS,SAAU5H,GAAM;AAEzC,uBADIzI,IAAIyI,EAAK,QACJvK,IAAI,GAAGA,IAAI8B,GAAG9B,KAAK;AAC1B,oBAAI2K,IAAIJ,EAAKvK,CAAC;AACd,qBAAK,IAAI2K,CAAC;AAAA,cACX;AAAA,YACH,GAEAlO,EAAO,UAAU0V;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAS1V,GAAQO,GAASH,GAAqB;AAKtD,gBAAI6M,IAAe,WAAY;AAAE,uBAASC,EAAiBhM,GAAQiM,GAAO;AAAE,yBAAS5J,IAAI,GAAGA,IAAI4J,EAAM,QAAQ5J,KAAK;AAAE,sBAAI6J,IAAaD,EAAM5J,CAAC;AAAG,kBAAA6J,EAAW,aAAaA,EAAW,cAAc,IAAOA,EAAW,eAAe,IAAU,WAAWA,MAAYA,EAAW,WAAW,KAAM,OAAO,eAAelM,GAAQkM,EAAW,KAAKA,CAAU;AAAA,gBAAE;AAAA,cAAI;AAAC,qBAAO,SAAUC,GAAaC,GAAYC,GAAa;AAAE,uBAAID,KAAYJ,EAAiBG,EAAY,WAAWC,CAAU,GAAOC,KAAaL,EAAiBG,GAAaE,CAAW,GAAUF;AAAA,cAAc;AAAA,YAAG,EAAA;AAEjjB,qBAASG,EAAgBC,GAAUJ,GAAa;AAAE,kBAAI,EAAEI,aAAoBJ;AAAgB,sBAAM,IAAI,UAAU,mCAAmC;AAAA,YAAM;AASzJ,gBAAI5I,IAAarE,EAAoB,EAAE,GAEnCwV,IAAY,WAAY;AACxB,uBAASA,EAAUC,GAAGC,GAAiB;AACnC,gBAAAtI,EAAgB,MAAMoI,CAAS,IAE3BE,MAAoB,QAAQA,MAAoB,YAAW,KAAK,kBAAkB,KAAK;AAE3F,oBAAI1C,IAAS;AACb,gBAAIyC,aAAapR,IAAY2O,IAASyC,EAAE,KAAI,IAAQzC,IAASyC,EAAE,QAE/D,KAAK,WAAWA,GAAG,GAAGzC,IAAS,CAAC;AAAA,cACnC;AAED,qBAAAnG,EAAa2I,GAAW,CAAC;AAAA,gBACrB,KAAK;AAAA,gBACL,OAAO,SAAoBC,GAAGlJ,GAAG,GAAG;AAChC,sBAAIA,IAAI,GAAG;AACP,wBAAIC,IAAI,KAAK,WAAWiJ,GAAGlJ,GAAG,CAAC;AAC/B,yBAAK,WAAWkJ,GAAGlJ,GAAGC,CAAC,GACvB,KAAK,WAAWiJ,GAAGjJ,IAAI,GAAG,CAAC;AAAA,kBAC9B;AAAA,gBACJ;AAAA,cACT,GAAO;AAAA,gBACC,KAAK;AAAA,gBACL,OAAO,SAAoBiJ,GAAGlJ,GAAG,GAAG;AAIhC,2BAHIlK,IAAI,KAAK,KAAKoT,GAAGlJ,CAAC,GAClBpJ,IAAIoJ,GACJmG,IAAI,OACK;AACT,2BAAO,KAAK,gBAAgBrQ,GAAG,KAAK,KAAKoT,GAAG/C,CAAC,CAAC;AAC1C,sBAAAA;AACH,2BAAO,KAAK,gBAAgB,KAAK,KAAK+C,GAAGtS,CAAC,GAAGd,CAAC;AAC3C,sBAAAc;AACH,wBAAIA,IAAIuP;AACL,2BAAK,MAAM+C,GAAGtS,GAAGuP,CAAC,GAClBvP,KACAuP;AAAA;AACG,6BAAOA;AAAA,kBACjB;AAAA,gBACJ;AAAA,cACT,GAAO;AAAA,gBACC,KAAK;AAAA,gBACL,OAAO,SAAcpS,GAAQ4E,GAAO;AAChC,yBAAI5E,aAAkB+D,IAAmB/D,EAAO,cAAc4E,CAAK,IAAc5E,EAAO4E,CAAK;AAAA,gBAChG;AAAA,cACT,GAAO;AAAA,gBACC,KAAK;AAAA,gBACL,OAAO,SAAc5E,GAAQ4E,GAAOhF,GAAO;AACvC,kBAAII,aAAkB+D,IAAY/D,EAAO,cAAc4E,GAAOhF,CAAK,IAAOI,EAAO4E,CAAK,IAAIhF;AAAA,gBAC7F;AAAA,cACT,GAAO;AAAA,gBACC,KAAK;AAAA,gBACL,OAAO,SAAeuV,GAAGtS,GAAGuP,GAAG;AAC3B,sBAAIlD,IAAO,KAAK,KAAKiG,GAAGtS,CAAC;AACzB,uBAAK,KAAKsS,GAAGtS,GAAG,KAAK,KAAKsS,GAAG/C,CAAC,CAAC,GAC/B,KAAK,KAAK+C,GAAG/C,GAAGlD,CAAI;AAAA,gBACvB;AAAA,cACT,GAAO;AAAA,gBACC,KAAK;AAAA,gBACL,OAAO,SAAiCrD,GAAGC,GAAG;AAC1C,yBAAOA,IAAID;AAAA,gBACd;AAAA,cACJ,CAAA,CAAC,GAEKqJ;AAAA,YACX;AAEA,YAAA5V,EAAO,UAAU4V;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAS5V,GAAQO,GAASH,GAAqB;AAKtD,gBAAI6M,IAAe,WAAY;AAAE,uBAASC,EAAiBhM,GAAQiM,GAAO;AAAE,yBAAS5J,IAAI,GAAGA,IAAI4J,EAAM,QAAQ5J,KAAK;AAAE,sBAAI6J,IAAaD,EAAM5J,CAAC;AAAG,kBAAA6J,EAAW,aAAaA,EAAW,cAAc,IAAOA,EAAW,eAAe,IAAU,WAAWA,MAAYA,EAAW,WAAW,KAAM,OAAO,eAAelM,GAAQkM,EAAW,KAAKA,CAAU;AAAA,gBAAE;AAAA,cAAI;AAAC,qBAAO,SAAUC,GAAaC,GAAYC,GAAa;AAAE,uBAAID,KAAYJ,EAAiBG,EAAY,WAAWC,CAAU,GAAOC,KAAaL,EAAiBG,GAAaE,CAAW,GAAUF;AAAA,cAAc;AAAA,YAAG,EAAA;AAEjjB,qBAASG,EAAgBC,GAAUJ,GAAa;AAAE,kBAAI,EAAEI,aAAoBJ;AAAgB,sBAAM,IAAI,UAAU,mCAAmC;AAAA,YAAM;AAYzJ,gBAAI0I,IAAkB,WAAY;AAC9B,uBAASA,EAAgBC,GAAWC,GAAW;AAC3C,oBAAIC,IAAc,UAAU,SAAS,KAAK,UAAU,CAAC,MAAM,SAAY,UAAU,CAAC,IAAI,GAClFC,IAAmB,UAAU,SAAS,KAAK,UAAU,CAAC,MAAM,SAAY,UAAU,CAAC,IAAI,IACvFC,IAAc,UAAU,SAAS,KAAK,UAAU,CAAC,MAAM,SAAY,UAAU,CAAC,IAAI;AAEtF,gBAAA5I,EAAgB,MAAMuI,CAAe,GAErC,KAAK,YAAYC,GACjB,KAAK,YAAYC,GACjB,KAAK,cAAcC,GACnB,KAAK,mBAAmBC,GACxB,KAAK,cAAcC,GAGnB,KAAK,OAAOJ,EAAU,SAAS,GAC/B,KAAK,OAAOC,EAAU,SAAS,GAG/B,KAAK,OAAO,IAAI,MAAM,KAAK,IAAI;AAC/B,yBAAS1S,IAAI,GAAGA,IAAI,KAAK,MAAMA,KAAK;AAChC,uBAAK,KAAKA,CAAC,IAAI,IAAI,MAAM,KAAK,IAAI;AAElC,2BAASuP,IAAI,GAAGA,IAAI,KAAK,MAAMA;AAC3B,yBAAK,KAAKvP,CAAC,EAAEuP,CAAC,IAAI;AAAA,gBAEzB;AAGD,qBAAK,gBAAgB,IAAI,MAAM,KAAK,IAAI;AACxC,yBAASuD,IAAK,GAAGA,IAAK,KAAK,MAAMA,KAAM;AACnC,uBAAK,cAAcA,CAAE,IAAI,IAAI,MAAM,KAAK,IAAI;AAE5C,2BAASC,IAAK,GAAGA,IAAK,KAAK,MAAMA;AAC7B,yBAAK,cAAcD,CAAE,EAAEC,CAAE,IAAI,CAAC,MAAM,MAAM,IAAI;AAAA,gBAErD;AAGD,qBAAK,aAAa,IAGlB,KAAK,QAAQ,IAGb,KAAK,aAAY;AAAA,cACpB;AAED,qBAAArJ,EAAa8I,GAAiB,CAAC;AAAA,gBAC3B,KAAK;AAAA,gBACL,OAAO,WAAoB;AACvB,yBAAO,KAAK;AAAA,gBACf;AAAA,cACT,GAAO;AAAA,gBACC,KAAK;AAAA,gBACL,OAAO,WAAyB;AAC5B,yBAAO,KAAK;AAAA,gBACf;AAAA;AAAA,cAIT,GAAO;AAAA,gBACC,KAAK;AAAA,gBACL,OAAO,WAAwB;AAE3B,2BAASjD,IAAI,GAAGA,IAAI,KAAK,MAAMA;AAC3B,yBAAK,KAAK,CAAC,EAAEA,CAAC,IAAI,KAAK,KAAK,CAAC,EAAEA,IAAI,CAAC,IAAI,KAAK,aAC7C,KAAK,cAAc,CAAC,EAAEA,CAAC,IAAI,CAAC,IAAO,IAAO,EAAI;AAIlD,2BAASvP,IAAI,GAAGA,IAAI,KAAK,MAAMA;AAC3B,yBAAK,KAAKA,CAAC,EAAE,CAAC,IAAI,KAAK,KAAKA,IAAI,CAAC,EAAE,CAAC,IAAI,KAAK,aAC7C,KAAK,cAAcA,CAAC,EAAE,CAAC,IAAI,CAAC,IAAO,IAAM,EAAK;AAIlD,2BAASgT,IAAM,GAAGA,IAAM,KAAK,MAAMA;AAC/B,6BAASC,IAAM,GAAGA,IAAM,KAAK,MAAMA,KAAO;AAEtC,0BAAIC,IAAO;AACX,sBAAI,KAAK,UAAUF,IAAM,CAAC,MAAM,KAAK,UAAUC,IAAM,CAAC,IAAGC,IAAO,KAAK,KAAKF,IAAM,CAAC,EAAEC,IAAM,CAAC,IAAI,KAAK,cAAiBC,IAAO,KAAK,KAAKF,IAAM,CAAC,EAAEC,IAAM,CAAC,IAAI,KAAK;AAE9J,0BAAIE,IAAK,KAAK,KAAKH,IAAM,CAAC,EAAEC,CAAG,IAAI,KAAK,aACpCvS,IAAO,KAAK,KAAKsS,CAAG,EAAEC,IAAM,CAAC,IAAI,KAAK,aAGtCG,IAAQ,CAACF,GAAMC,GAAIzS,CAAI,GACvB2S,IAAU,KAAK,mBAAmBD,CAAK;AAG3C,2BAAK,KAAKJ,CAAG,EAAEC,CAAG,IAAIG,EAAMC,EAAQ,CAAC,CAAC,GACtC,KAAK,cAAcL,CAAG,EAAEC,CAAG,IAAI,CAACI,EAAQ,SAAS,CAAC,GAAGA,EAAQ,SAAS,CAAC,GAAGA,EAAQ,SAAS,CAAC,CAAC;AAAA,oBAChG;AAIL,uBAAK,QAAQ,KAAK,KAAK,KAAK,OAAO,CAAC,EAAE,KAAK,OAAO,CAAC;AAAA,gBACtD;AAAA;AAAA,cAIT,GAAO;AAAA,gBACC,KAAK;AAAA,gBACL,OAAO,WAA8B;AACjC,sBAAIC,IAAsB,CAAA;AAO1B,uBALAA,EAAoB,KAAK;AAAA,oBAAE,KAAK,CAAC,KAAK,UAAU,QAAQ,KAAK,UAAU,MAAM;AAAA,oBACzE,MAAM;AAAA,oBACN,MAAM;AAAA,kBACtB,CAAa,GAEMA,EAAoB,CAAC,KAAG;AAC3B,wBAAIxI,IAAUwI,EAAoB,CAAC,GAC/BvO,IAAa,KAAK,cAAc+F,EAAQ,IAAI,CAAC,CAAC,EAAEA,EAAQ,IAAI,CAAC,CAAC;AAElE,oBAAI/F,EAAW,CAAC,KACZuO,EAAoB,KAAK;AAAA,sBAAE,KAAK,CAACxI,EAAQ,IAAI,CAAC,IAAI,GAAGA,EAAQ,IAAI,CAAC,IAAI,CAAC;AAAA,sBACnE,MAAM,KAAK,UAAUA,EAAQ,IAAI,CAAC,IAAI,CAAC,IAAIA,EAAQ;AAAA,sBACnD,MAAM,KAAK,UAAUA,EAAQ,IAAI,CAAC,IAAI,CAAC,IAAIA,EAAQ;AAAA,oBAC3E,CAAqB,GAED/F,EAAW,CAAC,KACZuO,EAAoB,KAAK;AAAA,sBAAE,KAAK,CAACxI,EAAQ,IAAI,CAAC,IAAI,GAAGA,EAAQ,IAAI,CAAC,CAAC;AAAA,sBAC/D,MAAM,KAAK,UAAUA,EAAQ,IAAI,CAAC,IAAI,CAAC,IAAIA,EAAQ;AAAA,sBACnD,MAAM,MAAMA,EAAQ;AAAA,oBAC5C,CAAqB,GAED/F,EAAW,CAAC,KACZuO,EAAoB,KAAK;AAAA,sBAAE,KAAK,CAACxI,EAAQ,IAAI,CAAC,GAAGA,EAAQ,IAAI,CAAC,IAAI,CAAC;AAAA,sBAC/D,MAAM,MAAMA,EAAQ;AAAA,sBACpB,MAAM,KAAK,UAAUA,EAAQ,IAAI,CAAC,IAAI,CAAC,IAAIA,EAAQ;AAAA,oBAC3E,CAAqB,GAGDA,EAAQ,IAAI,CAAC,MAAM,KAAKA,EAAQ,IAAI,CAAC,MAAM,KAAG,KAAK,WAAW,KAAK;AAAA,sBAAE,WAAWA,EAAQ;AAAA,sBACxF,WAAWA,EAAQ;AAAA,oBACvC,CAAiB,GAEDwI,EAAoB,MAAK;AAAA,kBAC5B;AAED,yBAAO,KAAK;AAAA,gBACf;AAAA;AAAA,cAIT,GAAO;AAAA,gBACC,KAAK;AAAA,gBACL,OAAO,SAAuBjI,GAAKT,GAAK;AAGpC,2BAFI2I,IAAU,CAAE,GACZvT,IAAI,KACAA,IAAIqL,EAAI,QAAQT,GAAK5K,IAAI,CAAC,OAAO;AACrC,oBAAAuT,EAAQ,KAAKvT,CAAC;AAElB,yBAAOuT;AAAA,gBACV;AAAA,cACT,GAAO;AAAA,gBACC,KAAK;AAAA,gBACL,OAAO,SAA4BC,GAAO;AACtC,yBAAO,KAAK,cAAcA,GAAO,KAAK,IAAI,MAAM,MAAMA,CAAK,CAAC;AAAA,gBAC/D;AAAA,cACJ,CAAA,CAAC,GAEKhB;AAAA,YACX;AAEA,YAAA/V,EAAO,UAAU+V;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAS/V,GAAQO,GAASH,GAAqB;AAKtD,gBAAI4W,IAAa,WAAsB;AAAA,YAEvC;AAEA,YAAAA,EAAW,WAAW5W,EAAoB,EAAE,GAC5C4W,EAAW,oBAAoB5W,EAAoB,CAAC,GACpD4W,EAAW,eAAe5W,EAAoB,EAAE,GAChD4W,EAAW,eAAe5W,EAAoB,EAAE,GAChD4W,EAAW,aAAa5W,EAAoB,EAAE,GAC9C4W,EAAW,UAAU5W,EAAoB,EAAE,GAC3C4W,EAAW,UAAU5W,EAAoB,EAAE,GAC3C4W,EAAW,YAAY5W,EAAoB,CAAC,GAC5C4W,EAAW,QAAQ5W,EAAoB,CAAC,GACxC4W,EAAW,UAAU5W,EAAoB,EAAE,GAC3C4W,EAAW,QAAQ5W,EAAoB,EAAE,GACzC4W,EAAW,SAAS5W,EAAoB,CAAC,GACzC4W,EAAW,aAAa5W,EAAoB,EAAE,GAC9C4W,EAAW,aAAa5W,EAAoB,EAAE,GAC9C4W,EAAW,YAAY5W,EAAoB,EAAE,GAC7C4W,EAAW,oBAAoB5W,EAAoB,EAAE,GACrD4W,EAAW,YAAY5W,EAAoB,EAAE,GAC7C4W,EAAW,aAAa5W,EAAoB,EAAE,GAC9C4W,EAAW,eAAe5W,EAAoB,CAAC,GAC/C4W,EAAW,SAAS5W,EAAoB,CAAC,GACzC4W,EAAW,QAAQ5W,EAAoB,CAAC,GACxC4W,EAAW,gBAAgB5W,EAAoB,CAAC,GAChD4W,EAAW,QAAQ5W,EAAoB,CAAC,GACxC4W,EAAW,SAAS5W,EAAoB,EAAE,GAC1C4W,EAAW,kBAAkB5W,EAAoB,CAAC,GAClD4W,EAAW,kBAAkB5W,EAAoB,EAAE,GAEnDJ,EAAO,UAAUgX;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAShX,GAAQO,GAASH,GAAqB;AAKtD,qBAAS2O,IAAU;AACjB,mBAAK,YAAY;YAClB;AAED,gBAAIpC,IAAIoC,EAAQ;AAEhB,YAAApC,EAAE,cAAc,SAAUsK,GAAOC,GAAU;AACzC,mBAAK,UAAU,KAAK;AAAA,gBAClB,OAAOD;AAAA,gBACP,UAAUC;AAAA,cACd,CAAG;AAAA,YACH,GAEAvK,EAAE,iBAAiB,SAAUsK,GAAOC,GAAU;AAC5C,uBAAS3T,IAAI,KAAK,UAAU,QAAQA,KAAK,GAAGA,KAAK;AAC/C,oBAAI4T,IAAI,KAAK,UAAU5T,CAAC;AAExB,gBAAI4T,EAAE,UAAUF,KAASE,EAAE,aAAaD,KACtC,KAAK,UAAU,OAAO3T,GAAG,CAAC;AAAA,cAE7B;AAAA,YACH,GAEAoJ,EAAE,OAAO,SAAUsK,GAAOG,GAAM;AAC9B,uBAAS7T,IAAI,GAAGA,IAAI,KAAK,UAAU,QAAQA,KAAK;AAC9C,oBAAI4T,IAAI,KAAK,UAAU5T,CAAC;AAExB,gBAAI0T,MAAUE,EAAE,SACdA,EAAE,SAASC,CAAI;AAAA,cAElB;AAAA,YACH,GAEApX,EAAO,UAAU+O;AAAA,UAEV;AAAA;AAAA,QACP,CAAU;AAAA;AAAA,IACV,CAAC;AAAA;;;;;AC7uID,KAAC,SAA0CjP,GAAMC,GAAS;AAExD,MAAAC,EAAiB,UAAAD,EAAQsX,GAAsB,CAAA;AAAA,IAOjD,GAAGpX,GAAM,SAASqX,GAA+B;AACjD;AAAA;AAAA,QAAiB,SAASpX,GAAS;AAEzB,cAAIC,IAAmB,CAAA;AAGvB,mBAASC,EAAoBC,GAAU;AAGtC,gBAAGF,EAAiBE,CAAQ;AAC3B,qBAAOF,EAAiBE,CAAQ,EAAE;AAGnC,gBAAIL,IAASG,EAAiBE,CAAQ,IAAI;AAAA;AAAA,cACzC,GAAGA;AAAA;AAAA,cACH,GAAG;AAAA;AAAA,cACH,SAAS,CAAE;AAAA;AAAA,YACvB;AAGW,mBAAAH,EAAQG,CAAQ,EAAE,KAAKL,EAAO,SAASA,GAAQA,EAAO,SAASI,CAAmB,GAGlFJ,EAAO,IAAI,IAGJA,EAAO;AAAA,UACd;AAID,iBAAAI,EAAoB,IAAIF,GAGxBE,EAAoB,IAAID,GAGxBC,EAAoB,IAAI,SAASE,GAAO;AAAE,mBAAOA;AAAA,UAAM,GAGvDF,EAAoB,IAAI,SAASG,GAASC,GAAMC,GAAQ;AACvD,YAAIL,EAAoB,EAAEG,GAASC,CAAI,KACtC,OAAO,eAAeD,GAASC,GAAM;AAAA;AAAA,cACpC,cAAc;AAAA;AAAA,cACd,YAAY;AAAA;AAAA,cACZ,KAAKC;AAAA;AAAA,YAClB,CAAa;AAAA,UAEb,GAGUL,EAAoB,IAAI,SAASJ,GAAQ;AACxC,gBAAIS,IAAST,KAAUA,EAAO;AAAA;AAAA,cAC7B,WAAsB;AAAE,uBAAOA,EAAO;AAAA,cAAa;AAAA;AAAA;AAAA,cACnD,WAA4B;AAAE,uBAAOA;AAAA;;AACtC,mBAAAI,EAAoB,EAAEK,GAAQ,KAAKA,CAAM,GAClCA;AAAA,UAClB,GAGUL,EAAoB,IAAI,SAASM,GAAQC,GAAU;AAAE,mBAAO,OAAO,UAAU,eAAe,KAAKD,GAAQC,CAAQ;AAAA,UAAE,GAGnHP,EAAoB,IAAI,IAGjBA,EAAoBA,EAAoB,IAAI,CAAC;AAAA,QACpD,EAEA;AAAA;AAAA;AAAA,UAEH,SAASJ,GAAQO,GAAS;AAEjC,YAAAP,EAAO,UAAUsX;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAStX,GAAQO,GAASH,GAAqB;AAKtD,gBAAI6H,IAAoB7H,EAAoB,CAAC,EAAE;AAE/C,qBAASmX,IAAgB;AAAA,YAAE;AAG3B,qBAASnW,KAAQ6G;AACf,cAAAsP,EAAcnW,CAAI,IAAI6G,EAAkB7G,CAAI;AAG9C,YAAAmW,EAAc,kCAAkC,IAChDA,EAAc,4BAA4BtP,EAAkB,qBAC5DsP,EAAc,+BAA+B,IAC7CA,EAAc,OAAO,IACrBA,EAAc,0BAA0B,IACxCA,EAAc,4BAA4B,IAC1CA,EAAc,gCAAgC,IAE9CvX,EAAO,UAAUuX;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAASvX,GAAQO,GAASH,GAAqB;AAKtD,gBAAI4U,IAAe5U,EAAoB,CAAC,EAAE;AAE1C,qBAASoX,EAASvW,GAAQC,GAAQC,GAAO;AACvC,cAAA6T,EAAa,KAAK,MAAM/T,GAAQC,GAAQC,CAAK;AAAA,YAC9C;AAED,YAAAqW,EAAS,YAAY,OAAO,OAAOxC,EAAa,SAAS;AACzD,qBAAS5T,KAAQ4T;AACf,cAAAwC,EAASpW,CAAI,IAAI4T,EAAa5T,CAAI;AAGpC,YAAApB,EAAO,UAAUwX;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAASxX,GAAQO,GAASH,GAAqB;AAKtD,gBAAIsE,IAAStE,EAAoB,CAAC,EAAE;AAEpC,qBAASqX,EAAU9S,GAAQ+S,GAAU7S,GAAQ;AAC3C,cAAAH,EAAO,KAAK,MAAMC,GAAQ+S,GAAU7S,CAAM;AAAA,YAC3C;AAED,YAAA4S,EAAU,YAAY,OAAO,OAAO/S,EAAO,SAAS;AACpD,qBAAStD,KAAQsD;AACf,cAAA+S,EAAUrW,CAAI,IAAIsD,EAAOtD,CAAI;AAG/B,YAAApB,EAAO,UAAUyX;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAASzX,GAAQO,GAASH,GAAqB;AAKtD,gBAAImE,IAAgBnE,EAAoB,CAAC,EAAE;AAE3C,qBAASuX,EAAiB9Q,GAAQ;AAChC,cAAAtC,EAAc,KAAK,MAAMsC,CAAM;AAAA,YAChC;AAED,YAAA8Q,EAAiB,YAAY,OAAO,OAAOpT,EAAc,SAAS;AAClE,qBAASnD,KAAQmD;AACf,cAAAoT,EAAiBvW,CAAI,IAAImD,EAAcnD,CAAI;AAG7C,YAAApB,EAAO,UAAU2X;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAS3X,GAAQO,GAASH,GAAqB;AAKtD,gBAAI6U,IAAe7U,EAAoB,CAAC,EAAE,cACtCW,IAAQX,EAAoB,CAAC,EAAE;AAEnC,qBAASwX,EAAS7V,GAAIC,GAAKC,GAAMC,GAAO;AACtC,cAAA+S,EAAa,KAAK,MAAMlT,GAAIC,GAAKC,GAAMC,CAAK;AAAA,YAC7C;AAED,YAAA0V,EAAS,YAAY,OAAO,OAAO3C,EAAa,SAAS;AACzD,qBAAS7T,KAAQ6T;AACf,cAAA2C,EAASxW,CAAI,IAAI6T,EAAa7T,CAAI;AAGpC,YAAAwW,EAAS,UAAU,OAAO,WAAY;AACpC,kBAAI/Q,IAAS,KAAK,aAAa,UAAS;AACxC,mBAAK,gBAAgBA,EAAO,iBAAiB,KAAK,eAAe,KAAK,kBAAkB,KAAK,qBAAqB,KAAK,cACvH,KAAK,gBAAgBA,EAAO,iBAAiB,KAAK,eAAe,KAAK,kBAAkB,KAAK,qBAAqB,KAAK,cAEnH,KAAK,IAAI,KAAK,aAAa,IAAIA,EAAO,gBAAgBA,EAAO,wBAC/D,KAAK,gBAAgBA,EAAO,gBAAgBA,EAAO,sBAAsB9F,EAAM,KAAK,KAAK,aAAa,IAGpG,KAAK,IAAI,KAAK,aAAa,IAAI8F,EAAO,gBAAgBA,EAAO,wBAC/D,KAAK,gBAAgBA,EAAO,gBAAgBA,EAAO,sBAAsB9F,EAAM,KAAK,KAAK,aAAa,IAIpG,KAAK,SAAS,OAChB,KAAK,OAAO,KAAK,eAAe,KAAK,aAAa,IAG3C,KAAK,MAAM,SAAQ,EAAG,UAAU,IACrC,KAAK,OAAO,KAAK,eAAe,KAAK,aAAa,IAIhD,KAAK,gCAAgC,KAAK,eAAe,KAAK,aAAa,GAGjF8F,EAAO,qBAAqB,KAAK,IAAI,KAAK,aAAa,IAAI,KAAK,IAAI,KAAK,aAAa,GAEtF,KAAK,eAAe,GACpB,KAAK,eAAe,GACpB,KAAK,kBAAkB,GACvB,KAAK,kBAAkB,GACvB,KAAK,oBAAoB,GACzB,KAAK,oBAAoB,GACzB,KAAK,gBAAgB,GACrB,KAAK,gBAAgB;AAAA,YACvB,GAEA+Q,EAAS,UAAU,kCAAkC,SAAUC,GAAIC,GAAI;AAGrE,uBAFIxU,IAAQ,KAAK,SAAU,EAAC,SAAQ,GAChCjC,GACKkC,IAAI,GAAGA,IAAID,EAAM,QAAQC;AAChC,gBAAAlC,IAAOiC,EAAMC,CAAC,GACVlC,EAAK,SAAU,KAAI,QACrBA,EAAK,OAAOwW,GAAIC,CAAE,GAClBzW,EAAK,iBAAiBwW,GACtBxW,EAAK,iBAAiByW,KAEtBzW,EAAK,gCAAgCwW,GAAIC,CAAE;AAAA,YAGjD,GAEAF,EAAS,UAAU,WAAW,SAAUG,GAAO;AAC7C,mBAAK,QAAQA;AAAA,YACf,GAEAH,EAAS,UAAU,WAAW,WAAY;AACxC,qBAAO;AAAA,YACT,GAEAA,EAAS,UAAU,WAAW,WAAY;AACxC,qBAAO;AAAA,YACT,GAEAA,EAAS,UAAU,UAAU,SAAU/J,GAAM;AAC3C,mBAAK,OAAOA;AAAA,YACd,GAEA+J,EAAS,UAAU,UAAU,WAAY;AACvC,qBAAO;AAAA,YACT,GAEAA,EAAS,UAAU,eAAe,SAAUI,GAAW;AACrD,mBAAK,YAAYA;AAAA,YACnB,GAEAJ,EAAS,UAAU,cAAc,WAAY;AAC3C,qBAAO;AAAA,YACT,GAEA5X,EAAO,UAAU4X;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAAS5X,GAAQO,GAASH,GAAqB;AAKtD,gBAAImS,IAAWnS,EAAoB,CAAC,EAAE,UAClCuX,IAAmBvX,EAAoB,CAAC,GACxCqX,IAAYrX,EAAoB,CAAC,GACjCwX,IAAWxX,EAAoB,CAAC,GAChCoX,IAAWpX,EAAoB,CAAC,GAChCmX,IAAgBnX,EAAoB,CAAC,GACrC6H,IAAoB7H,EAAoB,CAAC,EAAE,mBAC3CQ,IAAkBR,EAAoB,CAAC,EAAE,iBACzCoE,IAAQpE,EAAoB,CAAC,EAAE,OAC/ByB,IAASzB,EAAoB,CAAC,EAAE,QAChC4O,IAAS5O,EAAoB,CAAC,EAAE,QAChCsB,IAAUtB,EAAoB,CAAC,EAAE,SACjCU,IAAYV,EAAoB,CAAC,EAAE,WACnCsE,IAAStE,EAAoB,CAAC,EAAE,QAChC0O,IAAY1O,EAAoB,CAAC,EAAE;AAEvC,qBAAS6X,IAAa;AACpB,cAAA1F,EAAS,KAAK,IAAI,GAElB,KAAK,YAAY;YAClB;AAED,YAAA0F,EAAW,YAAY,OAAO,OAAO1F,EAAS,SAAS;AAEvD,qBAASnR,KAAQmR;AACf,cAAA0F,EAAW7W,CAAI,IAAImR,EAASnR,CAAI;AAGlC,YAAA6W,EAAW,UAAU,kBAAkB,WAAY;AACjD,kBAAIlW,IAAK,IAAI4V,EAAiB,IAAI;AAClC,0BAAK,eAAe5V,GACbA;AAAA,YACT,GAEAkW,EAAW,UAAU,WAAW,SAAUpT,GAAQ;AAChD,qBAAO,IAAI4S,EAAU,MAAM,KAAK,cAAc5S,CAAM;AAAA,YACtD,GAEAoT,EAAW,UAAU,UAAU,SAAU/V,GAAO;AAC9C,qBAAO,IAAI0V,EAAS,KAAK,cAAc1V,CAAK;AAAA,YAC9C,GAEA+V,EAAW,UAAU,UAAU,SAAU9W,GAAO;AAC9C,qBAAO,IAAIqW,EAAS,MAAM,MAAMrW,CAAK;AAAA,YACvC,GAEA8W,EAAW,UAAU,iBAAiB,WAAY;AAChD,cAAA1F,EAAS,UAAU,eAAe,KAAK,MAAM,SAAS,GACjD,KAAK,gBACJgF,EAAc,sBAAsB,KACtC,KAAK,kBAAkB,KAEvB,KAAK,kBAAkBA,EAAc,qBAGvC,KAAK,qCAAqCA,EAAc,iDACxD,KAAK,iBAAiBtP,EAAkB,yBACxC,KAAK,oBAAoBA,EAAkB,4BAC3C,KAAK,kBAAkBA,EAAkB,0BACzC,KAAK,0BAA0BA,EAAkB,mCACjD,KAAK,qBAAqBA,EAAkB,8BAC5C,KAAK,6BAA6BA,EAAkB,uCAGpD,KAAK,iBAAiB,IACtB,KAAK,qBAAqB,GAC1B,KAAK,wBAAwB,GAC7B,KAAK,gBAAgB,IACrB,KAAK,mBAAmB,IAGxB,KAAK,eAAe,GACpB,KAAK,kBAAkB,KAAK,gBAAgBA,EAAkB,0BAC9D,KAAK,mBAAmBA,EAAkB,2BAA2B,KAAK,eAC1E,KAAK,kBAAkB;AAAA,YAE3B,GAEAgQ,EAAW,UAAU,SAAS,WAAY;AACxC,kBAAIC,IAAsBtX,EAAgB;AAC1C,qBAAIsX,MACF,KAAK,iBAAgB,GACrB,KAAK,aAAa,kBAGpB,KAAK,QAAQ,GACN,KAAK;YACd,GAEAD,EAAW,UAAU,gBAAgB,WAAY;AAS/C,kBARA,KAAK,mBAAmB,KAAK,sCAC7B,KAAK,aAAa,8BAA8B,KAAK,gBAAgB,GACrE,KAAK,4BAA2B,GAChC,KAAK,aAAa,6BAClB,KAAK,aAAa,2BAClB,KAAK,aAAa,QAAS,EAAC,kBAAiB,GAC7C,KAAK,qBAAoB,GAEpB,KAAK;AAsBR,oBAAIV,EAAc,+BAA+B;AAE/C,uBAAK,YAAW,GAEhB,KAAK,aAAa;AAClB,sBAAIhI,IAAW,IAAI,IAAI,KAAK,YAAa,CAAA,GACrC4I,IAAe,KAAK,iBAAiB,OAAO,SAAU1V,GAAG;AAC3D,2BAAO8M,EAAS,IAAI9M,CAAC;AAAA,kBAC7B,CAAO;AACD,uBAAK,aAAa,8BAA8B0V,CAAY;AAAA,gBAC7D;AAAA,qBAhCoB;AACrB,oBAAIC,IAAS,KAAK;AAGlB,oBAAIA,EAAO,SAAS;AAClB,uBAAK,sBAAsBA,CAAM;AAAA,qBAG9B;AAED,uBAAK,YAAW,GAEhB,KAAK,aAAa;AAClB,sBAAI7I,IAAW,IAAI,IAAI,KAAK,YAAa,CAAA,GACrC4I,IAAe,KAAK,iBAAiB,OAAO,SAAU1V,GAAG;AAC3D,2BAAO8M,EAAS,IAAI9M,CAAC;AAAA,kBAC/B,CAAS;AACD,uBAAK,aAAa,8BAA8B0V,CAAY,GAE5D,KAAK,sBAAqB;AAAA,gBAC3B;AAAA,cACP;AAcE,0BAAK,mBAAkB,GACvB,KAAK,kBAAiB,GAEf;AAAA,YACT,GAEAF,EAAW,UAAU,OAAO,WAAY;AAGtC,kBAFA,KAAK,mBAED,KAAK,oBAAoB,KAAK,iBAAiB,CAAC,KAAK,iBAAiB,CAAC,KAAK;AAC9E,oBAAI,KAAK,eAAe,SAAS;AAC/B,uBAAK,gBAAgB;AAAA;AAErB,yBAAO;AAIX,kBAAI,KAAK,kBAAkBhQ,EAAkB,4BAA4B,KAAK,CAAC,KAAK,iBAAiB,CAAC,KAAK,kBAAkB;AAC3H,oBAAI,KAAK;AACP,sBAAI,KAAK,eAAe,SAAS;AAC/B,yBAAK,gBAAgB;AAAA;AAErB,2BAAO;AAIX,qBAAK,gBAED,KAAK,iBAAiB,IAExB,KAAK,kBAAkB,KAAK,eACnB,KAAK,iBAAiB,MAE/B,KAAK,kBAAkB,KAAK,eAAe,IAI7C,KAAK,gBAAgB,KAAK,IAAI,KAAK,uBAAuB,KAAK,IAAI,KAAK,cAAc,KAAK,IAAI,OAAO,KAAK,uBAAuB,KAAK,iBAAiB,IAAI,KAAK,IAAI,KAAK,eAAe,CAAC,IAAI,MAAM,KAAK,iBAAiB,KAAK,gBAAgB,GAC/O,KAAK,kBAAkB,KAAK,KAAK,KAAK,yBAAyB,KAAK,KAAK,KAAK,aAAa,CAAC;AAAA,cAC7F;AAED,kBAAI,KAAK,eAAe;AACtB,oBAAI,KAAK,qBAAqB,MAAM;AAClC,sBAAI,KAAK,eAAe,SAAS,GAAG;AAClC,yBAAK,aAAa,gBAClB,KAAK,WAAU,GACf,KAAK,SAAS,KAAK,cAAc,GAEjC,KAAK,aAAa;AAClB,wBAAIsH,IAAW,IAAI,IAAI,KAAK,YAAa,CAAA,GACrC4I,IAAe,KAAK,iBAAiB,OAAO,SAAU1V,GAAG;AAC3D,6BAAO8M,EAAS,IAAI9M,CAAC;AAAA,oBAC/B,CAAS;AACD,yBAAK,aAAa,8BAA8B0V,CAAY,GAE5D,KAAK,aAAa,gBAClB,KAAK,WAAU,GACf,KAAK,gBAAgBlQ,EAAkB;AAAA,kBAC/C;AACQ,yBAAK,gBAAgB,IACrB,KAAK,mBAAmB;AAG5B,qBAAK;AAAA,cACN;AAED,kBAAI,KAAK,kBAAkB;AACzB,oBAAI,KAAK;AACP,yBAAO;AAET,gBAAI,KAAK,wBAAwB,MAAM,MACrC,KAAK,aAAa,gBAClB,KAAK,WAAU,IAEjB,KAAK,gBAAgBA,EAAkB,uCAAuC,MAAM,KAAK,yBAAyB,MAClH,KAAK;AAAA,cACN;AAED,kBAAI2K,IAAoB,CAAC,KAAK,iBAAiB,CAAC,KAAK,kBACjDC,IAA+B,KAAK,qBAAqB,MAAM,KAAK,KAAK,iBAAiB,KAAK,wBAAwB,MAAM,KAAK,KAAK;AAE3I,0BAAK,oBAAoB,GACzB,KAAK,aAAa,gBAClB,KAAK,iBAAgB,GACrB,KAAK,oBAAoBD,GAAmBC,CAA4B,GACxE,KAAK,wBAAuB,GAC5B,KAAK,UAAS,GACd,KAAK,QAAO,GAEL;AAAA,YACT,GAEAoF,EAAW,UAAU,mBAAmB,WAAY;AAGlD,uBAFI1I,IAAW,KAAK,aAAa,YAAW,GACxC8I,IAAQ,CAAA,GACH9U,IAAI,GAAGA,IAAIgM,EAAS,QAAQhM,KAAK;AACxC,oBAAI+U,IAAO/I,EAAShM,CAAC,EAAE,MACnBiL,IAAKe,EAAShM,CAAC,EAAE;AACrB,gBAAA8U,EAAM7J,CAAE,IAAI;AAAA,kBACV,IAAIA;AAAA,kBACJ,GAAG8J,EAAK,WAAY;AAAA,kBACpB,GAAGA,EAAK,WAAY;AAAA,kBACpB,GAAGA,EAAK;AAAA,kBACR,GAAGA,EAAK;AAAA,gBACd;AAAA,cACG;AAED,qBAAOD;AAAA,YACT,GAEAJ,EAAW,UAAU,oBAAoB,WAAY;AACnD,mBAAK,yBAAyB,IAC9B,KAAK,kBAAkB,KAAK;AAC5B,kBAAIM,IAAc;AAGlB,kBAAItQ,EAAkB,YAAY;AAChC,qBAAK,KAAK,eAAe;AAAA,mBACpB;AAEL,uBAAO,CAACsQ;AACN,kBAAAA,IAAc,KAAK;AAGrB,qBAAK,aAAa;cACnB;AAAA,YACH,GAEAN,EAAW,UAAU,qCAAqC,WAAY;AACpE,kBAAI3Q,IAAW,CAAA,GACXhG,GAEAiG,IAAS,KAAK,aAAa,UAAS,GACpCtF,IAAOsF,EAAO,QACdhE;AACJ,mBAAKA,IAAI,GAAGA,IAAItB,GAAMsB;AACpB,gBAAAjC,IAAQiG,EAAOhE,CAAC,GAEhBjC,EAAM,gBAAe,GAEhBA,EAAM,gBACTgG,IAAWA,EAAS,OAAOhG,EAAM,SAAU,CAAA;AAI/C,qBAAOgG;AAAA,YACT,GAEA2Q,EAAW,UAAU,mBAAmB,WAAY;AAClD,kBAAIpQ,IAAQ,CAAA;AACZ,cAAAA,IAAQA,EAAM,OAAO,KAAK,aAAa,YAAW,CAAE;AACpD,kBAAIzB,IAAU,oBAAI,OACd7C;AACJ,mBAAKA,IAAI,GAAGA,IAAIsE,EAAM,QAAQtE,KAAK;AACjC,oBAAIP,IAAO6E,EAAMtE,CAAC;AAElB,oBAAI,CAAC6C,EAAQ,IAAIpD,CAAI,GAAG;AACtB,sBAAI/B,IAAS+B,EAAK,aACd9B,IAAS8B,EAAK;AAElB,sBAAI/B,KAAUC;AACZ,oBAAA8B,EAAK,cAAe,EAAC,KAAK,IAAInB,EAAQ,CAAA,GACtCmB,EAAK,cAAe,EAAC,KAAK,IAAInB,EAAQ,CAAA,GACtC,KAAK,8BAA8BmB,CAAI,GACvCoD,EAAQ,IAAIpD,CAAI;AAAA,uBACX;AACL,wBAAIF,IAAW,CAAA;AAKf,wBAHAA,IAAWA,EAAS,OAAO7B,EAAO,kBAAkBC,CAAM,CAAC,GAC3D4B,IAAWA,EAAS,OAAO5B,EAAO,kBAAkBD,CAAM,CAAC,GAEvD,CAACmF,EAAQ,IAAItD,EAAS,CAAC,CAAC,GAAG;AAC7B,0BAAIA,EAAS,SAAS,GAAG;AACvB,4BAAIkN;AACJ,6BAAKA,IAAI,GAAGA,IAAIlN,EAAS,QAAQkN,KAAK;AACpC,8BAAIwI,IAAY1V,EAASkN,CAAC;AAC1B,0BAAAwI,EAAU,cAAe,EAAC,KAAK,IAAI3W,EAAQ,CAAA,GAC3C,KAAK,8BAA8B2W,CAAS;AAAA,wBAC7C;AAAA,sBACF;AACD,sBAAA1V,EAAS,QAAQ,SAAUE,GAAM;AAC/B,wBAAAoD,EAAQ,IAAIpD,CAAI;AAAA,sBAC5B,CAAW;AAAA,oBACF;AAAA,kBACF;AAAA,gBACF;AAED,oBAAIoD,EAAQ,QAAQyB,EAAM;AACxB;AAAA,cAEH;AAAA,YACH,GAEAoQ,EAAW,UAAU,wBAAwB,SAAUG,GAAQ;AAS7D,uBAPIK,IAAuB,IAAIjU,EAAM,GAAG,CAAC,GACrCkU,IAAkB,KAAK,KAAK,KAAK,KAAKN,EAAO,MAAM,CAAC,GACpDhW,IAAS,GACTuW,IAAW,GACXC,IAAW,GACXC,IAAQ,IAAIhX,EAAO,GAAG,CAAC,GAElB0B,IAAI,GAAGA,IAAI6U,EAAO,QAAQ7U,KAAK;AACtC,gBAAIA,IAAImV,KAAmB,MAGzBE,IAAW,GACXD,IAAWvW,GAEPmB,KAAK,MACPoV,KAAYpB,EAAc,+BAG5BnV,IAAS;AAGX,oBAAI0W,IAAOV,EAAO7U,CAAC,GAGfsN,IAAa7B,EAAO,iBAAiB8J,CAAI;AAG7C,gBAAAL,EAAqB,IAAIG,GACzBH,EAAqB,IAAIE,GAGzBE,IAAQZ,EAAW,aAAaa,GAAMjI,GAAY4H,CAAoB,GAElEI,EAAM,IAAIzW,MACZA,IAAS,KAAK,MAAMyW,EAAM,CAAC,IAG7BD,IAAW,KAAK,MAAMC,EAAM,IAAItB,EAAc,4BAA4B;AAAA,cAC3E;AAED,mBAAK,UAAU,IAAI1V,EAAOjB,EAAgB,iBAAiBiY,EAAM,IAAI,GAAGjY,EAAgB,iBAAiBiY,EAAM,IAAI,CAAC,CAAC;AAAA,YACvH,GAEAZ,EAAW,eAAe,SAAUa,GAAMjI,GAAYkI,GAAe;AACnE,kBAAIC,IAAY,KAAK,IAAI,KAAK,kBAAkBF,CAAI,GAAGvB,EAAc,yBAAyB;AAC9F,cAAAU,EAAW,mBAAmBpH,GAAY,MAAM,GAAG,KAAK,GAAGmI,CAAS;AACpE,kBAAIC,IAASvU,EAAO,gBAAgBoU,CAAI,GAEpCI,IAAY,IAAIpK;AACpB,cAAAoK,EAAU,cAAcD,EAAO,QAAS,CAAA,GACxCC,EAAU,cAAcD,EAAO,QAAS,CAAA,GACxCC,EAAU,aAAaH,EAAc,CAAC,GACtCG,EAAU,aAAaH,EAAc,CAAC;AAEtC,uBAASxV,IAAI,GAAGA,IAAIuV,EAAK,QAAQvV,KAAK;AACpC,oBAAIlC,IAAOyX,EAAKvV,CAAC;AACjB,gBAAAlC,EAAK,UAAU6X,CAAS;AAAA,cACzB;AAED,kBAAIC,IAAc,IAAItX,EAAOoX,EAAO,QAAO,GAAIA,EAAO,QAAO,CAAE;AAE/D,qBAAOC,EAAU,sBAAsBC,CAAW;AAAA,YACpD,GAEAlB,EAAW,qBAAqB,SAAU5W,GAAM+X,GAAcC,GAAYC,GAAU1F,GAAU2F,GAAkB;AAE9G,kBAAIC,KAAgBF,IAAWD,IAAa,KAAK;AAEjD,cAAIG,IAAe,MACjBA,KAAgB;AAGlB,kBAAIC,KAAaD,IAAeH,KAAc,KAC1CK,IAAOD,IAAY3Y,EAAU,SAAS,KAItC6Y,IAAK/F,IAAW,KAAK,IAAI8F,CAAI,GAC7BE,IAAKhG,IAAW,KAAK,IAAI8F,CAAI;AAEjC,cAAArY,EAAK,UAAUsY,GAAIC,CAAE;AAIrB,kBAAItT,IAAgB,CAAA;AACpB,cAAAA,IAAgBA,EAAc,OAAOjF,EAAK,SAAU,CAAA;AACpD,kBAAIwY,IAAavT,EAAc;AAE/B,cAAI8S,KAAgB,QAClBS;AAYF,uBATIC,IAAc,GAEdC,IAAgBzT,EAAc,QAC9B0T,GAEAnS,IAAQxG,EAAK,gBAAgB+X,CAAY,GAItCvR,EAAM,SAAS,KAAG;AAEvB,oBAAI+H,IAAO/H,EAAM,CAAC;AAClB,gBAAAA,EAAM,OAAO,GAAG,CAAC;AACjB,oBAAIvC,IAAQgB,EAAc,QAAQsJ,CAAI;AACtC,gBAAItK,KAAS,KACXgB,EAAc,OAAOhB,GAAO,CAAC,GAE/ByU,KACAF;AAAA,cACD;AAED,cAAIT,KAAgB,OAElBY,KAAc1T,EAAc,QAAQuB,EAAM,CAAC,CAAC,IAAI,KAAKkS,IAErDC,IAAa;AAKf,uBAFIC,IAAY,KAAK,IAAIX,IAAWD,CAAU,IAAIQ,GAEzCtW,IAAIyW,GAAYF,KAAeD,GAAYtW,IAAI,EAAEA,IAAIwW,GAAe;AAC3E,oBAAIxT,IAAkBD,EAAc/C,CAAC,EAAE,YAAYlC,CAAI;AAGvD,oBAAIkF,KAAmB6S,GAIvB;AAAA,sBAAIc,KAAmBb,IAAaS,IAAcG,KAAa,KAC3DE,KAAiBD,IAAkBD,KAAa;AAEpD,kBAAAhC,EAAW,mBAAmB1R,GAAiBlF,GAAM6Y,GAAiBC,GAAevG,IAAW2F,GAAkBA,CAAgB,GAElIO;AAAA;AAAA,cACD;AAAA,YACH,GAEA7B,EAAW,oBAAoB,SAAUa,GAAM;AAG7C,uBAFIsB,IAAc1Y,EAAQ,WAEjB6B,IAAI,GAAGA,IAAIuV,EAAK,QAAQvV,KAAK;AACpC,oBAAIlC,IAAOyX,EAAKvV,CAAC,GACb8W,IAAWhZ,EAAK;AAEpB,gBAAIgZ,IAAWD,MACbA,IAAcC;AAAA,cAEjB;AAED,qBAAOD;AAAA,YACT,GAEAnC,EAAW,UAAU,qBAAqB,WAAY;AAEpD,qBAAO,KAAK,KAAK,QAAQ,KAAK,KAAK;AAAA,YACrC,GAKAA,EAAW,UAAU,yBAAyB,WAAY;AACxD,kBAAIlV,IAAO,MAEPuX,IAAmB,CAAA;AACvB,mBAAK,eAAe,IACpB,KAAK,gBAAgB;AAMrB,uBAJIC,IAAa,CAAA,GACbhL,IAAW,KAAK,aAAa,YAAW,GAGnChM,IAAI,GAAGA,IAAIgM,EAAS,QAAQhM,KAAK;AACxC,oBAAIlC,IAAOkO,EAAShM,CAAC,GACjBoB,IAAStD,EAAK;AAElB,gBAAI,KAAK,0BAA0BA,CAAI,MAAM,MAAMsD,EAAO,MAAM,QAAa,CAAC,KAAK,aAAaA,CAAM,MACpG4V,EAAW,KAAKlZ,CAAI;AAAA,cAEvB;AAGD,uBAASkC,IAAI,GAAGA,IAAIgX,EAAW,QAAQhX,KAAK;AAC1C,oBAAIlC,IAAOkZ,EAAWhX,CAAC,GACnBiX,IAAOnZ,EAAK,UAAS,EAAG;AAE5B,gBAAI,OAAOiZ,EAAiBE,CAAI,IAAM,QAAaF,EAAiBE,CAAI,IAAI,KAE5EF,EAAiBE,CAAI,IAAIF,EAAiBE,CAAI,EAAE,OAAOnZ,CAAI;AAAA,cAC5D;AAGD,qBAAO,KAAKiZ,CAAgB,EAAE,QAAQ,SAAUE,GAAM;AACpD,oBAAIF,EAAiBE,CAAI,EAAE,SAAS,GAAG;AACrC,sBAAIC,IAAkB,mBAAmBD;AACzC,kBAAAzX,EAAK,aAAa0X,CAAe,IAAIH,EAAiBE,CAAI;AAE1D,sBAAI7V,IAAS2V,EAAiBE,CAAI,EAAE,CAAC,EAAE,aAGnCE,IAAgB,IAAI9C,EAAS7U,EAAK,YAAY;AAClD,kBAAA2X,EAAc,KAAKD,GACnBC,EAAc,cAAc/V,EAAO,eAAe,GAClD+V,EAAc,eAAe/V,EAAO,gBAAgB,GACpD+V,EAAc,gBAAgB/V,EAAO,iBAAiB,GACtD+V,EAAc,aAAa/V,EAAO,cAAc,GAEhD5B,EAAK,cAAc0X,CAAe,IAAIC;AAEtC,sBAAIC,IAAmB5X,EAAK,gBAAiB,EAAC,IAAIA,EAAK,YAAY2X,CAAa,GAC5EE,IAAcjW,EAAO;AAGzB,kBAAAiW,EAAY,IAAIF,CAAa;AAG7B,2BAASnX,IAAI,GAAGA,IAAI+W,EAAiBE,CAAI,EAAE,QAAQjX,KAAK;AACtD,wBAAIlC,IAAOiZ,EAAiBE,CAAI,EAAEjX,CAAC;AAEnC,oBAAAqX,EAAY,OAAOvZ,CAAI,GACvBsZ,EAAiB,IAAItZ,CAAI;AAAA,kBAC1B;AAAA,gBACF;AAAA,cACL,CAAG;AAAA,YACH,GAEA4W,EAAW,UAAU,iBAAiB,WAAY;AAChD,kBAAI4C,IAAgB,CAAA,GAChBC,IAAW,CAAA;AAGf,mBAAK,sBAAqB;AAE1B,uBAASvX,IAAI,GAAGA,IAAI,KAAK,cAAc,QAAQA;AAE7C,gBAAAuX,EAAS,KAAK,cAAcvX,CAAC,EAAE,EAAE,IAAI,KAAK,cAAcA,CAAC,GACzDsX,EAAc,KAAK,cAActX,CAAC,EAAE,EAAE,IAAI,CAAE,EAAC,OAAO,KAAK,cAAcA,CAAC,EAAE,SAAU,EAAC,SAAQ,CAAE,GAG/F,KAAK,aAAa,OAAO,KAAK,cAAcA,CAAC,EAAE,SAAQ,CAAE,GACzD,KAAK,cAAcA,CAAC,EAAE,QAAQ;AAGhC,mBAAK,aAAa,iBAGlB,KAAK,oBAAoBsX,GAAeC,CAAQ;AAAA,YAClD,GAEA7C,EAAW,UAAU,yBAAyB,WAAY;AACxD,kBAAIlV,IAAO,MACPgY,IAAsB,KAAK,sBAAsB;AAErD,qBAAO,KAAK,KAAK,YAAY,EAAE,QAAQ,SAAUvM,GAAI;AACnD,oBAAIwM,IAAejY,EAAK,cAAcyL,CAAE;AAExC,gBAAAuM,EAAoBvM,CAAE,IAAIzL,EAAK,UAAUA,EAAK,aAAayL,CAAE,GAAGwM,EAAa,cAAcA,EAAa,YAAY,GAGpHA,EAAa,KAAK,QAAQD,EAAoBvM,CAAE,EAAE,OAClDwM,EAAa,KAAK,SAASD,EAAoBvM,CAAE,EAAE;AAAA,cACvD,CAAG;AAAA,YACH,GAEAyJ,EAAW,UAAU,sBAAsB,WAAY;AACrD,uBAAS1U,IAAI,KAAK,cAAc,SAAS,GAAGA,KAAK,GAAGA,KAAK;AACvD,oBAAI0X,IAAgB,KAAK,cAAc1X,CAAC,GACpCiL,IAAKyM,EAAc,IACnBC,IAAmBD,EAAc,aACjCE,IAAiBF,EAAc;AAEnC,qBAAK,gBAAgB,KAAK,gBAAgBzM,CAAE,GAAGyM,EAAc,KAAK,GAAGA,EAAc,KAAK,GAAGC,GAAkBC,CAAc;AAAA,cAC5H;AAAA,YACH,GAEAlD,EAAW,UAAU,8BAA8B,WAAY;AAC7D,kBAAIlV,IAAO,MACPqY,IAAY,KAAK;AAErB,qBAAO,KAAKA,CAAS,EAAE,QAAQ,SAAU5M,GAAI;AAC3C,oBAAIwM,IAAejY,EAAK,cAAcyL,CAAE,GACpC0M,IAAmBF,EAAa,aAChCG,IAAiBH,EAAa;AAGlC,gBAAAjY,EAAK,gBAAgBqY,EAAU5M,CAAE,GAAGwM,EAAa,KAAK,GAAGA,EAAa,KAAK,GAAGE,GAAkBC,CAAc;AAAA,cAClH,CAAG;AAAA,YACH,GAEAlD,EAAW,UAAU,eAAe,SAAU5W,GAAM;AAClD,kBAAImN,IAAKnN,EAAK;AAEd,kBAAI,KAAK,UAAUmN,CAAE,KAAK;AACxB,uBAAO,KAAK,UAAUA,CAAE;AAI1B,kBAAIzK,IAAa1C,EAAK;AACtB,kBAAI0C,KAAc;AAChB,4BAAK,UAAUyK,CAAE,IAAI,IACd;AAMT,uBAHInL,IAAWU,EAAW,YAGjBR,IAAI,GAAGA,IAAIF,EAAS,QAAQE,KAAK;AACxC,oBAAI8X,IAAWhY,EAASE,CAAC;AAEzB,oBAAI,KAAK,cAAc8X,CAAQ,IAAI;AACjC,8BAAK,UAAU7M,CAAE,IAAI,IACd;AAIT,oBAAI6M,EAAS,SAAU,KAAI,MAAM;AAC/B,uBAAK,UAAUA,EAAS,EAAE,IAAI;AAC9B;AAAA,gBACD;AAED,oBAAI,CAAC,KAAK,aAAaA,CAAQ;AAC7B,8BAAK,UAAU7M,CAAE,IAAI,IACd;AAAA,cAEV;AACD,0BAAK,UAAUA,CAAE,IAAI,IACd;AAAA,YACT,GAGAyJ,EAAW,UAAU,gBAAgB,SAAU5W,GAAM;AAC1C,cAAAA,EAAK;AAKd,uBAJIwG,IAAQxG,EAAK,YACbyP,IAAS,GAGJvN,IAAI,GAAGA,IAAIsE,EAAM,QAAQtE,KAAK;AACrC,oBAAIP,IAAO6E,EAAMtE,CAAC;AAClB,gBAAIP,EAAK,YAAY,OAAOA,EAAK,UAAW,EAAC,OAC3C8N,IAASA,IAAS;AAAA,cAErB;AACD,qBAAOA;AAAA,YACT,GAGAmH,EAAW,UAAU,4BAA4B,SAAU5W,GAAM;AAC/D,kBAAIyP,IAAS,KAAK,cAAczP,CAAI;AACpC,kBAAIA,EAAK,SAAU,KAAI;AACrB,uBAAOyP;AAGT,uBADIzN,IAAWhC,EAAK,SAAU,EAAC,SAAQ,GAC9BkC,IAAI,GAAGA,IAAIF,EAAS,QAAQE,KAAK;AACxC,oBAAI+X,IAAQjY,EAASE,CAAC;AACtB,gBAAAuN,KAAU,KAAK,0BAA0BwK,CAAK;AAAA,cAC/C;AACD,qBAAOxK;AAAA,YACT,GAEAmH,EAAW,UAAU,wBAAwB,WAAY;AACvD,mBAAK,gBAAgB,IACrB,KAAK,qBAAqB,KAAK,aAAa,QAAS,EAAC,SAAQ,CAAE;AAAA,YAClE,GAEAA,EAAW,UAAU,uBAAuB,SAAU5U,GAAU;AAC9D,uBAASE,IAAI,GAAGA,IAAIF,EAAS,QAAQE,KAAK;AACxC,oBAAI+X,IAAQjY,EAASE,CAAC;AACtB,gBAAI+X,EAAM,SAAU,KAAI,QACtB,KAAK,qBAAqBA,EAAM,SAAQ,EAAG,SAAU,CAAA,GAEnD,KAAK,aAAaA,CAAK,KACzB,KAAK,cAAc,KAAKA,CAAK;AAAA,cAEhC;AAAA,YACH,GAKArD,EAAW,UAAU,kBAAkB,SAAUsD,GAAc9Y,GAAGC,GAAG8Y,GAA0BC,GAAwB;AACrH,cAAAhZ,KAAK+Y,GACL9Y,KAAK+Y;AAIL,uBAFIxX,IAAOxB,GAEFc,IAAI,GAAGA,IAAIgY,EAAa,KAAK,QAAQhY,KAAK;AACjD,oBAAImY,IAAMH,EAAa,KAAKhY,CAAC;AAC7B,gBAAAd,IAAIwB;AAGJ,yBAFI0X,IAAY,GAEP7I,IAAI,GAAGA,IAAI4I,EAAI,QAAQ5I,KAAK;AACnC,sBAAI8I,IAAQF,EAAI5I,CAAC;AAEjB,kBAAA8I,EAAM,KAAK,IAAInZ,GACfmZ,EAAM,KAAK,IAAIlZ,GAEfD,KAAKmZ,EAAM,KAAK,QAAQL,EAAa,mBAEjCK,EAAM,KAAK,SAASD,MAAWA,IAAYC,EAAM,KAAK;AAAA,gBAC3D;AAED,gBAAAlZ,KAAKiZ,IAAYJ,EAAa;AAAA,cAC/B;AAAA,YACH,GAEAtD,EAAW,UAAU,sBAAsB,SAAU4C,GAAeC,GAAU;AAC5E,kBAAI/X,IAAO;AACX,mBAAK,kBAAkB,IAEvB,OAAO,KAAK8X,CAAa,EAAE,QAAQ,SAAUrM,GAAI;AAE/C,oBAAIwM,IAAeF,EAAStM,CAAE;AAE9B,gBAAAzL,EAAK,gBAAgByL,CAAE,IAAIzL,EAAK,UAAU8X,EAAcrM,CAAE,GAAGwM,EAAa,cAAcA,EAAa,YAAY,GAEjHA,EAAa,KAAK,QAAQjY,EAAK,gBAAgByL,CAAE,EAAE,OACnDwM,EAAa,KAAK,SAASjY,EAAK,gBAAgByL,CAAE,EAAE;AAAA,cACxD,CAAG;AAAA,YACH,GAEAyJ,EAAW,UAAU,YAAY,SAAU3U,GAAOuY,GAAU;AAC1D,kBAAIC,IAAkBvE,EAAc,yBAChCwE,IAAoBxE,EAAc,2BAClCgE,IAAe;AAAA,gBACjB,MAAM,CAAE;AAAA,gBACR,UAAU,CAAE;AAAA,gBACZ,WAAW,CAAE;AAAA,gBACb,OAAO;AAAA,gBACP,QAAQM;AAAA;AAAA,gBACR,iBAAiBC;AAAA,gBACjB,mBAAmBC;AAAA,cACvB;AAGE,cAAAzY,EAAM,KAAK,SAAU0Y,GAAIC,GAAI;AAC3B,uBAAID,EAAG,KAAK,QAAQA,EAAG,KAAK,SAASC,EAAG,KAAK,QAAQA,EAAG,KAAK,SAAe,KACxED,EAAG,KAAK,QAAQA,EAAG,KAAK,SAASC,EAAG,KAAK,QAAQA,EAAG,KAAK,SAAe,IACrE;AAAA,cACX,CAAG;AAGD,uBAAS1Y,IAAI,GAAGA,IAAID,EAAM,QAAQC,KAAK;AACrC,oBAAIqC,IAAQtC,EAAMC,CAAC;AAEnB,gBAAIgY,EAAa,KAAK,UAAU,IAC9B,KAAK,gBAAgBA,GAAc3V,GAAO,GAAGiW,CAAQ,IAC5C,KAAK,iBAAiBN,GAAc3V,EAAM,KAAK,OAAOA,EAAM,KAAK,MAAM,IAChF,KAAK,gBAAgB2V,GAAc3V,GAAO,KAAK,oBAAoB2V,CAAY,GAAGM,CAAQ,IAE1F,KAAK,gBAAgBN,GAAc3V,GAAO2V,EAAa,KAAK,QAAQM,CAAQ,GAG9E,KAAK,eAAeN,CAAY;AAAA,cACjC;AAED,qBAAOA;AAAA,YACT,GAEAtD,EAAW,UAAU,kBAAkB,SAAUsD,GAAcla,GAAM6a,GAAUL,GAAU;AACvF,kBAAIM,IAAkBN;AAGtB,kBAAIK,KAAYX,EAAa,KAAK,QAAQ;AACxC,oBAAIa,IAAkB,CAAA;AAEtB,gBAAAb,EAAa,KAAK,KAAKa,CAAe,GACtCb,EAAa,SAAS,KAAKY,CAAe,GAC1CZ,EAAa,UAAU,KAAK,CAAC;AAAA,cAC9B;AAGD,kBAAIc,IAAId,EAAa,SAASW,CAAQ,IAAI7a,EAAK,KAAK;AAEpD,cAAIka,EAAa,KAAKW,CAAQ,EAAE,SAAS,MACvCG,KAAKd,EAAa,oBAGpBA,EAAa,SAASW,CAAQ,IAAIG,GAE9Bd,EAAa,QAAQc,MACvBd,EAAa,QAAQc;AAIvB,kBAAIC,IAAIjb,EAAK,KAAK;AAClB,cAAI6a,IAAW,MAAGI,KAAKf,EAAa;AAEpC,kBAAIgB,IAAc;AAClB,cAAID,IAAIf,EAAa,UAAUW,CAAQ,MACrCK,IAAchB,EAAa,UAAUW,CAAQ,GAC7CX,EAAa,UAAUW,CAAQ,IAAII,GACnCC,IAAchB,EAAa,UAAUW,CAAQ,IAAIK,IAGnDhB,EAAa,UAAUgB,GAGvBhB,EAAa,KAAKW,CAAQ,EAAE,KAAK7a,CAAI;AAAA,YACvC,GAGA4W,EAAW,UAAU,sBAAsB,SAAUsD,GAAc;AAIjE,uBAHI1O,IAAI,IACJ2P,IAAM,OAAO,WAERjZ,IAAI,GAAGA,IAAIgY,EAAa,KAAK,QAAQhY;AAC5C,gBAAIgY,EAAa,SAAShY,CAAC,IAAIiZ,MAC7B3P,IAAItJ,GACJiZ,IAAMjB,EAAa,SAAShY,CAAC;AAGjC,qBAAOsJ;AAAA,YACT,GAGAoL,EAAW,UAAU,qBAAqB,SAAUsD,GAAc;AAIhE,uBAHI1O,IAAI,IACJ4P,IAAM,OAAO,WAERlZ,IAAI,GAAGA,IAAIgY,EAAa,KAAK,QAAQhY;AAE5C,gBAAIgY,EAAa,SAAShY,CAAC,IAAIkZ,MAC7B5P,IAAItJ,GACJkZ,IAAMlB,EAAa,SAAShY,CAAC;AAIjC,qBAAOsJ;AAAA,YACT,GAMAoL,EAAW,UAAU,mBAAmB,SAAUsD,GAAcmB,GAAYH,GAAa;AAEvF,kBAAII,IAAM,KAAK,oBAAoBpB,CAAY;AAE/C,kBAAIoB,IAAM;AACR,uBAAO;AAGT,kBAAIH,IAAMjB,EAAa,SAASoB,CAAG;AAEnC,kBAAIH,IAAMjB,EAAa,oBAAoBmB,KAAcnB,EAAa;AAAO,uBAAO;AAEpF,kBAAIqB,IAAQ;AAGZ,cAAIrB,EAAa,UAAUoB,CAAG,IAAIJ,KAC5BI,IAAM,MAAGC,IAAQL,IAAchB,EAAa,kBAAkBA,EAAa,UAAUoB,CAAG;AAG9F,kBAAIE;AACJ,cAAItB,EAAa,QAAQiB,KAAOE,IAAanB,EAAa,oBACxDsB,KAAoBtB,EAAa,SAASqB,MAAUJ,IAAME,IAAanB,EAAa,qBAEpFsB,KAAoBtB,EAAa,SAASqB,KAASrB,EAAa,OAIlEqB,IAAQL,IAAchB,EAAa;AACnC,kBAAIuB;AACJ,qBAAIvB,EAAa,QAAQmB,IACvBI,KAAqBvB,EAAa,SAASqB,KAASF,IAEpDI,KAAqBvB,EAAa,SAASqB,KAASrB,EAAa,OAG/DuB,IAAoB,MAAGA,IAAoB,IAAIA,IAE/CD,IAAmB,MAAGA,IAAmB,IAAIA,IAE1CA,IAAmBC;AAAA,YAC5B,GAIA7E,EAAW,UAAU,iBAAiB,SAAUsD,GAAc;AAC5D,kBAAIwB,IAAU,KAAK,mBAAmBxB,CAAY,GAC9CyB,IAAOzB,EAAa,SAAS,SAAS,GACtCG,IAAMH,EAAa,KAAKwB,CAAO,GAC/B1b,IAAOqa,EAAIA,EAAI,SAAS,CAAC,GAEzBuB,IAAO5b,EAAK,QAAQka,EAAa;AAGrC,kBAAIA,EAAa,QAAQA,EAAa,SAASyB,CAAI,IAAIC,KAAQF,KAAWC,GAAM;AAE9E,gBAAAtB,EAAI,OAAO,IAAI,CAAC,GAGhBH,EAAa,KAAKyB,CAAI,EAAE,KAAK3b,CAAI,GAEjCka,EAAa,SAASwB,CAAO,IAAIxB,EAAa,SAASwB,CAAO,IAAIE,GAClE1B,EAAa,SAASyB,CAAI,IAAIzB,EAAa,SAASyB,CAAI,IAAIC,GAC5D1B,EAAa,QAAQA,EAAa,SAAS,SAAS,mBAAmBA,CAAY,CAAC;AAIpF,yBADII,IAAY,OAAO,WACdpY,IAAI,GAAGA,IAAImY,EAAI,QAAQnY;AAC9B,kBAAImY,EAAInY,CAAC,EAAE,SAASoY,MAAWA,IAAYD,EAAInY,CAAC,EAAE;AAEpD,gBAAIwZ,IAAU,MAAGpB,KAAaJ,EAAa;AAE3C,oBAAI2B,IAAY3B,EAAa,UAAUwB,CAAO,IAAIxB,EAAa,UAAUyB,CAAI;AAE7E,gBAAAzB,EAAa,UAAUwB,CAAO,IAAIpB,GAC9BJ,EAAa,UAAUyB,CAAI,IAAI3b,EAAK,SAASka,EAAa,oBAAiBA,EAAa,UAAUyB,CAAI,IAAI3b,EAAK,SAASka,EAAa;AAEzI,oBAAI4B,IAAa5B,EAAa,UAAUwB,CAAO,IAAIxB,EAAa,UAAUyB,CAAI;AAC9E,gBAAAzB,EAAa,UAAU4B,IAAaD,GAEpC,KAAK,eAAe3B,CAAY;AAAA,cACjC;AAAA,YACH,GAEAtD,EAAW,UAAU,kBAAkB,WAAY;AACjD,cAAIV,EAAc,SAEhB,KAAK,uBAAsB,GAE3B,KAAK,eAAc,GAEnB,KAAK,uBAAsB;AAAA,YAE/B,GAEAU,EAAW,UAAU,mBAAmB,WAAY;AAClD,cAAIV,EAAc,SAChB,KAAK,4BAA2B,GAChC,KAAK,oBAAmB;AAAA,YAE5B,GAMAU,EAAW,UAAU,cAAc,WAAY;AAK7C,uBAJImF,IAAiB,CAAA,GACjBC,IAAe,IACfhc,GAEGgc,KAAc;AACnB,oBAAI9N,IAAW,KAAK,aAAa,YAAW,GACxC+N,IAAwB,CAAA;AAC5B,gBAAAD,IAAe;AAEf,yBAAS9Z,IAAI,GAAGA,IAAIgM,EAAS,QAAQhM;AACnC,kBAAAlC,IAAOkO,EAAShM,CAAC,GACblC,EAAK,SAAQ,EAAG,UAAU,KAAK,CAACA,EAAK,SAAQ,EAAG,CAAC,EAAE,gBAAgBA,EAAK,SAAQ,KAAM,SACxFic,EAAsB,KAAK,CAACjc,GAAMA,EAAK,WAAW,CAAC,GAAGA,EAAK,SAAQ,CAAE,CAAC,GACtEgc,IAAe;AAGnB,oBAAIA,KAAgB,IAAM;AAExB,2BADIE,IAAoB,CAAA,GACfzK,IAAI,GAAGA,IAAIwK,EAAsB,QAAQxK;AAChD,oBAAIwK,EAAsBxK,CAAC,EAAE,CAAC,EAAE,SAAU,EAAC,UAAU,MACnDyK,EAAkB,KAAKD,EAAsBxK,CAAC,CAAC,GAC/CwK,EAAsBxK,CAAC,EAAE,CAAC,EAAE,SAAQ,EAAG,OAAOwK,EAAsBxK,CAAC,EAAE,CAAC,CAAC;AAG7E,kBAAAsK,EAAe,KAAKG,CAAiB,GACrC,KAAK,aAAa,iBAClB,KAAK,aAAa;gBACnB;AAAA,cACF;AACD,mBAAK,iBAAiBH;AAAA,YACxB,GAGAnF,EAAW,UAAU,WAAW,SAAUmF,GAAgB;AAKxD,uBAJII,IAA4BJ,EAAe,QAC3CG,IAAoBH,EAAeI,IAA4B,CAAC,GAEhEC,GACKla,IAAI,GAAGA,IAAIga,EAAkB,QAAQha;AAC5C,gBAAAka,IAAWF,EAAkBha,CAAC,GAE9B,KAAK,uBAAuBka,CAAQ,GAEpCA,EAAS,CAAC,EAAE,IAAIA,EAAS,CAAC,CAAC,GAC3BA,EAAS,CAAC,EAAE,IAAIA,EAAS,CAAC,GAAGA,EAAS,CAAC,EAAE,QAAQA,EAAS,CAAC,EAAE,MAAM;AAGrE,cAAAL,EAAe,OAAOA,EAAe,SAAS,GAAG,CAAC,GAClD,KAAK,aAAa,iBAClB,KAAK,aAAa;YACpB,GAGAnF,EAAW,UAAU,yBAAyB,SAAUwF,GAAU;AAEhE,kBAAIC,GACAC,GACAC,IAAaH,EAAS,CAAC;AAC3B,cAAIG,KAAcH,EAAS,CAAC,EAAE,SAC5BE,IAAgBF,EAAS,CAAC,EAAE,SAE5BE,IAAgBF,EAAS,CAAC,EAAE;AAE9B,kBAAII,IAAaF,EAAc,QAC3BG,IAAcH,EAAc,SAC5BI,IAAaJ,EAAc,QAC3BK,IAAcL,EAAc,SAE5BM,IAAc,GACdC,IAAgB,GAChBC,IAAiB,GACjBC,IAAgB,GAChBC,IAAiB,CAACJ,GAAaE,GAAgBD,GAAeE,CAAa;AAE/E,kBAAIL,IAAa;AACf,yBAASxa,IAAIsa,GAAYta,KAAKua,GAAava;AACzC,kBAAA8a,EAAe,CAAC,KAAK,KAAK,KAAK9a,CAAC,EAAEwa,IAAa,CAAC,EAAE,SAAS,KAAK,KAAKxa,CAAC,EAAEwa,CAAU,EAAE,SAAS;AAGjG,kBAAID,IAAc,KAAK,KAAK,SAAS;AACnC,yBAASva,IAAIwa,GAAYxa,KAAKya,GAAaza;AACzC,kBAAA8a,EAAe,CAAC,KAAK,KAAK,KAAKP,IAAc,CAAC,EAAEva,CAAC,EAAE,SAAS,KAAK,KAAKua,CAAW,EAAEva,CAAC,EAAE,SAAS;AAGnG,kBAAIya,IAAc,KAAK,KAAK,CAAC,EAAE,SAAS;AACtC,yBAASza,IAAIsa,GAAYta,KAAKua,GAAava;AACzC,kBAAA8a,EAAe,CAAC,KAAK,KAAK,KAAK9a,CAAC,EAAEya,IAAc,CAAC,EAAE,SAAS,KAAK,KAAKza,CAAC,EAAEya,CAAW,EAAE,SAAS;AAGnG,kBAAIH,IAAa;AACf,yBAASta,IAAIwa,GAAYxa,KAAKya,GAAaza;AACzC,kBAAA8a,EAAe,CAAC,KAAK,KAAK,KAAKR,IAAa,CAAC,EAAEta,CAAC,EAAE,SAAS,KAAK,KAAKsa,CAAU,EAAEta,CAAC,EAAE,SAAS;AAMjG,uBAHIiZ,IAAM9a,EAAQ,WACd4c,GACAC,GACKzL,IAAI,GAAGA,IAAIuL,EAAe,QAAQvL;AACzC,gBAAIuL,EAAevL,CAAC,IAAI0J,KACtBA,IAAM6B,EAAevL,CAAC,GACtBwL,IAAW,GACXC,IAAWzL,KACFuL,EAAevL,CAAC,KAAK0J,KAC9B8B;AAIJ,kBAAIA,KAAY,KAAK9B,KAAO;AAC1B,gBAAI6B,EAAe,CAAC,KAAK,KAAKA,EAAe,CAAC,KAAK,KAAKA,EAAe,CAAC,KAAK,IAC3EX,IAAoB,IACXW,EAAe,CAAC,KAAK,KAAKA,EAAe,CAAC,KAAK,KAAKA,EAAe,CAAC,KAAK,IAClFX,IAAoB,IACXW,EAAe,CAAC,KAAK,KAAKA,EAAe,CAAC,KAAK,KAAKA,EAAe,CAAC,KAAK,IAClFX,IAAoB,IACXW,EAAe,CAAC,KAAK,KAAKA,EAAe,CAAC,KAAK,KAAKA,EAAe,CAAC,KAAK,MAClFX,IAAoB;AAAA,uBAEbY,KAAY,KAAK9B,KAAO,GAAG;AACpC,oBAAIgC,IAAS,KAAK,MAAM,KAAK,OAAM,IAAK,CAAC;AACzC,gBAAIH,EAAe,CAAC,KAAK,KAAKA,EAAe,CAAC,KAAK,IAE7CG,KAAU,IACZd,IAAoB,IAEpBA,IAAoB,IAEbW,EAAe,CAAC,KAAK,KAAKA,EAAe,CAAC,KAAK,IACpDG,KAAU,IACZd,IAAoB,IAEpBA,IAAoB,IAEbW,EAAe,CAAC,KAAK,KAAKA,EAAe,CAAC,KAAK,IACpDG,KAAU,IACZd,IAAoB,IAEpBA,IAAoB,IAEbW,EAAe,CAAC,KAAK,KAAKA,EAAe,CAAC,KAAK,IACpDG,KAAU,IACZd,IAAoB,IAEpBA,IAAoB,IAEbW,EAAe,CAAC,KAAK,KAAKA,EAAe,CAAC,KAAK,IACpDG,KAAU,IACZd,IAAoB,IAEpBA,IAAoB,IAGlBc,KAAU,IACZd,IAAoB,IAEpBA,IAAoB;AAAA,cAGzB,WAAUY,KAAY,KAAK9B,KAAO,GAAG;AACpC,oBAAIgC,IAAS,KAAK,MAAM,KAAK,OAAM,IAAK,CAAC;AACzC,gBAAAd,IAAoBc;AAAA,cACxB;AACI,gBAAAd,IAAoBa;AAGtB,cAAIb,KAAqB,IACvBE,EAAW,UAAUD,EAAc,WAAY,GAAEA,EAAc,WAAU,IAAKA,EAAc,UAAS,IAAK,IAAI1V,EAAkB,sBAAsB2V,EAAW,UAAS,IAAK,CAAC,IACvKF,KAAqB,IAC9BE,EAAW,UAAUD,EAAc,WAAY,IAAGA,EAAc,SAAQ,IAAK,IAAI1V,EAAkB,sBAAsB2V,EAAW,SAAU,IAAG,GAAGD,EAAc,WAAU,CAAE,IACrKD,KAAqB,IAC9BE,EAAW,UAAUD,EAAc,WAAY,GAAEA,EAAc,WAAU,IAAKA,EAAc,UAAS,IAAK,IAAI1V,EAAkB,sBAAsB2V,EAAW,UAAS,IAAK,CAAC,IAEhLA,EAAW,UAAUD,EAAc,WAAY,IAAGA,EAAc,SAAQ,IAAK,IAAI1V,EAAkB,sBAAsB2V,EAAW,SAAU,IAAG,GAAGD,EAAc,WAAU,CAAE;AAAA,YAElL,GAEA3d,EAAO,UAAUiY;AAAA,UAEV;AAAA;AAAA;AAAA,UAEA,SAASjY,GAAQO,GAASH,GAAqB;AAKtD,gBAAIqe,IAAW,CAAA;AAEf,YAAAA,EAAS,aAAare,EAAoB,CAAC,GAC3Cqe,EAAS,gBAAgBre,EAAoB,CAAC,GAC9Cqe,EAAS,WAAWre,EAAoB,CAAC,GACzCqe,EAAS,YAAYre,EAAoB,CAAC,GAC1Cqe,EAAS,mBAAmBre,EAAoB,CAAC,GACjDqe,EAAS,aAAare,EAAoB,CAAC,GAC3Cqe,EAAS,WAAWre,EAAoB,CAAC,GAEzCJ,EAAO,UAAUye;AAAA,UAEV;AAAA;AAAA,QACP,CAAU;AAAA;AAAA,IACV,CAAC;AAAA;;;ACt6CD,GAAC,SAA0C3e,GAAMC,GAAS;AAExD,IAAAC,EAAiB,UAAAD,EAAQsX,GAAoB,CAAA;AAAA,EAO/C,GAAGpX,GAAM,SAASqX,GAA+B;AACjD;AAAA;AAAA,MAAiB,SAASpX,GAAS;AAEzB,YAAIC,IAAmB,CAAA;AAGvB,iBAASC,EAAoBC,GAAU;AAGtC,cAAGF,EAAiBE,CAAQ;AAC3B,mBAAOF,EAAiBE,CAAQ,EAAE;AAGnC,cAAIL,IAASG,EAAiBE,CAAQ,IAAI;AAAA;AAAA,YACzC,GAAGA;AAAA;AAAA,YACH,GAAG;AAAA;AAAA,YACH,SAAS,CAAE;AAAA;AAAA,UACvB;AAGW,iBAAAH,EAAQG,CAAQ,EAAE,KAAKL,EAAO,SAASA,GAAQA,EAAO,SAASI,CAAmB,GAGlFJ,EAAO,IAAI,IAGJA,EAAO;AAAA,QACd;AAID,eAAAI,EAAoB,IAAIF,GAGxBE,EAAoB,IAAID,GAGxBC,EAAoB,IAAI,SAASE,GAAO;AAAE,iBAAOA;AAAA,QAAM,GAGvDF,EAAoB,IAAI,SAASG,GAASC,GAAMC,GAAQ;AACvD,UAAIL,EAAoB,EAAEG,GAASC,CAAI,KACtC,OAAO,eAAeD,GAASC,GAAM;AAAA;AAAA,YACpC,cAAc;AAAA;AAAA,YACd,YAAY;AAAA;AAAA,YACZ,KAAKC;AAAA;AAAA,UAClB,CAAa;AAAA,QAEb,GAGUL,EAAoB,IAAI,SAASJ,GAAQ;AACxC,cAAIS,IAAST,KAAUA,EAAO;AAAA;AAAA,YAC7B,WAAsB;AAAE,qBAAOA,EAAO;AAAA,YAAa;AAAA;AAAA;AAAA,YACnD,WAA4B;AAAE,qBAAOA;AAAA;;AACtC,iBAAAI,EAAoB,EAAEK,GAAQ,KAAKA,CAAM,GAClCA;AAAA,QAClB,GAGUL,EAAoB,IAAI,SAASM,GAAQC,GAAU;AAAE,iBAAO,OAAO,UAAU,eAAe,KAAKD,GAAQC,CAAQ;AAAA,QAAE,GAGnHP,EAAoB,IAAI,IAGjBA,EAAoBA,EAAoB,IAAI,CAAC;AAAA,MACpD,EAEA;AAAA;AAAA;AAAA,QAEH,SAASJ,GAAQO,GAAS;AAEjC,UAAAP,EAAO,UAAUsX;AAAA,QAEV;AAAA;AAAA;AAAA,QAEA,SAAStX,GAAQO,GAASH,GAAqB;AAKtD,cAAIQ,IAAkBR,EAAoB,CAAC,EAAE,WAAW,iBACpD6H,IAAoB7H,EAAoB,CAAC,EAAE,WAAW,mBACtDmX,IAAgBnX,EAAoB,CAAC,EAAE,eACvC6X,IAAa7X,EAAoB,CAAC,EAAE,YACpCwX,IAAWxX,EAAoB,CAAC,EAAE,UAClCyB,IAASzB,EAAoB,CAAC,EAAE,WAAW,QAC3CkV,IAAalV,EAAoB,CAAC,EAAE,WAAW,YAE/Cse,IAAW;AAAA;AAAA,YAEb,OAAO,WAAiB;AAAA,YAAE;AAAA;AAAA,YAE1B,MAAM,WAAgB;AAAA,YAAE;AAAA;AAAA;AAAA;AAAA;AAAA,YAKxB,SAAS;AAAA;AAAA,YAET,6BAA6B;AAAA;AAAA,YAE7B,SAAS;AAAA;AAAA,YAET,KAAK;AAAA;AAAA,YAEL,SAAS;AAAA;AAAA,YAET,WAAW;AAAA;AAAA,YAEX,eAAe;AAAA;AAAA,YAEf,iBAAiB;AAAA;AAAA,YAEjB,gBAAgB;AAAA;AAAA,YAEhB,eAAe;AAAA;AAAA,YAEf,SAAS;AAAA;AAAA,YAET,SAAS;AAAA;AAAA,YAET,MAAM;AAAA;AAAA,YAEN,SAAS;AAAA;AAAA,YAET,mBAAmB;AAAA;AAAA,YAEnB,uBAAuB;AAAA;AAAA,YAEvB,yBAAyB;AAAA;AAAA,YAEzB,sBAAsB;AAAA;AAAA,YAEtB,iBAAiB;AAAA;AAAA,YAEjB,cAAc;AAAA;AAAA,YAEd,4BAA4B;AAAA,UAC9B;AAEA,mBAASC,EAAOD,GAAUE,GAAS;AACjC,gBAAIzZ,IAAM,CAAA;AAEV,qBAAS5B,KAAKmb;AACZ,cAAAvZ,EAAI5B,CAAC,IAAImb,EAASnb,CAAC;AAGrB,qBAASA,KAAKqb;AACZ,cAAAzZ,EAAI5B,CAAC,IAAIqb,EAAQrb,CAAC;AAGpB,mBAAO4B;AAAA,UAET;AACA,mBAAS0Z,EAAYC,GAAU;AAC7B,iBAAK,UAAUH,EAAOD,GAAUI,CAAQ,GACxCC,EAAe,KAAK,OAAO;AAAA,UAC5B;AAED,cAAIA,IAAiB,SAAwBH,GAAS;AACpD,YAAIA,EAAQ,iBAAiB,SAAMrH,EAAc,6BAA6BtP,EAAkB,6BAA6B2W,EAAQ,gBACjIA,EAAQ,mBAAmB,SAAMrH,EAAc,sBAAsBtP,EAAkB,sBAAsB2W,EAAQ,kBACrHA,EAAQ,kBAAkB,SAAMrH,EAAc,0BAA0BtP,EAAkB,0BAA0B2W,EAAQ,iBAC5HA,EAAQ,iBAAiB,SAAMrH,EAAc,qCAAqCtP,EAAkB,qCAAqC2W,EAAQ,gBACjJA,EAAQ,WAAW,SAAMrH,EAAc,2BAA2BtP,EAAkB,2BAA2B2W,EAAQ,UACvHA,EAAQ,WAAW,SAAMrH,EAAc,iBAAiBtP,EAAkB,iBAAiB2W,EAAQ,UACnGA,EAAQ,gBAAgB,SAAMrH,EAAc,+BAA+BtP,EAAkB,+BAA+B2W,EAAQ,eACpIA,EAAQ,mBAAmB,SAAMrH,EAAc,oCAAoCtP,EAAkB,oCAAoC2W,EAAQ,kBACjJA,EAAQ,wBAAwB,SAAMrH,EAAc,wCAAwCtP,EAAkB,wCAAwC2W,EAAQ,uBAC9JA,EAAQ,8BAA8B,SAAMrH,EAAc,qCAAqCtP,EAAkB,qCAAqC2W,EAAQ,6BAE9JA,EAAQ,WAAW,UAAShe,EAAgB,UAAU,IAAWge,EAAQ,WAAW,UAAShe,EAAgB,UAAU,IAAOA,EAAgB,UAAU,GAE5J2W,EAAc,iCAAiCtP,EAAkB,iCAAiCrH,EAAgB,iCAAiCge,EAAQ,6BAC3JrH,EAAc,sBAAsBtP,EAAkB,sBAAsBrH,EAAgB,sBAAsB,CAACge,EAAQ,WAC3HrH,EAAc,UAAUtP,EAAkB,UAAUrH,EAAgB,UAAUge,EAAQ,SACtFrH,EAAc,OAAOqH,EAAQ,MAC7BrH,EAAc,0BAA0B,OAAOqH,EAAQ,yBAA0B,aAAaA,EAAQ,sBAAsB,SAASA,EAAQ,uBAC7IrH,EAAc,4BAA4B,OAAOqH,EAAQ,2BAA4B,aAAaA,EAAQ,wBAAwB,SAASA,EAAQ;AAAA,UACrJ;AAEA,UAAAC,EAAY,UAAU,MAAM,WAAY;AACtC,gBAAIG,GACAC,GACAL,IAAU,KAAK;AACH,iBAAK,YAAY,CAAG;AACpC,gBAAI/X,IAAS,KAAK,SAAS,IAAIoR,EAAU,GACrClV,IAAO;AAEX,YAAAA,EAAK,UAAU,IAEf,KAAK,KAAK,KAAK,QAAQ,IAEvB,KAAK,GAAG,QAAQ,EAAE,MAAM,eAAe,QAAQ,KAAI,CAAE;AAErD,gBAAIhB,IAAK8E,EAAO;AAChB,iBAAK,KAAK9E;AAEV,gBAAIuB,IAAQ,KAAK,QAAQ,KAAK,MAAK,GAC/BuE,IAAQ,KAAK,QAAQ,KAAK,MAAK;AAEnC,iBAAK,OAAO9F,EAAG,WACf,KAAK,oBAAoB,KAAK,MAAM,KAAK,gBAAgBuB,CAAK,GAAGuD,CAAM;AAEvE,qBAAStD,IAAI,GAAGA,IAAIsE,EAAM,QAAQtE,KAAK;AACrC,kBAAIP,IAAO6E,EAAMtE,CAAC,GACdwB,IAAa,KAAK,UAAU/B,EAAK,KAAK,QAAQ,CAAC,GAC/CgC,IAAa,KAAK,UAAUhC,EAAK,KAAK,QAAQ,CAAC;AACnD,kBAAI+B,MAAeC,KAAcD,EAAW,gBAAgBC,CAAU,EAAE,UAAU,GAAG;AACnF,oBAAIka,IAAKnd,EAAG,IAAI8E,EAAO,WAAW9B,GAAYC,CAAU;AACxD,gBAAAka,EAAG,KAAKlc,EAAK;cACd;AAAA,YACF;AAED,gBAAImc,IAAe,SAAsBC,GAAK7b,GAAG;AAC/C,cAAI,OAAO6b,KAAQ,aACjBA,IAAM7b;AAER,kBAAIkS,IAAQ2J,EAAI,KAAK,IAAI,GACrBxZ,IAAQ7C,EAAK,UAAU0S,CAAK;AAEhC,qBAAO;AAAA,gBACL,GAAG7P,EAAM,QAAS,EAAC,WAAY;AAAA,gBAC/B,GAAGA,EAAM,QAAS,EAAC,WAAY;AAAA,cACrC;AAAA,YACA,GAKMyZ,IAAkB,SAASA,IAAkB;AAiB/C,uBAfIC,IAAkB,WAA2B;AAC/C,gBAAIV,EAAQ,OACVA,EAAQ,GAAG,IAAIA,EAAQ,MAAMA,EAAQ,OAAO,GAGzCI,MACHA,IAAQ,IACRjc,EAAK,GAAG,IAAI,eAAe6b,EAAQ,KAAK,GACxC7b,EAAK,GAAG,QAAQ,EAAE,MAAM,eAAe,QAAQA,EAAI,CAAE;AAAA,cAE7D,GAEQwc,IAAgBxc,EAAK,QAAQ,SAC7Byc,GAEKjc,IAAI,GAAGA,IAAIgc,KAAiB,CAACC,GAAQjc;AAC5C,gBAAAic,IAASzc,EAAK,WAAWA,EAAK,OAAO,KAAI;AAI3C,kBAAIyc,GAAQ;AAEV,gBAAI3Y,EAAO,mBAAkB,KAAM,CAACA,EAAO,eACzCA,EAAO,aAAY,GAIjBA,EAAO,oBACTA,EAAO,iBAAgB,GAGzBA,EAAO,mBAAmB,IAE1B9D,EAAK,QAAQ,KAAK,MAAK,EAAG,UAAUoc,CAAY,GAEhDG,KAGAvc,EAAK,GAAG,IAAI,cAAcA,EAAK,QAAQ,IAAI,GAC3CA,EAAK,GAAG,QAAQ,EAAE,MAAM,cAAc,QAAQA,EAAI,CAAE,GAEhDkc,KACF,qBAAqBA,CAAO,GAG9BD,IAAQ;AACR;AAAA,cACD;AAED,kBAAIS,IAAgB1c,EAAK,OAAO,iBAAgB;AAIhD,cAAA6b,EAAQ,KAAK,MAAK,EAAG,UAAU,SAAUQ,GAAK7b,GAAG;AAK/C,oBAJI,OAAO6b,KAAQ,aACjBA,IAAM7b,IAGJ,CAAC6b,EAAI,YAAY;AAKnB,2BAJI3J,IAAQ2J,EAAI,MACZM,IAAQD,EAAchK,CAAK,GAC3B7F,IAAOwP,GAEJM,KAAS,SACdA,IAAQD,EAAc7P,EAAK,KAAK,QAAQ,CAAC,KAAK6P,EAAc,mBAAmB7P,EAAK,KAAK,QAAQ,CAAC,GAClG6P,EAAchK,CAAK,IAAIiK,GACvB9P,IAAOA,EAAK,OAAQ,EAAC,CAAC,GAClBA,KAAQ;AAAZ;AAIF,yBAAI8P,KAAS,OACJ;AAAA,oBACL,GAAGA,EAAM;AAAA,oBACT,GAAGA,EAAM;AAAA,kBACrB,IAEiB;AAAA,oBACL,GAAGN,EAAI,SAAS,GAAG;AAAA,oBACnB,GAAGA,EAAI,SAAS,GAAG;AAAA,kBAC/B;AAAA,gBAEO;AAAA,cACP,CAAK,GAEDE,KAEAL,IAAU,sBAAsBI,CAAe;AAAA,YACnD;AAKE,mBAAAxY,EAAO,YAAY,iBAAiB,WAAY;AAC9C,cAAI9D,EAAK,QAAQ,YAAY,aAC3Bkc,IAAU,sBAAsBI,CAAe;AAAA,YAErD,CAAG,GAEDxY,EAAO,UAAS,GAKZ,KAAK,QAAQ,YAAY,aAC3B9D,EAAK,QAAQ,KAAK,MAAK,EAAG,IAAI,SAAS,EAAE,gBAAgBA,GAAMA,EAAK,SAASoc,CAAY,GACzFH,IAAQ,KAGH;AAAA,UACT,GAGAH,EAAY,UAAU,kBAAkB,SAAUvb,GAAO;AAEvD,qBADIqc,IAAW,CAAA,GACNpc,IAAI,GAAGA,IAAID,EAAM,QAAQC;AAChC,cAAAoc,EAASrc,EAAMC,CAAC,EAAE,GAAI,CAAA,IAAI;AAE5B,gBAAIqc,IAAQtc,EAAM,OAAO,SAAU8b,GAAK7b,GAAG;AACzC,cAAI,OAAO6b,KAAQ,aACjBA,IAAM7b;AAGR,uBADIoB,IAASya,EAAI,OAAQ,EAAC,CAAC,GACpBza,KAAU,QAAM;AACrB,oBAAIgb,EAAShb,EAAO,GAAE,CAAE;AACtB,yBAAO;AAET,gBAAAA,IAASA,EAAO,OAAQ,EAAC,CAAC;AAAA,cAC3B;AACD,qBAAO;AAAA,YACX,CAAG;AAED,mBAAOib;AAAA,UACT,GAEAf,EAAY,UAAU,sBAAsB,SAAUla,GAAQtB,GAAUwD,GAAQ;AAE9E,qBADI5E,IAAOoB,EAAS,QACXE,IAAI,GAAGA,IAAItB,GAAMsB,KAAK;AAC7B,kBAAI8X,IAAWhY,EAASE,CAAC,GACrBsc,IAAuBxE,EAAS,YAChCyE,GAEAC,IAAa1E,EAAS,iBAAiB;AAAA,gBACzC,6BAA6B,KAAK,QAAQ;AAAA,cAChD,CAAK;AAgBD,kBAdIA,EAAS,gBAAgB,QAAQA,EAAS,YAAa,KAAI,OAC7DyE,IAAUnb,EAAO,IAAI,IAAIiT,EAAS/Q,EAAO,cAAc,IAAIhF,EAAOwZ,EAAS,SAAS,GAAG,IAAI0E,EAAW,IAAI,GAAG1E,EAAS,SAAS,GAAG,IAAI0E,EAAW,IAAI,CAAC,GAAG,IAAIzK,EAAW,WAAWyK,EAAW,CAAC,GAAG,WAAWA,EAAW,CAAC,CAAC,CAAC,CAAC,IAE5ND,IAAUnb,EAAO,IAAI,IAAIiT,EAAS,KAAK,YAAY,CAAC,GAGtDkI,EAAQ,KAAKzE,EAAS,KAAK,IAAI,GAE/ByE,EAAQ,cAAc,SAASzE,EAAS,IAAI,SAAS,CAAC,GACtDyE,EAAQ,aAAa,SAASzE,EAAS,IAAI,SAAS,CAAC,GACrDyE,EAAQ,eAAe,SAASzE,EAAS,IAAI,SAAS,CAAC,GACvDyE,EAAQ,gBAAgB,SAASzE,EAAS,IAAI,SAAS,CAAC,GAGpD,KAAK,QAAQ,+BACXA,EAAS,YAAY;AACvB,oBAAI2E,IAAa3E,EAAS,YAAY,EAAE,eAAe,IAAM,cAAc,IAAO,EAAE,GAChF4E,IAAc5E,EAAS,YAAY,EAAE,eAAe,IAAM,cAAc,IAAO,EAAE,GACjF6E,IAAW7E,EAAS,IAAI,aAAa;AACzC,gBAAAyE,EAAQ,aAAaE,GACrBF,EAAQ,cAAcG,GACtBH,EAAQ,WAAWI;AAAA,cACpB;AAcH,kBAVA,KAAK,UAAU7E,EAAS,KAAK,IAAI,CAAC,IAAIyE,GAElC,MAAMA,EAAQ,KAAK,CAAC,MACtBA,EAAQ,KAAK,IAAI,IAGf,MAAMA,EAAQ,KAAK,CAAC,MACtBA,EAAQ,KAAK,IAAI,IAGfD,KAAwB,QAAQA,EAAqB,SAAS,GAAG;AACnE,oBAAIM;AACJ,gBAAAA,IAActZ,EAAO,kBAAkB,IAAIA,EAAO,SAAQ,GAAIiZ,CAAO,GACrE,KAAK,oBAAoBK,GAAaN,GAAsBhZ,CAAM;AAAA,cACnE;AAAA,YACF;AAAA,UACH,GAKAgY,EAAY,UAAU,OAAO,WAAY;AACvC,wBAAK,UAAU,IAER;AAAA,UACT;AAEA,cAAIuB,IAAW,SAAkBC,GAAW;AAG1C,YAAAA,EAAU,UAAU,gBAAgBxB,CAAW;AAAA,UACjD;AAGA,UAAI,OAAO,YAAc,OACvBuB,EAAS,SAAS,GAGpBpgB,EAAO,UAAUogB;AAAA,QAEV;AAAA;AAAA,MACP,CAAU;AAAA;AAAA,EACV,CAAC;;;;;;"}